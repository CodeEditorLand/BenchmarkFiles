import type { StorybookConfig } from "@storybook/nextjs";
import path, { dirname, join } from "path";

const config: StorybookConfig = {
  stories: [
    "../intro.stories.mdx",
    "../../../packages/ui/components/**/*.stories.mdx", // legacy SB6 stories
    "../../../packages/ui/components/**/*.stories.@(js|jsx|ts|tsx)",
    "../../../packages/ui/components/**/*.docs.mdx",
    "../../../packages/features/**/*.stories.@(js|jsx|ts|tsx)",
    "../../../packages/features/**/*.docs.mdx",
    "../../../packages/atoms/**/*.stories.@(js|jsx|ts|tsx)",
    "../../../packages/atoms/**/*.docs.mdx",
  ],

  addons: [
    getAbsolutePath("@storybook/addon-links"),
    getAbsolutePath("@storybook/addon-essentials"),
    getAbsolutePath("@storybook/addon-interactions"),
    getAbsolutePath("storybook-addon-rtl-direction"),
    getAbsolutePath("storybook-react-i18next"),
  ],

  framework: {
    name: getAbsolutePath("@storybook/nextjs") as "@storybook/nextjs",

    options: {
      // builder: {
      //   fsCache: true,
      //   lazyCompilation: true,
      // },
    },
  },

  staticDirs: ["../public"],

  webpackFinal: async (config, { configType }) => {
    config.resolve = config.resolve || {};
    config.resolve.fallback = {
      fs: false,
      assert: false,
      buffer: false,
      console: false,
      constants: false,
      crypto: false,
      domain: false,
      events: false,
      http: false,
      https: false,
      os: false,
      path: false,
      punycode: false,
      process: false,
      querystring: false,
      stream: false,
      string_decoder: false,
      sys: false,
      timers: false,
      tty: false,
      url: false,
      util: false,
      vm: false,
      zlib: false,
    };

    config.module = config.module || {};
    config.module.rules = config.module.rules || [];
    config.module.rules.push({
      test: /\.css$/,
      use: [
        "style-loader",
        {
          loader: "css-loader",
          options: {
            modules: true, // Enable modules to help you using className
          },
        },
      ],
      include: path.resolve(__dirname, "../src"),
    });

    return config;
  },

  typescript: { reactDocgen: "react-docgen" },

  docs: {
    autodocs: true,
  },
};

export default config;

function getAbsolutePath(value) {
  return dirname(require.resolve(join(value, "package.json")));
}
export * from "./Examples";

export * from "./Note";

export * from "./VariantsTable";

export * from "./Title";

export * from "./CustomArgsTable";
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
import * as OpenAPISnippet from "openapi-snippet";

export const requestSnippets = {
  generators: {
    curl_bash: {
      title: "cURL (bash)",
      syntax: "bash",
    },
    curl_powershell: {
      title: "cURL (PowerShell)",
      syntax: "powershell",
    },
    curl_cmd: {
      title: "cURL (CMD)",
      syntax: "bash",
    },
    node: {
      title: "Node",
      syntax: "node",
    },
  },
  defaultExpanded: true,
  languages: ["node", "curl_bash"],
};
// Since swagger-ui-react was not configured to change the request snippets some workarounds required
// configuration will be added programatically
// Custom Plugin
export const SnippedGenerator = {
  statePlugins: {
    // extend some internals to gain information about current path, method and spec in the generator function metioned later
    spec: {
      wrapSelectors: {
        requestFor: (ori) => (state, path, method) => {
          return ori(path, method)
            ?.set("spec", state.get("json", {}))
            ?.setIn(["oasPathMethod", "path"], path)
            ?.setIn(["oasPathMethod", "method"], method);
        },
        mutatedRequestFor: (ori) => (state, path, method) => {
          return ori(path, method)
            ?.set("spec", state.get("json", {}))
            ?.setIn(["oasPathMethod", "path"], path)
            ?.setIn(["oasPathMethod", "method"], method);
        },
      },
    },
    // extend the request snippets core plugin
    requestSnippets: {
      wrapSelectors: {
        // add additional snippet generators here
        getSnippetGenerators:
          (ori, system) =>
          (state, ...args) =>
            ori(state, ...args)
              // add node native snippet generator
              //   .set(
              //     // key
              //     "node_native",
              //     // config and generator function
              //     system.Im.fromJS({
              //       title: "NodeJs Native",
              //       syntax: "javascript",
              //       hostname: "test",
              //       fn: (req) => {
              //         // get extended info about request
              //         const { spec, oasPathMethod } = req.toJS();
              //         const { path, method } = oasPathMethod;

              //         // run OpenAPISnippet for target node
              //         const targets = ["node_native"];
              //         let snippet;
              //         try {
              //           // set request snippet content
              //           snippet = OpenAPISnippet.getEndpointSnippets(
              //             spec,
              //             path,
              //             method,
              //             targets
              //             // Since I don't know why hostname was undefinedundefined, I harcoded it here
              //           ).snippets[0].content;
              //         } catch (err) {
              //           // set to error in case it happens the npm package has some flaws
              //           snippet = JSON.stringify(snippet);
              //         }
              //         // return stringified snipped
              //         return snippet;
              //       },
              //     })
              //   )
              .set(
                // key
                "node_fetch",
                // config and generator function
                system.Im.fromJS({
                  title: "NodeJS",
                  syntax: "javascript",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;

                    // run OpenAPISnippet for target node
                    const targets = ["node_fetch"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              )
              .set(
                // key
                "shell_httpie",
                // config and generator function
                system.Im.fromJS({
                  title: "HTTPie",
                  syntax: "bash",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;

                    // run OpenAPISnippet for target node
                    const targets = ["shell_httpie"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              )
              .set(
                // key
                "php_curl",
                // config and generator function
                system.Im.fromJS({
                  title: "PHP",
                  syntax: "php",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;

                    // run OpenAPISnippet for target node
                    const targets = ["php_curl"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              )
              .set(
                // key
                "java_okhttp",
                // config and generator function
                system.Im.fromJS({
                  title: "Java",
                  syntax: "java",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;
                    console.log(spec, oasPathMethod, path, method);
                    // run OpenAPISnippet for target node
                    const targets = ["java_okhttp"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              )
              //   .set(
              //     // key
              //     "java",
              //     // config and generator function
              //     system.Im.fromJS({
              //       title: "Java (Unirest)",
              //       syntax: "java",
              //       fn: (req) => {
              //         // get extended info about request
              //         const { spec, oasPathMethod } = req.toJS();
              //         const { path, method } = oasPathMethod;

              //         // run OpenAPISnippet for target node
              //         const targets = ["java"];
              //         let snippet;
              //         try {
              //           // set request snippet content
              //           snippet = OpenAPISnippet.getEndpointSnippets(
              //             spec,
              //             path,
              //             method,
              //             targets
              //           ).snippets[0].content;
              //         } catch (err) {
              //           // set to error in case it happens the npm package has some flaws
              //           snippet = JSON.stringify(snippet);
              //         }
              //         // return stringified snipped
              //         return snippet;
              //       },
              //     })
              //   )
              //   .set(
              //     // key
              //     "c_libcurl",
              //     // config and generator function
              //     system.Im.fromJS({
              //       title: "C (libcurl)  ",
              //       syntax: "bash",
              //       fn: (req) => {
              //         // get extended info about request
              //         const { spec, oasPathMethod } = req.toJS();
              //         const { path, method } = oasPathMethod;

              //         // run OpenAPISnippet for target node
              //         const targets = ["c_libcurl"];
              //         let snippet;
              //         try {
              //           // set request snippet content
              //           snippet = OpenAPISnippet.getEndpointSnippets(
              //             spec,
              //             path,
              //             method,
              //             targets
              //           ).snippets[0].content;
              //         } catch (err) {
              //           // set to error in case it happens the npm package has some flaws
              //           snippet = JSON.stringify(snippet);
              //         }
              //         // return stringified snipped
              //         return snippet;
              //       },
              //     })
              //   )
              .set(
                // key
                "go_native",
                // config and generator function
                system.Im.fromJS({
                  title: "Go",
                  syntax: "bash",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;

                    // run OpenAPISnippet for target node
                    const targets = ["go_native"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              )
              .set(
                // key
                "ruby",
                // config and generator function
                system.Im.fromJS({
                  title: "Ruby",
                  syntax: "ruby",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;

                    // run OpenAPISnippet for target node
                    const targets = ["ruby"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              )
              .set(
                // key
                "python",
                // config and generator function
                system.Im.fromJS({
                  title: "Python",
                  syntax: "python",
                  fn: (req) => {
                    // get extended info about request
                    const { spec, oasPathMethod } = req.toJS();

                    const { path, method } = oasPathMethod;

                    // run OpenAPISnippet for target node
                    const targets = ["python"];

                    let snippet;

                    try {
                      // set request snippet content
                      snippet = OpenAPISnippet.getEndpointSnippets(spec, path, method, targets).snippets[0]
                        .content;
                    } catch (err) {
                      // set to error in case it happens the npm package has some flaws
                      snippet = JSON.stringify(snippet);
                    }
                    // return stringified snipped
                    return snippet;
                  },
                })
              ),
      },
    },
  },
};
import { get } from "@vercel/edge-config";
import { collectEvents } from "next-collect/server";
import { cookies } from "next/headers";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

import { getLocale } from "@calcom/features/auth/lib/getLocale";
import { extendEventData, nextCollectBasicSettings } from "@calcom/lib/telemetry";

import { csp } from "@lib/csp";

import { abTestMiddlewareFactory } from "./abTest/middlewareFactory";

const middleware = async (req: NextRequest): Promise<NextResponse<unknown>> => {
  const url = req.nextUrl;
  const requestHeaders = new Headers(req.headers);

  requestHeaders.set("x-url", req.url);

  if (!url.pathname.startsWith("/api")) {
    //
    // NOTE: When tRPC hits an error a 500 is returned, when this is received
    //       by the application the user is automatically redirected to /auth/login.
    //
    //     - For this reason our matchers are sufficient for an app-wide maintenance page.
    //
    try {
      // Check whether the maintenance page should be shown
      const isInMaintenanceMode = await get<boolean>("isInMaintenanceMode");
      // If is in maintenance mode, point the url pathname to the maintenance page
      if (isInMaintenanceMode) {
        req.nextUrl.pathname = `/maintenance`;

        return NextResponse.rewrite(req.nextUrl);
      }
    } catch (error) {
      // show the default page if EDGE_CONFIG env var is missing,
      // but log the error to the console
      // console.error(error);
    }
  }

  const res = routingForms.handle(url);

  const { nonce } = csp(req, res ?? null);

  if (!process.env.CSP_POLICY) {
    req.headers.set("x-csp", "not-opted-in");
  } else if (!req.headers.get("x-csp")) {
    // If x-csp not set by gSSP, then it's initialPropsOnly
    req.headers.set("x-csp", "initialPropsOnly");
  } else {
    req.headers.set("x-csp", nonce ?? "");
  }

  if (res) {
    return res;
  }

  if (url.pathname.startsWith("/api/trpc/")) {
    requestHeaders.set("x-cal-timezone", req.headers.get("x-vercel-ip-timezone") ?? "");
  }

  if (url.pathname.startsWith("/auth/login") || url.pathname.startsWith("/login")) {
    // Use this header to actually enforce CSP, otherwise it is running in Report Only mode on all pages.
    requestHeaders.set("x-csp-enforce", "true");
  }

  if (url.pathname.startsWith("/future/apps/installed")) {
    const returnTo = req.cookies.get("return-to")?.value;

    if (returnTo !== undefined) {
      requestHeaders.set("Set-Cookie", "return-to=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT");

      let validPathname = returnTo;

      try {
        validPathname = new URL(returnTo).pathname;
      } catch (e) {}

      const nextUrl = url.clone();
      nextUrl.pathname = validPathname;
      return NextResponse.redirect(nextUrl, { headers: requestHeaders });
    }
  }

  if (url.pathname.startsWith("/future/auth/logout")) {
    cookies().delete("next-auth.session-token");
  }

  requestHeaders.set("x-pathname", url.pathname);

  const locale = await getLocale(req);

  requestHeaders.set("x-locale", locale);

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
  });
};

const routingForms = {
  handle: (url: URL) => {
    // Don't 404 old routing_forms links
    if (url.pathname.startsWith("/apps/routing_forms")) {
      url.pathname = url.pathname.replace(/^\/apps\/routing_forms($|\/)/, "/apps/routing-forms/");
      return NextResponse.rewrite(url);
    }
  },
};

export const config = {
  // Next.js Doesn't support spread operator in config matcher, so, we must list all paths explicitly here.
  // https://github.com/vercel/next.js/discussions/42458
  matcher: [
    "/:path*/embed",
    "/api/trpc/:path*",
    "/login",
    "/auth/login",
    "/future/auth/login",
    /**
     * Paths required by routingForms.handle
     */
    "/apps/routing_forms/:path*",

    "/event-types",
    "/future/event-types/",
    "/settings/admin/:path*",
    "/future/settings/admin/:path*",
    "/apps/installed/:category/",
    "/future/apps/installed/:category/",
    "/apps/:slug/",
    "/future/apps/:slug/",
    "/apps/:slug/setup/",
    "/future/apps/:slug/setup/",
    "/apps/categories/",
    "/future/apps/categories/",
    "/apps/categories/:category/",
    "/future/apps/categories/:category/",
    "/workflows/:path*",
    "/future/workflows/:path*",
    "/settings/teams/:path*",
    "/future/settings/teams/:path*",
    "/getting-started/:step/",
    "/future/getting-started/:step/",
    "/apps",
    "/future/apps",
    "/bookings/:status/",
    "/future/bookings/:status/",
    "/video/:path*",
    "/future/video/:path*",
    "/teams",
    "/future/teams/",
  ],
};

export default collectEvents({
  middleware: abTestMiddlewareFactory(middleware),
  ...nextCollectBasicSettings,
  cookieName: "__clnds",
  extend: extendEventData,
});
import type { AppRouter } from "@calcom/trpc/server/routers/_app";

import { createTRPCReact } from "@trpc/react-query";

export const trpc = createTRPCReact<AppRouter>({});
import type { TRPCContext } from "@calcom/trpc/server/createContext";
import { appRouter } from "@calcom/trpc/server/routers/_app";

export const getServerCaller = (ctx: TRPCContext) => appRouter.createCaller(ctx);

export type Params = {
  [param: string]: string | string[] | undefined;
};

export type SearchParams = {
  [param: string]: string | string[] | undefined;
};

export type PageProps = {
  params: Params;
  searchParams: SearchParams;
};

export type LayoutProps = { params: Params; children: React.ReactElement };
import { _generateMetadata } from "app/_utils";

import Page from "@calcom/features/ee/organizations/pages/settings/other-team-listing-view";

export const generateMetadata = async () =>
  await _generateMetadata(
    (t) => t("org_admin_other_teams"),
    (t) => t("org_admin_other_teams_description")
  );

export default Page;
import { _generateMetadata } from "app/_utils";

import Page from "@calcom/features/ee/teams/pages/team-listing-view";

export const generateMetadata = async () =>
  await _generateMetadata(
    (t) => t("teams"),
    (t) => t("create_manage_teams_collaborative")
  );

export default Page;
import prismaMock from "../../../../../tests/libs/__mocks__/prisma";

import type { Payment, Prisma, PaymentOption, Booking } from "@prisma/client";
import { v4 as uuidv4 } from "uuid";
import "vitest-fetch-mock";

import { sendAwaitingPaymentEmail } from "@calcom/emails";
import logger from "@calcom/lib/logger";
import type { CalendarEvent } from "@calcom/types/Calendar";
import type { IAbstractPaymentService } from "@calcom/types/PaymentService";

export function getMockPaymentService() {
  function createPaymentLink(/*{ paymentUid, name, email, date }*/) {
    return "http://mock-payment.example.com/";
  }
  const paymentUid = uuidv4();
  const externalId = uuidv4();

  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  class MockPaymentService implements IAbstractPaymentService {
    // TODO: We shouldn't need to implement adding a row to Payment table but that's a requirement right now.
    // We should actually delegate table creation to the core app. Here, only the payment app specific logic should come
    async create(
      payment: Pick<Prisma.PaymentUncheckedCreateInput, "amount" | "currency">,
      bookingId: Booking["id"],
      userId: Booking["userId"],
      username: string | null,
      bookerName: string | null,
      bookerEmail: string,
      paymentOption: PaymentOption
    ) {
      const paymentCreateData = {
        id: 1,
        uid: paymentUid,
        appId: null,
        bookingId,
        // booking       Booking?       @relation(fields: [bookingId], references: [id], onDelete: Cascade)
        fee: 10,
        success: true,
        refunded: false,
        data: {},
        externalId,
        paymentOption,
        amount: payment.amount,
        currency: payment.currency,
      };

      const paymentData = prismaMock.payment.create({
        data: paymentCreateData,
      });
      logger.silly("Created mock payment", JSON.stringify({ paymentData }));

      return paymentData;
    }
    async afterPayment(
      event: CalendarEvent,
      booking: {
        user: { email: string | null; name: string | null; timeZone: string } | null;
        id: number;
        startTime: { toISOString: () => string };
        uid: string;
      },
      paymentData: Payment
    ): Promise<void> {
      // TODO: App implementing PaymentService is supposed to send email by itself at the moment.
      await sendAwaitingPaymentEmail({
        ...event,
        paymentInfo: {
          link: createPaymentLink(/*{
            paymentUid: paymentData.uid,
            name: booking.user?.name,
            email: booking.user?.email,
            date: booking.startTime.toISOString(),
          }*/),
          paymentOption: paymentData.paymentOption || "ON_BOOKING",
          amount: paymentData.amount,
          currency: paymentData.currency,
        },
      });
    }
  }
  return {
    paymentUid,
    externalId,
    MockPaymentService,
  };
}
import { beforeEach, afterEach } from "vitest";

import {
  enableEmailFeature,
  mockNoTranslations,
} from "@calcom/web/test/utils/bookingScenario/bookingScenario";

export function setupAndTeardown() {
  beforeEach(() => {
    // Required to able to generate token in email in some cases
    //@ts-expect-error - It is a readonly variable
    process.env.CALENDSO_ENCRYPTION_KEY = "abcdefghjnmkljhjklmnhjklkmnbhjui";
    //@ts-expect-error - It is a readonly variable
    process.env.STRIPE_WEBHOOK_SECRET = "MOCK_STRIPE_WEBHOOK_SECRET";
    // We are setting it in vitest.config.ts because otherwise it's too late to set it.
    // process.env.DAILY_API_KEY = "MOCK_DAILY_API_KEY";

    // Ensure that Rate Limiting isn't enforced for tests
    delete process.env.UPSTASH_REDIS_REST_URL;
    mockNoTranslations();
    // mockEnableEmailFeature();
    enableEmailFeature();
    globalThis.testEmails = [];
    fetchMock.resetMocks();
  });
  afterEach(() => {
    //@ts-expect-error - It is a readonly variable
    delete process.env.CALENDSO_ENCRYPTION_KEY;
    //@ts-expect-error - It is a readonly variable
    delete process.env.STRIPE_WEBHOOK_SECRET;
    delete process.env.DAILY_API_KEY;
    globalThis.testEmails = [];
    fetchMock.resetMocks();
    // process.env.DAILY_API_KEY = "MOCK_DAILY_API_KEY";
  });
}
import { createMocks } from "node-mocks-http";

import type {
  CustomNextApiRequest,
  CustomNextApiResponse,
} from "@calcom/features/bookings/lib/handleNewBooking/test/fresh-booking.test";

export function createMockNextJsRequest(...args: Parameters<typeof createMocks>) {
  return createMocks<CustomNextApiRequest, CustomNextApiResponse>(...args);
}
import { getDate } from "@calcom/web/test/utils/bookingScenario/bookingScenario";

export const DEFAULT_TIMEZONE_BOOKER = "Asia/Kolkata";

export function getBasicMockRequestDataForBooking() {
  return {
    start: `${getDate({ dateIncrement: 1 }).dateString}T04:00:00.000Z`,
    end: `${getDate({ dateIncrement: 1 }).dateString}T04:30:00.000Z`,
    eventTypeSlug: "no-confirmation",
    timeZone: DEFAULT_TIMEZONE_BOOKER,
    language: "en",
    user: "teampro",
    metadata: {},
    hasHashedBookingLink: false,
    hashedLink: null,
  };
}
export function getMockRequestDataForBooking({
  data,
}: {
  data: Partial<ReturnType<typeof getBasicMockRequestDataForBooking>> & {
    eventTypeId: number;
    rescheduleUid?: string;
    bookingUid?: string;
    recurringEventId?: string;
    recurringCount?: number;
    responses: {
      email: string;
      name: string;
      location: { optionValue: ""; value: string };
    };
  };
}) {
  return {
    ...getBasicMockRequestDataForBooking(),
    ...data,
  };
}
import type z from "zod";

import type { schemaBookingCancelParams } from "@calcom/prisma/zod-utils";

export function getMockRequestDataForCancelBooking(data: z.infer<typeof schemaBookingCancelParams>) {
  return data;
}
import type { TestFunction } from "vitest";

import { WEBSITE_URL } from "@calcom/lib/constants";
import { test } from "@calcom/web/test/fixtures/fixtures";
import type { Fixtures } from "@calcom/web/test/fixtures/fixtures";
import { createOrganization } from "@calcom/web/test/utils/bookingScenario/bookingScenario";

const WEBSITE_PROTOCOL = new URL(WEBSITE_URL).protocol;

const _testWithAndWithoutOrg = (
  description: Parameters<typeof testWithAndWithoutOrg>[0],
  fn: Parameters<typeof testWithAndWithoutOrg>[1],
  timeout: Parameters<typeof testWithAndWithoutOrg>[2],
  mode: "only" | "skip" | "run" = "run"
) => {
  const t = mode === "only" ? test.only : mode === "skip" ? test.skip : test;
  t(
    `${description} - With org`,
    async ({ emails, meta, task, onTestFailed, expect, skip }) => {
      const org = await createOrganization({
        name: "Test Org",
        slug: "testorg",
      });

      await fn({
        meta,
        task,
        onTestFailed,
        expect,
        emails,
        skip,
        org: {
          organization: org,
          urlOrigin: `${WEBSITE_PROTOCOL}//${org.slug}.cal.local:3000`,
        },
      });
    },
    timeout
  );

  t(
    `${description}`,
    async ({ emails, meta, task, onTestFailed, expect, skip }) => {
      await fn({
        emails,
        meta,
        task,
        onTestFailed,
        expect,
        skip,
        org: null,
      });
    },
    timeout
  );
};

export const testWithAndWithoutOrg = (
  description: string,
  fn: TestFunction<
    Fixtures & {
      org: {
        organization: { id: number | null };
        urlOrigin?: string;
      } | null;
    }
  >,
  timeout?: number
) => {
  _testWithAndWithoutOrg(description, fn, timeout, "run");
};

testWithAndWithoutOrg.only = ((description, fn, timeout) => {
  _testWithAndWithoutOrg(description, fn, timeout, "only");
}) as typeof _testWithAndWithoutOrg;

testWithAndWithoutOrg.skip = ((description, fn, timeout) => {
  _testWithAndWithoutOrg(description, fn, timeout, "skip");
}) as typeof _testWithAndWithoutOrg;
import { UserPermissionRole } from "@calcom/prisma/client";
import { IdentityProvider } from "@calcom/prisma/enums";

export const getSampleUserInSession = function () {
  return {
    locale: "",
    avatar: "",
    organization: {
      isOrgAdmin: false,
      metadata: null,
    },
    defaultScheduleId: null,
    name: "",
    defaultBookerLayouts: null,
    timeZone: "Asia/Kolkata",
    selectedCalendars: [],
    destinationCalendar: null,
    emailVerified: new Date(),
    allowDynamicBooking: false,
    bio: "",
    weekStart: "",
    startTime: 0,
    endTime: 0,
    bufferTime: 0,
    hideBranding: false,
    timeFormat: 12,
    twoFactorEnabled: false,
    identityProvider: IdentityProvider.CAL,
    brandColor: "#292929",
    darkBrandColor: "#fafafa",
    away: false,
    metadata: null,
    role: UserPermissionRole.USER,
    disableImpersonation: false,
    organizationId: null,
    theme: "",
    createdDate: new Date(),
    trialEndsAt: new Date(),
    completedOnboarding: false,
    allowSEOIndexing: false,
    receiveMonthlyDigestEmail: false,
  };
};
import prismaMock from "../../../../../tests/libs/__mocks__/prisma";

import type { WebhookTriggerEvents, Booking, BookingReference, DestinationCalendar } from "@prisma/client";
import { parse } from "node-html-parser";
import type { VEvent } from "node-ical";
import ical from "node-ical";
import { expect, vi } from "vitest";
import "vitest-fetch-mock";

import dayjs from "@calcom/dayjs";
import { CAL_URL } from "@calcom/lib/constants";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import { BookingStatus } from "@calcom/prisma/enums";
import type { AppsStatus } from "@calcom/types/Calendar";
import type { CalendarEvent } from "@calcom/types/Calendar";
import type { Fixtures } from "@calcom/web/test/fixtures/fixtures";

import type { InputEventType, getOrganizer } from "./bookingScenario";
import { DEFAULT_TIMEZONE_BOOKER } from "./getMockRequestDataForBooking";

// This is too complex at the moment, I really need to simplify this.
// Maybe we can replace the exact match with a partial match approach that would be easier to maintain but we would still need Dayjs to do the timezone conversion
// Alternative could be that we use some other library to do the timezone conversion?
function formatDateToWhenFormat({ start, end }: { start: Date; end: Date }, timeZone: string) {
  const startTime = dayjs(start).tz(timeZone);
  return `${startTime.format(`dddd, LL`)} | ${startTime.format("h:mma")} - ${dayjs(end)
    .tz(timeZone)
    .format("h:mma")} (${timeZone})`;
}

type Recurrence = {
  freq: number;
  interval: number;
  count: number;
};
type ExpectedEmail = {
  /**
   * Checks the main heading of the email - Also referred to as title in code at some places
   */
  heading?: string;
  links?: { text: string; href: string }[];
  /**
   * Checks the sub heading of the email - Also referred to as subTitle in code
   */
  subHeading?: string;
  /**
   * Checks the <title> tag - Not sure what's the use of it, as it is not shown in UI it seems.
   */
  titleTag?: string;
  to: string;
  bookingTimeRange?: {
    start: Date;
    end: Date;
    timeZone: string;
  };
  // TODO: Implement these and more
  // what?: string;
  // when?: string;
  // who?: string;
  // where?: string;
  // additionalNotes?: string;
  // footer?: {
  //   rescheduleLink?: string;
  //   cancelLink?: string;
  // };
  ics?: {
    filename: string;
    iCalUID?: string;
    recurrence?: Recurrence;
    method: string;
  };
  /**
   * Checks that there is no
   */
  noIcs?: true;
  appsStatus?: AppsStatus[];
};
declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace jest {
    interface Matchers<R> {
      toHaveEmail(expectedEmail: ExpectedEmail, to: string): R;
    }
  }
}

expect.extend({
  toHaveEmail(emails: Fixtures["emails"], expectedEmail: ExpectedEmail, to: string) {
    const { isNot } = this;

    const testEmail = emails.get().find((email) => email.to.includes(to));

    const emailsToLog = emails
      .get()
      .map((email) => ({ to: email.to, html: email.html, ics: email.icalEvent }));

    if (!testEmail) {
      logger.silly("All Emails", JSON.stringify({ numEmails: emailsToLog.length, emailsToLog }));
      return {
        pass: false,
        message: () => `No email sent to ${to}. All emails are ${JSON.stringify(emailsToLog)}`,
      };
    }
    const ics = testEmail.icalEvent;

    const icsObject = ics?.content ? ical.sync.parseICS(ics?.content) : null;

    const iCalUidData = icsObject ? icsObject[expectedEmail.ics?.iCalUID || ""] : null;

    let isToAddressExpected = true;

    const isIcsFilenameExpected = expectedEmail.ics ? ics?.filename === expectedEmail.ics.filename : true;

    const isIcsUIDExpected =
      expectedEmail.ics && expectedEmail.ics.iCalUID
        ? !!(icsObject ? icsObject[expectedEmail.ics.iCalUID] : null)
        : true;

    const emailDom = parse(testEmail.html);

    const actualEmailContent = {
      titleTag: emailDom.querySelector("title")?.innerText,
      heading: emailDom.querySelector('[data-testid="heading"]')?.innerText,
      subHeading: emailDom.querySelector('[data-testid="subHeading"]')?.innerText,
      when: emailDom.querySelector('[data-testid="when"]')?.innerText,
      links: emailDom.querySelectorAll("a[href]").map((link) => ({
        text: link.innerText,
        href: link.getAttribute("href"),
      })),
    };

    const expectedEmailContent = getExpectedEmailContent(expectedEmail);
    assertHasRecurrence(expectedEmail.ics?.recurrence, (iCalUidData as VEvent)?.rrule?.toString() || "");

    const isEmailContentMatched = this.equals(
      actualEmailContent,
      expect.objectContaining(expectedEmailContent)
    );

    if (!isEmailContentMatched) {
      logger.silly("All Emails", JSON.stringify({ numEmails: emailsToLog.length, emailsToLog }));

      return {
        pass: false,
        message: () => `Email content ${isNot ? "is" : "is not"} matching. ${JSON.stringify(emailsToLog)}`,
        actual: actualEmailContent,
        expected: expectedEmailContent,
      };
    }

    isToAddressExpected = expectedEmail.to === testEmail.to;

    if (!isToAddressExpected) {
      logger.silly("All Emails", JSON.stringify({ numEmails: emailsToLog.length, emailsToLog }));
      return {
        pass: false,
        message: () => `To address ${isNot ? "is" : "is not"} matching`,
        actual: testEmail.to,
        expected: expectedEmail.to,
      };
    }

    if (!expectedEmail.noIcs && !isIcsFilenameExpected) {
      return {
        pass: false,
        actual: ics?.filename,
        expected: expectedEmail.ics?.filename,
        message: () => `ICS Filename ${isNot ? "is" : "is not"} matching`,
      };
    }

    if (!expectedEmail.noIcs && !isIcsUIDExpected) {
      const icsObjectKeys = icsObject ? Object.keys(icsObject) : [];
      const icsKey = icsObjectKeys.find((key) => key !== "vcalendar");
      if (!icsKey) throw new Error("icsKey not found");
      return {
        pass: false,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        actual: icsObject[icsKey].uid!,
        expected: expectedEmail.ics?.iCalUID,
        message: () => `Expected ICS UID ${isNot ? "is" : "isn't"} present in actual`,
      };
    }

    if (expectedEmail.noIcs && ics) {
      return {
        pass: false,
        message: () => `${isNot ? "" : "Not"} expected ics file ${JSON.stringify(ics)}`,
      };
    }

    if (expectedEmail.appsStatus) {
      const actualAppsStatus = emailDom.querySelectorAll('[data-testid="appsStatus"] li').map((li) => {
        return li.innerText.trim();
      });
      const expectedAppStatus = expectedEmail.appsStatus.map((appStatus) => {
        if (appStatus.success && !appStatus.failures) {
          return `${appStatus.appName} ✅`;
        }
        return `${appStatus.appName} ❌`;
      });

      const isAppsStatusCorrect = this.equals(actualAppsStatus, expectedAppStatus);

      if (!isAppsStatusCorrect) {
        return {
          pass: false,
          actual: actualAppsStatus,
          expected: expectedAppStatus,
          message: () => `AppsStatus ${isNot ? "is" : "isn't"} matching`,
        };
      }
    }

    return {
      pass: true,
      message: () => `Email ${isNot ? "is" : "isn't"} correct`,
    };

    function getExpectedEmailContent(expectedEmail: ExpectedEmail) {
      const bookingTimeRange = expectedEmail.bookingTimeRange;
      const when = bookingTimeRange
        ? formatDateToWhenFormat(
            {
              start: bookingTimeRange.start,
              end: bookingTimeRange.end,
            },
            bookingTimeRange.timeZone
          )
        : null;

      const expectedEmailContent = {
        titleTag: expectedEmail.titleTag,
        heading: expectedEmail.heading,
        subHeading: expectedEmail.subHeading,
        when: when ? (expectedEmail.ics?.recurrence ? `starting ${when}` : `${when}`) : undefined,
        links: expect.arrayContaining(expectedEmail.links || []),
      };
      // Remove undefined props so that they aren't matched, they are intentionally left undefined because we don't want to match them
      Object.keys(expectedEmailContent).filter((key) => {
        if (expectedEmailContent[key as keyof typeof expectedEmailContent] === undefined) {
          delete expectedEmailContent[key as keyof typeof expectedEmailContent];
        }
      });
      return expectedEmailContent;
    }

    function assertHasRecurrence(expectedRecurrence: Recurrence | null | undefined, rrule: string) {
      if (!expectedRecurrence) {
        return;
      }

      const expectedRrule = `FREQ=${
        expectedRecurrence.freq === 0 ? "YEARLY" : expectedRecurrence.freq === 1 ? "MONTHLY" : "WEEKLY"
      };COUNT=${expectedRecurrence.count};INTERVAL=${expectedRecurrence.interval}`;

      logger.silly({
        expectedRrule,
        rrule,
      });
      expect(rrule).toContain(expectedRrule);
    }
  },
});

export function expectWebhookToHaveBeenCalledWith(
  subscriberUrl: string,
  data: {
    triggerEvent: WebhookTriggerEvents;
    payload: Record<string, unknown> | null;
  }
) {
  const fetchCalls = fetchMock.mock.calls;
  const webhooksToSubscriberUrl = fetchCalls.filter((call) => {
    return call[0] === subscriberUrl;
  });
  logger.silly("Scanning fetchCalls for webhook", safeStringify(fetchCalls));
  const webhookFetchCall = webhooksToSubscriberUrl.find((call) => {
    const body = call[1]?.body;

    const parsedBody = JSON.parse((body as string) || "{}");

    return parsedBody.triggerEvent === data.triggerEvent;
  });

  if (!webhookFetchCall) {
    throw new Error(
      `Webhook not sent to ${subscriberUrl} for ${data.triggerEvent}. All webhooks: ${JSON.stringify(
        webhooksToSubscriberUrl
      )}`
    );
  }
  expect(webhookFetchCall[0]).toBe(subscriberUrl);
  const body = webhookFetchCall[1]?.body;
  const parsedBody = JSON.parse((body as string) || "{}");

  expect(parsedBody.triggerEvent).toBe(data.triggerEvent);

  if (parsedBody.payload.metadata?.videoCallUrl) {
    parsedBody.payload.metadata.videoCallUrl = parsedBody.payload.metadata.videoCallUrl
      ? parsedBody.payload.metadata.videoCallUrl
      : parsedBody.payload.metadata.videoCallUrl;
  }
  if (data.payload) {
    if (data.payload.metadata !== undefined) {
      expect(parsedBody.payload.metadata).toEqual(expect.objectContaining(data.payload.metadata));
    }
    if (data.payload.responses !== undefined)
      expect(parsedBody.payload.responses).toEqual(expect.objectContaining(data.payload.responses));

    const { responses: _1, metadata: _2, ...remainingPayload } = data.payload;
    expect(parsedBody.payload).toEqual(expect.objectContaining(remainingPayload));
  }
}

export function expectWorkflowToBeTriggered({
  emails,
  organizer,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string; timeZone: string };
}) {
  const subjectPattern = /^Reminder: /i;
  expect(emails.get()).toEqual(
    expect.arrayContaining([
      expect.objectContaining({
        subject: expect.stringMatching(subjectPattern),
        to: organizer.email,
      }),
    ])
  );
}

export function expectWorkflowToBeNotTriggered({
  emails,
  organizer,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string; timeZone: string };
}) {
  const subjectPattern = /^Reminder: /i;

  expect(emails.get()).not.toEqual(
    expect.arrayContaining([
      expect.objectContaining({
        subject: expect.stringMatching(subjectPattern),
        to: organizer.email,
      }),
    ])
  );
}

export async function expectBookingToBeInDatabase(
  booking: Partial<Booking> & Pick<Booking, "uid"> & { references?: Partial<BookingReference>[] }
) {
  const actualBooking = await prismaMock.booking.findUnique({
    where: {
      uid: booking.uid,
    },
    include: {
      references: true,
    },
  });

  const { references, ...remainingBooking } = booking;
  expect(actualBooking).toEqual(expect.objectContaining(remainingBooking));
  expect(actualBooking?.references).toEqual(
    expect.arrayContaining((references || []).map((reference) => expect.objectContaining(reference)))
  );
}

export function expectSuccessfulBookingCreationEmails({
  emails,
  organizer,
  booker,
  guests,
  otherTeamMembers,
  iCalUID,
  recurrence,
  bookingTimeRange,
  booking,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string; timeZone: string };
  booker: { email: string; name: string; timeZone?: string };
  guests?: { email: string; name: string; timeZone?: string }[];
  otherTeamMembers?: { email: string; name: string; timeZone?: string }[];
  iCalUID: string;
  recurrence?: Recurrence;
  eventDomain?: string;
  bookingTimeRange?: { start: Date; end: Date };
  booking: { uid: string; urlOrigin?: string };
}) {
  const bookingUrlOrigin = booking.urlOrigin || CAL_URL;
  expect(emails).toHaveEmail(
    {
      titleTag: "confirmed_event_type_subject",
      heading: recurrence ? "new_event_scheduled_recurring" : "new_event_scheduled",
      subHeading: "",
      links: recurrence
        ? [
            {
              href: `${bookingUrlOrigin}/booking/${booking.uid}?cancel=true&allRemainingBookings=true`,
              text: "cancel",
            },
          ]
        : [
            {
              href: `${bookingUrlOrigin}/reschedule/${booking.uid}`,
              text: "reschedule",
            },
          ],
      ...(bookingTimeRange
        ? {
            bookingTimeRange: {
              ...bookingTimeRange,
              timeZone: organizer.timeZone,
            },
          }
        : null),
      to: `${organizer.email}`,
      ics: {
        filename: "event.ics",
        iCalUID: `${iCalUID}`,
        recurrence,
        method: "REQUEST",
      },
    },
    `${organizer.email}`
  );

  expect(emails).toHaveEmail(
    {
      titleTag: "confirmed_event_type_subject",
      heading: recurrence ? "your_event_has_been_scheduled_recurring" : "your_event_has_been_scheduled",
      subHeading: "emailed_you_and_any_other_attendees",
      ...(bookingTimeRange
        ? {
            bookingTimeRange: {
              ...bookingTimeRange,
              // Using the default timezone
              timeZone: booker.timeZone || DEFAULT_TIMEZONE_BOOKER,
            },
          }
        : null),
      to: `${booker.name} <${booker.email}>`,
      ics: {
        filename: "event.ics",
        iCalUID: `${iCalUID}`,
        recurrence,
        method: "REQUEST",
      },
      links: recurrence
        ? [
            {
              href: `${bookingUrlOrigin}/booking/${booking.uid}?cancel=true&allRemainingBookings=true`,
              text: "cancel",
            },
          ]
        : [
            {
              href: `${bookingUrlOrigin}/reschedule/${booking.uid}`,
              text: "reschedule",
            },
          ],
    },
    `${booker.name} <${booker.email}>`
  );

  if (otherTeamMembers) {
    otherTeamMembers.forEach((otherTeamMember) => {
      expect(emails).toHaveEmail(
        {
          titleTag: "confirmed_event_type_subject",
          heading: recurrence ? "new_event_scheduled_recurring" : "new_event_scheduled",
          subHeading: "",
          ...(bookingTimeRange
            ? {
                bookingTimeRange: {
                  ...bookingTimeRange,
                  timeZone: otherTeamMember.timeZone || DEFAULT_TIMEZONE_BOOKER,
                },
              }
            : null),
          // Don't know why but organizer and team members of the eventType don'thave their name here like Booker
          to: `${otherTeamMember.email}`,
          ics: {
            filename: "event.ics",
            iCalUID: `${iCalUID}`,
            method: "REQUEST",
          },
          links: [
            {
              href: `${bookingUrlOrigin}/reschedule/${booking.uid}`,
              text: "reschedule",
            },
            {
              href: `${bookingUrlOrigin}/booking/${booking.uid}?cancel=true&allRemainingBookings=false`,
              text: "cancel",
            },
          ],
        },
        `${otherTeamMember.email}`
      );
    });
  }

  if (guests) {
    guests.forEach((guest) => {
      expect(emails).toHaveEmail(
        {
          titleTag: "confirmed_event_type_subject",
          heading: recurrence ? "your_event_has_been_scheduled_recurring" : "your_event_has_been_scheduled",
          subHeading: "emailed_you_and_any_other_attendees",
          ...(bookingTimeRange
            ? {
                bookingTimeRange: {
                  ...bookingTimeRange,
                  timeZone: guest.timeZone || DEFAULT_TIMEZONE_BOOKER,
                },
              }
            : null),
          to: `${guest.email}`,
          ics: {
            filename: "event.ics",
            iCalUID: `${iCalUID}`,
            method: "REQUEST",
          },
        },
        `${guest.name} <${guest.email}`
      );
    });
  }
}

export function expectBrokenIntegrationEmails({
  emails,
  organizer,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string };
}) {
  // Broken Integration email is only sent to the Organizer
  expect(emails).toHaveEmail(
    {
      titleTag: "broken_integration",
      to: `${organizer.email}`,
      // No ics goes in case of broken integration email it seems
      // ics: {
      //   filename: "event.ics",
      //   iCalUID: iCalUID,
      // },
    },
    `${organizer.email}`
  );

  // expect(emails).toHaveEmail(
  //   {
  //     title: "confirmed_event_type_subject",
  //     to: `${booker.name} <${booker.email}>`,
  //   },
  //   `${booker.name} <${booker.email}>`
  // );
}

export function expectCalendarEventCreationFailureEmails({
  emails,
  organizer,
  booker,
  iCalUID,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
  iCalUID: string;
}) {
  expect(emails).toHaveEmail(
    {
      titleTag: "broken_integration",
      to: `${organizer.email}`,
      ics: {
        filename: "event.ics",
        iCalUID,
        method: "REQUEST",
      },
    },
    `${organizer.email}`
  );

  expect(emails).toHaveEmail(
    {
      titleTag: "calendar_event_creation_failure_subject",
      to: `${booker.name} <${booker.email}>`,
      ics: {
        filename: "event.ics",
        iCalUID,
        method: "REQUEST",
      },
    },
    `${booker.name} <${booker.email}>`
  );
}

export function expectSuccessfulRoundRobinReschedulingEmails({
  emails,
  newOrganizer,
  prevOrganizer,
}: {
  emails: Fixtures["emails"];
  newOrganizer: { email: string; name: string };
  prevOrganizer: { email: string; name: string };
}) {
  if (newOrganizer !== prevOrganizer) {
    vi.waitFor(() => {
      // new organizer should recieve scheduling emails
      expect(emails).toHaveEmail(
        {
          heading: "new_event_scheduled",
          to: `${newOrganizer.email}`,
        },
        `${newOrganizer.email}`
      );
    });

    vi.waitFor(() => {
      // old organizer should recieve cancelled emails
      expect(emails).toHaveEmail(
        {
          heading: "event_request_cancelled",
          to: `${prevOrganizer.email}`,
        },
        `${prevOrganizer.email}`
      );
    });
  } else {
    vi.waitFor(() => {
      // organizer should recieve rescheduled emails
      expect(emails).toHaveEmail(
        {
          heading: "event_has_been_rescheduled",
          to: `${newOrganizer.email}`,
        },
        `${newOrganizer.email}`
      );
    });
  }
}

export function expectSuccessfulBookingRescheduledEmails({
  emails,
  organizer,
  booker,
  iCalUID,
  appsStatus,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
  iCalUID: string;
  appsStatus?: AppsStatus[];
}) {
  expect(emails).toHaveEmail(
    {
      titleTag: "event_type_has_been_rescheduled_on_time_date",
      to: `${organizer.email}`,
      ics: {
        filename: "event.ics",
        iCalUID,
        method: "REQUEST",
      },
      appsStatus,
    },
    `${organizer.email}`
  );

  expect(emails).toHaveEmail(
    {
      titleTag: "event_type_has_been_rescheduled_on_time_date",
      to: `${booker.name} <${booker.email}>`,
      ics: {
        filename: "event.ics",
        iCalUID,
        method: "REQUEST",
      },
    },
    `${booker.name} <${booker.email}>`
  );
}

export function expectAwaitingPaymentEmails({
  emails,
  booker,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
}) {
  expect(emails).toHaveEmail(
    {
      titleTag: "awaiting_payment_subject",
      to: `${booker.name} <${booker.email}>`,
      noIcs: true,
    },
    `${booker.email}`
  );
}

export function expectBookingRequestedEmails({
  emails,
  organizer,
  booker,
}: {
  emails: Fixtures["emails"];
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
}) {
  expect(emails).toHaveEmail(
    {
      titleTag: "event_awaiting_approval_subject",
      to: `${organizer.email}`,
      noIcs: true,
    },
    `${organizer.email}`
  );

  expect(emails).toHaveEmail(
    {
      titleTag: "booking_submitted_subject",
      to: `${booker.email}`,
      noIcs: true,
    },
    `${booker.email}`
  );
}

export function expectBookingRequestRescheduledEmails({
  emails,
  loggedInUser,
  booker,
  booking,
  bookNewTimePath,
  organizer,
}: {
  emails: Fixtures["emails"];
  organizer: ReturnType<typeof getOrganizer>;
  loggedInUser: {
    email: string;
    name: string;
  };
  booker: { email: string; name: string };
  booking: { uid: string; urlOrigin?: string };
  bookNewTimePath: string;
}) {
  const bookingUrlOrigin = booking.urlOrigin || CAL_URL;

  expect(emails).toHaveEmail(
    {
      titleTag: "rescheduled_event_type_subject",
      heading: "request_reschedule_booking",
      subHeading: "request_reschedule_subtitle",
      links: [
        {
          href: `${bookingUrlOrigin}${bookNewTimePath}?rescheduleUid=${booking.uid}`,
          text: "Book a new time",
        },
      ],
      to: `${booker.email}`,
      ics: {
        filename: "event.ics",
        method: "REQUEST",
      },
    },
    `${booker.email}`
  );

  expect(emails).toHaveEmail(
    {
      titleTag: "rescheduled_event_type_subject",
      heading: "request_reschedule_title_organizer",
      subHeading: "request_reschedule_subtitle_organizer",
      to: `${loggedInUser.email}`,
      ics: {
        filename: "event.ics",
        method: "REQUEST",
      },
    },
    `${loggedInUser.email}`
  );
}

export function expectBookingRequestedWebhookToHaveBeenFired({
  booker,
  location,
  subscriberUrl,
  paidEvent,
  eventType,
}: {
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
  subscriberUrl: string;
  location: string;
  paidEvent?: boolean;
  eventType: InputEventType;
}) {
  // There is an inconsistency in the way we send the data to the webhook for paid events and unpaid events. Fix that and then remove this if statement.
  if (!paidEvent) {
    expectWebhookToHaveBeenCalledWith(subscriberUrl, {
      triggerEvent: "BOOKING_REQUESTED",
      payload: {
        eventTitle: eventType.title,
        eventDescription: eventType.description,
        metadata: {
          // In a Pending Booking Request, we don't send the video call url
        },
        responses: {
          name: { label: "your_name", value: booker.name },
          email: { label: "email_address", value: booker.email },
          location: {
            label: "location",
            value: { optionValue: "", value: location },
          },
        },
      },
    });
  } else {
    expectWebhookToHaveBeenCalledWith(subscriberUrl, {
      triggerEvent: "BOOKING_REQUESTED",
      payload: {
        eventTitle: eventType.title,
        eventDescription: eventType.description,
        metadata: {
          // In a Pending Booking Request, we don't send the video call url
        },
        responses: {
          name: { label: "name", value: booker.name },
          email: { label: "email", value: booker.email },
          location: {
            label: "location",
            value: { optionValue: "", value: location },
          },
        },
      },
    });
  }
}

export function expectBookingCreatedWebhookToHaveBeenFired({
  booker,
  location,
  subscriberUrl,
  paidEvent,
  videoCallUrl,
}: {
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
  subscriberUrl: string;
  location: string;
  paidEvent?: boolean;
  videoCallUrl?: string | null;
}) {
  if (!paidEvent) {
    expectWebhookToHaveBeenCalledWith(subscriberUrl, {
      triggerEvent: "BOOKING_CREATED",
      payload: {
        metadata: {
          ...(videoCallUrl ? { videoCallUrl } : null),
        },
        responses: {
          name: { label: "your_name", value: booker.name },
          email: { label: "email_address", value: booker.email },
          location: {
            label: "location",
            value: { optionValue: "", value: location },
          },
        },
      },
    });
  } else {
    expectWebhookToHaveBeenCalledWith(subscriberUrl, {
      triggerEvent: "BOOKING_CREATED",
      payload: {
        // FIXME: File this bug and link ticket here. This is a bug in the code. metadata must be sent here like other BOOKING_CREATED webhook
        metadata: null,
        responses: {
          name: { label: "name", value: booker.name },
          email: { label: "email", value: booker.email },
          location: {
            label: "location",
            value: { optionValue: "", value: location },
          },
        },
      },
    });
  }
}

export function expectBookingRescheduledWebhookToHaveBeenFired({
  booker,
  location,
  subscriberUrl,
  videoCallUrl,
  payload,
}: {
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
  subscriberUrl: string;
  location: string;
  paidEvent?: boolean;
  videoCallUrl?: string;
  payload?: Record<string, unknown>;
}) {
  expectWebhookToHaveBeenCalledWith(subscriberUrl, {
    triggerEvent: "BOOKING_RESCHEDULED",
    payload: {
      ...payload,
      metadata: {
        ...(videoCallUrl ? { videoCallUrl } : null),
      },
      responses: {
        name: { label: "your_name", value: booker.name },
        email: { label: "email_address", value: booker.email },
        location: {
          label: "location",
          value: { optionValue: "", value: location },
        },
      },
    },
  });
}

export function expectBookingPaymentIntiatedWebhookToHaveBeenFired({
  booker,
  location,
  subscriberUrl,
  paymentId,
}: {
  organizer: { email: string; name: string };
  booker: { email: string; name: string };
  subscriberUrl: string;
  location: string;
  paymentId: number;
}) {
  expectWebhookToHaveBeenCalledWith(subscriberUrl, {
    triggerEvent: "BOOKING_PAYMENT_INITIATED",
    payload: {
      paymentId: paymentId,
      metadata: {
        // In a Pending Booking Request, we don't send the video call url
      },
      responses: {
        name: { label: "your_name", value: booker.name },
        email: { label: "email_address", value: booker.email },
        location: {
          label: "location",
          value: { optionValue: "", value: location },
        },
      },
    },
  });
}

export function expectSuccessfulCalendarEventCreationInCalendar(
  calendarMock: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createEventCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateEventCalls: any[];
  },
  expected:
    | {
        calendarId?: string | null;
        videoCallUrl: string;
        destinationCalendars?: Partial<DestinationCalendar>[];
      }
    | {
        calendarId?: string | null;
        videoCallUrl: string;
        destinationCalendars?: Partial<DestinationCalendar>[];
      }[]
) {
  const expecteds = expected instanceof Array ? expected : [expected];
  expect(calendarMock.createEventCalls.length).toBe(expecteds.length);
  for (let i = 0; i < calendarMock.createEventCalls.length; i++) {
    const expected = expecteds[i];

    const calEvent = calendarMock.createEventCalls[i][0];

    expect(calEvent).toEqual(
      expect.objectContaining({
        destinationCalendar: expected.calendarId
          ? [
              expect.objectContaining({
                externalId: expected.calendarId,
              }),
            ]
          : expected.destinationCalendars
          ? expect.arrayContaining(expected.destinationCalendars.map((cal) => expect.objectContaining(cal)))
          : null,
        videoCallData: expect.objectContaining({
          url: expected.videoCallUrl,
        }),
      })
    );
  }
}

export function expectSuccessfulCalendarEventUpdationInCalendar(
  calendarMock: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createEventCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateEventCalls: any[];
  },
  expected: {
    externalCalendarId: string;
    calEvent: Partial<CalendarEvent>;
    uid: string;
  }
) {
  expect(calendarMock.updateEventCalls.length).toBe(1);
  const call = calendarMock.updateEventCalls[0];
  const uid = call[0];
  const calendarEvent = call[1];
  const externalId = call[2];
  expect(uid).toBe(expected.uid);
  expect(calendarEvent).toEqual(expect.objectContaining(expected.calEvent));
  expect(externalId).toBe(expected.externalCalendarId);
}

export function expectSuccessfulCalendarEventDeletionInCalendar(
  calendarMock: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createEventCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateEventCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    deleteEventCalls: any[];
  },
  expected: {
    externalCalendarId: string;
    calEvent: Partial<CalendarEvent>;
    uid: string;
  }
) {
  expect(calendarMock.deleteEventCalls.length).toBe(1);
  const call = calendarMock.deleteEventCalls[0];
  const uid = call[0];
  const calendarEvent = call[1];
  const externalId = call[2];
  expect(uid).toBe(expected.uid);
  expect(calendarEvent).toEqual(expect.objectContaining(expected.calEvent));
  expect(externalId).toBe(expected.externalCalendarId);
}

export function expectSuccessfulVideoMeetingCreation(
  videoMock: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createMeetingCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateMeetingCalls: any[];
  },
  expected: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    credential: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    calEvent: any;
  }
) {
  expect(videoMock.createMeetingCalls.length).toBe(1);
  const call = videoMock.createMeetingCalls[0];
  const callArgs = call.args;
  const calEvent = callArgs[0];
  const credential = call.credential;

  expect(credential).toEqual(expected.credential);
  expect(calEvent).toEqual(expected.calEvent);
}

export function expectSuccessfulVideoMeetingUpdationInCalendar(
  videoMock: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createMeetingCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateMeetingCalls: any[];
  },
  expected: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    bookingRef: any;
    calEvent: Partial<CalendarEvent>;
  }
) {
  expect(videoMock.updateMeetingCalls.length).toBe(1);
  const call = videoMock.updateMeetingCalls[0];
  const bookingRef = call.args[0];
  const calendarEvent = call.args[1];
  expect(bookingRef).toEqual(expect.objectContaining(expected.bookingRef));
  expect(calendarEvent).toEqual(expect.objectContaining(expected.calEvent));
}

export function expectSuccessfulVideoMeetingDeletionInCalendar(
  videoMock: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    createMeetingCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    updateMeetingCalls: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    deleteMeetingCalls: any[];
  },
  expected: {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    bookingRef: any;
  }
) {
  expect(videoMock.deleteMeetingCalls.length).toBe(1);
  const call = videoMock.deleteMeetingCalls[0];
  const bookingRefUid = call.args[0];
  expect(bookingRefUid).toEqual(expected.bookingRef.uid);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function expectBookingInDBToBeRescheduledFromTo({ from, to }: { from: any; to: any }) {
  // Expect previous booking to be cancelled
  await expectBookingToBeInDatabase({
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ...from,
    status: BookingStatus.CANCELLED,
  });

  // Expect new booking to be created but status would depend on whether the new booking requires confirmation or not.
  await expectBookingToBeInDatabase({
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    ...to,
  });
}

export function expectICalUIDAsString(iCalUID: string | undefined | null) {
  if (typeof iCalUID !== "string") {
    throw new Error("iCalUID is not a string");
  }

  return iCalUID;
}
import appStoreMock from "../../../../../tests/libs/__mocks__/app-store";
import i18nMock from "../../../../../tests/libs/__mocks__/libServerI18n";
import prismock from "../../../../../tests/libs/__mocks__/prisma";

import type { BookingReference, Attendee, Booking, Membership } from "@prisma/client";
import type { Prisma } from "@prisma/client";
import type { WebhookTriggerEvents } from "@prisma/client";
import type Stripe from "stripe";
import type { getMockRequestDataForBooking } from "test/utils/bookingScenario/getMockRequestDataForBooking";
import { v4 as uuidv4 } from "uuid";
import "vitest-fetch-mock";

import { appStoreMetadata } from "@calcom/app-store/appStoreMetaData";
import { handleStripePaymentSuccess } from "@calcom/features/ee/payments/api/webhook";
import { weekdayToWeekIndex, type WeekDays } from "@calcom/lib/date-fns";
import type { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import type { WorkflowActions, WorkflowTemplates, WorkflowTriggerEvents } from "@calcom/prisma/client";
import type { SchedulingType } from "@calcom/prisma/enums";
import type { BookingStatus } from "@calcom/prisma/enums";
import type { userMetadataType } from "@calcom/prisma/zod-utils";
import type { AppMeta } from "@calcom/types/App";
import type { NewCalendarEventType } from "@calcom/types/Calendar";
import type { EventBusyDate, IntervalLimit } from "@calcom/types/Calendar";

import { getMockPaymentService } from "./MockPaymentService";

logger.settings.minLevel = 0;

const log = logger.getSubLogger({ prefix: ["[bookingScenario]"] });

type InputWebhook = {
  appId: string | null;
  userId?: number | null;
  teamId?: number | null;
  eventTypeId?: number;
  active: boolean;
  eventTriggers: WebhookTriggerEvents[];
  subscriberUrl: string;
};

type InputWorkflow = {
  userId?: number | null;
  teamId?: number | null;
  name?: string;
  activeEventTypeId?: number;
  trigger: WorkflowTriggerEvents;
  action: WorkflowActions;
  template: WorkflowTemplates;
};
/**
 * Data to be mocked
 */
export type ScenarioData = {
  // hosts: { id: number; eventTypeId?: number; userId?: number; isFixed?: boolean }[];
  /**
   * Prisma would return these eventTypes
   */
  eventTypes: InputEventType[];
  /**
   * Prisma would return these users
   */
  users: InputUser[];
  /**
   * Prisma would return these apps
   */
  apps?: Partial<AppMeta>[];
  bookings?: InputBooking[];
  webhooks?: InputWebhook[];
  workflows?: InputWorkflow[];
};

type InputCredential = typeof TestData.credentials.google & {
  id?: number;
};

type InputSelectedCalendar = typeof TestData.selectedCalendars.google;

type InputUser = Omit<typeof TestData.users.example, "defaultScheduleId"> & {
  id: number;
  defaultScheduleId?: number | null;
  credentials?: InputCredential[];
  organizationId?: number | null;
  selectedCalendars?: InputSelectedCalendar[];
  teams?: {
    membership: Partial<Membership>;
    team: {
      id: number;
      name: string;
      slug: string;
    };
  }[];
  schedules: {
    // Allows giving id in the input directly so that it can be referenced somewhere else as well
    id?: number;
    name: string;
    availability: {
      days: number[];
      startTime: Date;
      endTime: Date;
      date: string | null;
    }[];
    timeZone: string;
  }[];
  destinationCalendar?: Prisma.DestinationCalendarCreateInput;
  weekStart?: string;
};

export type InputEventType = {
  id: number;
  title?: string;
  length?: number;
  offsetStart?: number;
  slotInterval?: number;
  minimumBookingNotice?: number;
  /**
   * These user ids are `ScenarioData["users"]["id"]`
   */
  users?: { id: number }[];
  hosts?: { id: number }[];
  schedulingType?: SchedulingType;
  beforeEventBuffer?: number;
  afterEventBuffer?: number;
  teamId?: number | null;
  requiresConfirmation?: boolean;
  destinationCalendar?: Prisma.DestinationCalendarCreateInput;
  schedule?: InputUser["schedules"][number];
  bookingLimits?: IntervalLimit;
  durationLimits?: IntervalLimit;
  owner?: number;
} & Partial<Omit<Prisma.EventTypeCreateInput, "users" | "schedule" | "bookingLimits" | "durationLimits">>;

type AttendeeBookingSeatInput = Pick<Prisma.BookingSeatCreateInput, "referenceUid" | "data">;

type WhiteListedBookingProps = {
  id?: number;
  uid?: string;
  userId?: number;
  eventTypeId: number;
  startTime: string;
  endTime: string;
  title?: string;
  status: BookingStatus;
  attendees?: {
    email: string;
    bookingSeat?: AttendeeBookingSeatInput | null;
  }[];
  references?: (Omit<ReturnType<typeof getMockBookingReference>, "credentialId"> & {
    // TODO: Make sure that all references start providing credentialId and then remove this intersection of optional credentialId
    credentialId?: number | null;
  })[];
  bookingSeat?: Prisma.BookingSeatCreateInput[];
};

type InputBooking = Partial<Omit<Booking, keyof WhiteListedBookingProps>> & WhiteListedBookingProps;

export const Timezones = {
  "+5:30": "Asia/Kolkata",
  "+6:00": "Asia/Dhaka",
};

async function addEventTypesToDb(
  eventTypes: (Omit<
    Prisma.EventTypeCreateInput,
    "users" | "worflows" | "destinationCalendar" | "schedule"
  > & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    users?: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    workflows?: any[];
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    destinationCalendar?: any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    schedule?: any;
  })[]
) {
  log.silly("TestData: Add EventTypes to DB", JSON.stringify(eventTypes));
  await prismock.eventType.createMany({
    data: eventTypes,
  });
  const allEventTypes = await prismock.eventType.findMany({
    include: {
      users: true,
      workflows: true,
      destinationCalendar: true,
      schedule: true,
    },
  });

  /**
   * This is a hack to get the relationship of schedule to be established with eventType. Looks like a prismock bug that creating eventType along with schedule.create doesn't establish the relationship.
   * HACK STARTS
   */
  log.silly("Fixed possible prismock bug by creating schedule separately");
  for (let i = 0; i < eventTypes.length; i++) {
    const eventType = eventTypes[i];

    const createdEventType = allEventTypes[i];

    if (eventType.schedule) {
      log.silly("TestData: Creating Schedule for EventType", JSON.stringify(eventType));
      await prismock.schedule.create({
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        data: {
          ...eventType.schedule.create,
          eventType: {
            connect: {
              id: createdEventType.id,
            },
          },
        },
      });
    }
  }
  /***
   *  HACK ENDS
   */

  log.silly(
    "TestData: All EventTypes in DB are",
    JSON.stringify({
      eventTypes: allEventTypes,
    })
  );
  return allEventTypes;
}

async function addEventTypes(eventTypes: InputEventType[], usersStore: InputUser[]) {
  const baseEventType = {
    title: "Base EventType Title",
    slug: "base-event-type-slug",
    timeZone: null,
    beforeEventBuffer: 0,
    afterEventBuffer: 0,
    bookingLimits: {},
    schedulingType: null,
    length: 15,
    //TODO: What is the purpose of periodStartDate and periodEndDate? Test these?
    periodStartDate: new Date("2022-01-21T09:03:48.000Z"),
    periodEndDate: new Date("2022-01-21T09:03:48.000Z"),
    periodCountCalendarDays: false,
    periodDays: 30,
    seatsPerTimeSlot: null,
    metadata: {},
    minimumBookingNotice: 0,
    offsetStart: 0,
  };
  const foundEvents: Record<number, boolean> = {};
  const eventTypesWithUsers = eventTypes.map((eventType) => {
    if (!eventType.slotInterval && !eventType.length) {
      throw new Error("eventTypes[number]: slotInterval or length must be defined");
    }
    if (foundEvents[eventType.id]) {
      throw new Error(`eventTypes[number]: id ${eventType.id} is not unique`);
    }
    foundEvents[eventType.id] = true;

    const users =
      eventType.users?.map((userWithJustId) => {
        return usersStore.find((user) => user.id === userWithJustId.id);
      }) || [];

    return {
      ...baseEventType,
      ...eventType,
      workflows: [],
      users,
      destinationCalendar: eventType.destinationCalendar
        ? {
            create: eventType.destinationCalendar,
          }
        : eventType.destinationCalendar,
      schedule: eventType.schedule
        ? {
            create: {
              ...eventType.schedule,
              availability: {
                createMany: {
                  data: eventType.schedule.availability,
                },
              },
            },
          }
        : eventType.schedule,
      owner: eventType.owner ? { connect: { id: eventType.owner } } : undefined,
    };
  });
  log.silly("TestData: Creating EventType", JSON.stringify(eventTypesWithUsers));
  return await addEventTypesToDb(eventTypesWithUsers);
}

function addBookingReferencesToDB(bookingReferences: Prisma.BookingReferenceCreateManyInput[]) {
  prismock.bookingReference.createMany({
    data: bookingReferences,
  });
}

async function addBookingsToDb(
  bookings: (Prisma.BookingCreateInput & {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    references: any[];
  })[]
) {
  log.silly("TestData: Creating Bookings", JSON.stringify(bookings));

  function getDateObj(time: string | Date) {
    return time instanceof Date ? time : new Date(time);
  }

  // Make sure that we store the date in Date object always. This is to ensure consistency which Prisma does but not prismock
  log.silly("Handling Prismock bug-3");
  const fixedBookings = bookings.map((booking) => {
    const startTime = getDateObj(booking.startTime);

    const endTime = getDateObj(booking.endTime);

    return { ...booking, startTime, endTime };
  });

  await prismock.booking.createMany({
    data: fixedBookings,
  });
  log.silly(
    "TestData: Bookings as in DB",
    JSON.stringify({
      bookings: await prismock.booking.findMany({
        include: {
          references: true,
          attendees: true,
        },
      }),
    })
  );
}

async function addBookings(bookings: InputBooking[]) {
  log.silly("TestData: Creating Bookings", JSON.stringify(bookings));
  const allBookings = [...bookings].map((booking) => {
    if (booking.references) {
      addBookingReferencesToDB(
        booking.references.map((reference) => {
          return {
            ...reference,
            bookingId: booking.id,
          };
        })
      );
    }
    return {
      uid: booking.uid || uuidv4(),
      workflowReminders: [],
      references: [],
      title: "Test Booking Title",
      ...booking,
    };
  });

  await addBookingsToDb(
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore
    allBookings.map((booking) => {
      const bookingCreate = booking;
      if (booking.references) {
        bookingCreate.references = {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          createMany: {
            data: booking.references,
          },
        };
      }
      if (booking.attendees) {
        bookingCreate.attendees = {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          createMany: {
            data: booking.attendees.map((attendee) => {
              if (attendee.bookingSeat) {
                const { bookingSeat, ...attendeeWithoutBookingSeat } = attendee;

                return {
                  ...attendeeWithoutBookingSeat,
                  bookingSeat: {
                    create: { ...bookingSeat, bookingId: booking.id },
                  },
                };
              } else {
                return attendee;
              }
            }),
          },
        };
      }

      return bookingCreate;
    })
  );
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function addWebhooksToDb(webhooks: any[]) {
  await prismock.webhook.createMany({
    data: webhooks,
  });
}

async function addWebhooks(webhooks: InputWebhook[]) {
  log.silly("TestData: Creating Webhooks", safeStringify(webhooks));

  await addWebhooksToDb(webhooks);
}

async function addWorkflowsToDb(workflows: InputWorkflow[]) {
  await prismock.$transaction(
    workflows.map((workflow) => {
      return prismock.workflow.create({
        data: {
          userId: workflow.userId,
          teamId: workflow.teamId,
          trigger: workflow.trigger,
          name: workflow.name ? workflow.name : "Test Workflow",
          steps: {
            create: {
              stepNumber: 1,
              action: workflow.action,
              template: workflow.template,
              numberVerificationPending: false,
              includeCalendarEvent: false,
            },
          },
          activeOn: {
            create: workflow.activeEventTypeId ? { eventTypeId: workflow.activeEventTypeId } : undefined,
          },
        },
        include: {
          activeOn: true,
          steps: true,
        },
      });
    })
  );
}

async function addWorkflows(workflows: InputWorkflow[]) {
  log.silly("TestData: Creating Workflows", safeStringify(workflows));

  await addWorkflowsToDb(workflows);
}

async function addUsersToDb(users: (Prisma.UserCreateInput & { schedules: Prisma.ScheduleCreateInput[] })[]) {
  log.silly("TestData: Creating Users", JSON.stringify(users));
  await prismock.user.createMany({
    data: users,
  });

  log.silly(
    "Added users to Db",
    safeStringify({
      allUsers: await prismock.user.findMany({
        include: {
          credentials: true,
          teams: true,
          schedules: {
            include: {
              availability: true,
            },
          },
          destinationCalendar: true,
        },
      }),
    })
  );
}

async function addTeamsToDb(teams: NonNullable<InputUser["teams"]>[number]["team"][]) {
  log.silly("TestData: Creating Teams", JSON.stringify(teams));
  await prismock.team.createMany({
    data: teams,
  });
  const addedTeams = await prismock.team.findMany({
    where: {
      id: {
        in: teams.map((team) => team.id),
      },
    },
  });
  log.silly(
    "Added teams to Db",
    safeStringify({
      addedTeams,
    })
  );
  return addedTeams;
}

async function addUsers(users: InputUser[]) {
  const prismaUsersCreate = [];
  for (let i = 0; i < users.length; i++) {
    const newUser = users[i];

    const user = users[i];

    if (user.schedules) {
      newUser.schedules = {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        createMany: {
          data: user.schedules.map((schedule) => {
            return {
              ...schedule,
              availability: {
                createMany: {
                  data: schedule.availability,
                },
              },
            };
          }),
        },
      };
    }
    if (user.credentials) {
      newUser.credentials = {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        createMany: {
          data: user.credentials,
        },
      };
    }

    if (user.teams) {
      const addedTeams = await addTeamsToDb(user.teams.map((team) => team.team));
      newUser.teams = {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        createMany: {
          data: user.teams.map((team, index) => {
            return {
              teamId: addedTeams[index].id,
              ...team.membership,
            };
          }),
        },
      };
    }
    if (user.selectedCalendars) {
      newUser.selectedCalendars = {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        createMany: {
          data: user.selectedCalendars,
        },
      };
    }

    prismaUsersCreate.push(newUser);
  }
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  await addUsersToDb(prismaUsersCreate);
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function addAppsToDb(apps: any[]) {
  log.silly("TestData: Creating Apps", JSON.stringify({ apps }));
  await prismock.app.createMany({
    data: apps,
  });
  const allApps = await prismock.app.findMany();
  log.silly("TestData: Apps as in DB", JSON.stringify({ apps: allApps }));
}
export async function createBookingScenario(data: ScenarioData) {
  log.silly("TestData: Creating Scenario", JSON.stringify({ data }));
  await addUsers(data.users);
  if (data.apps) {
    await addAppsToDb(
      data.apps.map((app) => {
        // Enable the app by default
        return { enabled: true, ...app };
      })
    );
  }
  const eventTypes = await addEventTypes(data.eventTypes, data.users);

  data.bookings = data.bookings || [];
  // allowSuccessfulBookingCreation();
  await addBookings(data.bookings);
  // mockBusyCalendarTimes([]);
  await addWebhooks(data.webhooks || []);
  // addPaymentMock();
  await addWorkflows(data.workflows || []);

  return {
    eventTypes,
  };
}

export async function createOrganization(orgData: { name: string; slug: string }) {
  const org = await prismock.team.create({
    data: {
      name: orgData.name,
      slug: orgData.slug,
    },
  });
  return org;
}

// async function addPaymentsToDb(payments: Prisma.PaymentCreateInput[]) {
//   await prismaMock.payment.createMany({
//     data: payments,
//   });
// }

/**
 * This fn indents to /ally compute day, month, year for the purpose of testing.
 * We are not using DayJS because that's actually being tested by this code.
 * - `dateIncrement` adds the increment to current day
 * - `monthIncrement` adds the increment to current month
 * - `yearIncrement` adds the increment to current year
 * - `fromDate` starts incrementing from this date (default: today)
 */
export const getDate = (
  param: {
    dateIncrement?: number;
    monthIncrement?: number;
    yearIncrement?: number;
    fromDate?: Date;
  } = {}
) => {
  let { dateIncrement, monthIncrement, yearIncrement, fromDate } = param;

  dateIncrement = dateIncrement || 0;
  monthIncrement = monthIncrement || 0;
  yearIncrement = yearIncrement || 0;
  fromDate = fromDate || new Date();

  fromDate.setDate(fromDate.getDate() + dateIncrement);
  fromDate.setMonth(fromDate.getMonth() + monthIncrement);
  fromDate.setFullYear(fromDate.getFullYear() + yearIncrement);

  let _date = fromDate.getDate();
  let year = fromDate.getFullYear();

  // Make it start with 1 to match with DayJS requiremet
  let _month = fromDate.getMonth() + 1;

  // If last day of the month(As _month is plus 1 already it is going to be the 0th day of next month which is the last day of current month)
  const lastDayOfMonth = new Date(year, _month, 0).getDate();
  const numberOfDaysForNextMonth = +_date - +lastDayOfMonth;
  if (numberOfDaysForNextMonth > 0) {
    _date = numberOfDaysForNextMonth;
    _month = _month + 1;
  }

  if (_month === 13) {
    _month = 1;
    year = year + 1;
  }

  const date = _date < 10 ? `0${_date}` : _date;
  const month = _month < 10 ? `0${_month}` : _month;

  return {
    date: String(date),
    month: String(month),
    year: String(year),
    dateString: `${year}-${month}-${date}`,
  };
};

const isWeekStart = (date: Date, weekStart: WeekDays) => {
  return date.getDay() === weekdayToWeekIndex(weekStart);
};

export const getNextMonthNotStartingOnWeekStart = (weekStart: WeekDays, from?: Date) => {
  const date = from ?? new Date();

  const incrementMonth = (date: Date) => {
    date.setMonth(date.getMonth() + 1);
  };

  // start searching from the 1st day of next month
  incrementMonth(date);
  date.setDate(1);

  while (isWeekStart(date, weekStart)) {
    incrementMonth(date);
  }

  return getDate({ fromDate: date });
};

export function getMockedCredential({
  metadataLookupKey,
  key,
}: {
  metadataLookupKey: string;
  key: {
    expiry_date?: number;
    token_type?: string;
    access_token?: string;
    refresh_token?: string;
    scope: string;
  };
}) {
  const app = appStoreMetadata[metadataLookupKey as keyof typeof appStoreMetadata];
  return {
    type: app.type,
    appId: app.slug,
    app: app,
    key: {
      expiry_date: Date.now() + 1000000,
      token_type: "Bearer",
      access_token: "ACCESS_TOKEN",
      refresh_token: "REFRESH_TOKEN",
      ...key,
    },
  };
}

export function getGoogleCalendarCredential() {
  return getMockedCredential({
    metadataLookupKey: "googlecalendar",
    key: {
      scope:
        "https://www.googleapis.com/auth/calendar.events https://www.googleapis.com/auth/calendar.readonly",
    },
  });
}

export function getAppleCalendarCredential() {
  return getMockedCredential({
    metadataLookupKey: "applecalendar",
    key: {
      scope:
        "https://www.applecalendar.example/auth/calendar.events https://www.applecalendar.example/auth/calendar.readonly",
    },
  });
}

export function getZoomAppCredential() {
  return getMockedCredential({
    metadataLookupKey: "zoomvideo",
    key: {
      scope: "meeting:write",
    },
  });
}

export function getStripeAppCredential() {
  return getMockedCredential({
    metadataLookupKey: "stripepayment",
    key: {
      scope: "read_write",
    },
  });
}

export const TestData = {
  selectedCalendars: {
    google: {
      integration: "google_calendar",
      externalId: "john@example.com",
    },
  },
  credentials: {
    google: getGoogleCalendarCredential(),
  },
  schedules: {
    IstWorkHours: {
      name: "9:30AM to 6PM in India - 4:00AM to 12:30PM in GMT",
      availability: [
        {
          // userId: null,
          // eventTypeId: null,
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T09:30:00.000Z"),
          endTime: new Date("1970-01-01T18:00:00.000Z"),
          date: null,
        },
      ],
      timeZone: Timezones["+5:30"],
    },
    /**
     * Has an overlap with IstEveningShift from 5PM to 6PM IST(11:30AM to 12:30PM GMT)
     */
    IstMorningShift: {
      name: "9:30AM to 6PM in India - 4:00AM to 12:30PM in GMT",
      availability: [
        {
          // userId: null,
          // eventTypeId: null,
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T09:30:00.000Z"),
          endTime: new Date("1970-01-01T18:00:00.000Z"),
          date: null,
        },
      ],
      timeZone: Timezones["+5:30"],
    },
    /**
     * Has an overlap with IstMorningShift from 5PM to 6PM IST(11:30AM to 12:30PM GMT)
     */
    IstEveningShift: {
      name: "5:00PM to 10PM in India - 11:30AM to 16:30PM in GMT",
      availability: [
        {
          // userId: null,
          // eventTypeId: null,
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T17:00:00.000Z"),
          endTime: new Date("1970-01-01T22:00:00.000Z"),
          date: null,
        },
      ],
      timeZone: Timezones["+5:30"],
    },
    IstWorkHoursWithDateOverride: (dateString: string) => ({
      name: "9:30AM to 6PM in India - 4:00AM to 12:30PM in GMT but with a Date Override for 2PM to 6PM IST(in GST time it is 8:30AM to 12:30PM)",
      availability: [
        {
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T09:30:00.000Z"),
          endTime: new Date("1970-01-01T18:00:00.000Z"),
          date: null,
        },
        {
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date(`1970-01-01T14:00:00.000Z`),
          endTime: new Date(`1970-01-01T18:00:00.000Z`),
          date: dateString,
        },
      ],
      timeZone: Timezones["+5:30"],
    }),
  },
  users: {
    example: {
      name: "Example",
      email: "example@example.com",
      username: "example.username",
      defaultScheduleId: 1,
      timeZone: Timezones["+5:30"],
    },
  },
  apps: {
    "google-calendar": {
      ...appStoreMetadata.googlecalendar,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      keys: {
        expiry_date: Infinity,
        client_id: "client_id",
        client_secret: "client_secret",
        redirect_uris: ["http://localhost:3000/auth/callback"],
      },
    },
    "daily-video": {
      ...appStoreMetadata.dailyvideo,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      keys: {
        expiry_date: Infinity,
        api_key: "",
        scale_plan: "false",
        client_id: "client_id",
        client_secret: "client_secret",
        redirect_uris: ["http://localhost:3000/auth/callback"],
      },
    },
    zoomvideo: {
      ...appStoreMetadata.zoomvideo,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      keys: {
        expiry_date: Infinity,
        api_key: "",
        scale_plan: "false",
        client_id: "client_id",
        client_secret: "client_secret",
        redirect_uris: ["http://localhost:3000/auth/callback"],
      },
    },
    "stripe-payment": {
      ...appStoreMetadata.stripepayment,
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      keys: {
        expiry_date: Infinity,
        api_key: "",
        scale_plan: "false",
        client_id: "client_id",
        client_secret: "client_secret",
        redirect_uris: ["http://localhost:3000/auth/callback"],
      },
    },
  },
};

export class MockError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "MockError";
  }
}

export function getOrganizer({
  name,
  email,
  id,
  schedules,
  credentials,
  selectedCalendars,
  destinationCalendar,
  defaultScheduleId,
  weekStart = "Sunday",
  teams,
  organizationId,
  metadata,
}: {
  name: string;
  email: string;
  id: number;
  organizationId?: number | null;
  schedules: InputUser["schedules"];
  credentials?: InputCredential[];
  selectedCalendars?: InputSelectedCalendar[];
  defaultScheduleId?: number | null;
  destinationCalendar?: Prisma.DestinationCalendarCreateInput;
  weekStart?: WeekDays;
  teams?: InputUser["teams"];
  metadata?: userMetadataType;
}) {
  return {
    ...TestData.users.example,
    name,
    email,
    id,
    schedules,
    credentials,
    selectedCalendars,
    destinationCalendar,
    defaultScheduleId,
    weekStart,
    teams,
    organizationId,
    metadata,
  };
}

export function getScenarioData(
  {
    organizer,
    eventTypes,
    usersApartFromOrganizer = [],
    apps = [],
    webhooks,
    workflows,
    bookings,
  }: // hosts = [],
  {
    organizer: ReturnType<typeof getOrganizer>;
    eventTypes: ScenarioData["eventTypes"];
    apps?: ScenarioData["apps"];
    usersApartFromOrganizer?: ScenarioData["users"];
    webhooks?: ScenarioData["webhooks"];
    workflows?: ScenarioData["workflows"];
    bookings?: ScenarioData["bookings"];
    // hosts?: ScenarioData["hosts"];
  },
  org?: { id: number | null } | undefined | null
) {
  const users = [organizer, ...usersApartFromOrganizer];
  if (org) {
    users.forEach((user) => {
      user.organizationId = org.id;
    });
  }

  eventTypes.forEach((eventType) => {
    if (
      eventType.users?.filter((eventTypeUser) => {
        return !users.find((userToCreate) => userToCreate.id === eventTypeUser.id);
      }).length
    ) {
      throw new Error(`EventType ${eventType.id} has users that are not present in ScenarioData["users"]`);
    }
  });
  return {
    // hosts: [...hosts],
    eventTypes: eventTypes.map((eventType, index) => {
      return {
        ...eventType,
        teamId: eventType.teamId || null,
        title: `Test Event Type - ${index + 1}`,
        description: `It's a test event type - ${index + 1}`,
      };
    }),
    users: users.map((user) => {
      const newUser = {
        ...user,
        organizationId: user.organizationId ?? null,
      };
      if (user.destinationCalendar) {
        newUser.destinationCalendar = {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          create: user.destinationCalendar,
        };
      }
      return newUser;
    }),
    apps: [...apps],
    webhooks,
    bookings: bookings || [],
    workflows,
  } satisfies ScenarioData;
}

export function enableEmailFeature() {
  prismock.feature.create({
    data: {
      slug: "emails",
      enabled: false,
      type: "KILL_SWITCH",
    },
  });
}

export function mockNoTranslations() {
  log.silly("Mocking i18n.getTranslation to return identity function");
  // @ts-expect-error FIXME
  i18nMock.getTranslation.mockImplementation(() => {
    return new Promise((resolve) => {
      const identityFn = (key: string) => key;
      resolve(identityFn);
    });
  });
}

/**
 * @param metadataLookupKey
 * @param calendarData Specify uids and other data to be faked to be returned by createEvent and updateEvent
 */
export function mockCalendar(
  metadataLookupKey: keyof typeof appStoreMetadata,
  calendarData?: {
    create?: {
      id?: string;
      uid?: string;
      iCalUID?: string;
    };
    update?: {
      id?: string;
      uid: string;
      iCalUID?: string;
    };
    busySlots?: { start: `${string}Z`; end: `${string}Z` }[];
    creationCrash?: boolean;
    updationCrash?: boolean;

    getAvailabilityCrash?: boolean;
  }
) {
  const appStoreLookupKey = metadataLookupKey;
  const normalizedCalendarData = calendarData || {
    create: {
      uid: "MOCK_ID",
    },
    update: {
      uid: "UPDATED_MOCK_ID",
    },
  };
  log.silly(`Mocking ${appStoreLookupKey} on appStoreMock`);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const createEventCalls: any[] = [];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const updateEventCalls: any[] = [];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const deleteEventCalls: any[] = [];
  const app = appStoreMetadata[metadataLookupKey as keyof typeof appStoreMetadata];

  const appMock = appStoreMock.default[appStoreLookupKey as keyof typeof appStoreMock.default];

  appMock &&
    `mockResolvedValue` in appMock &&
    appMock.mockResolvedValue({
      lib: {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        CalendarService: function MockCalendarService() {
          return {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            createEvent: async function (...rest: any[]): Promise<NewCalendarEventType> {
              if (calendarData?.creationCrash) {
                throw new Error("MockCalendarService.createEvent fake error");
              }
              const [calEvent, credentialId] = rest;
              log.silly("mockCalendar.createEvent", JSON.stringify({ calEvent, credentialId }));
              createEventCalls.push(rest);
              return Promise.resolve({
                type: app.type,
                additionalInfo: {},
                uid: "PROBABLY_UNUSED_UID",
                // A Calendar is always expected to return an id.
                id: normalizedCalendarData.create?.id || "FALLBACK_MOCK_CALENDAR_EVENT_ID",
                iCalUID: normalizedCalendarData.create?.iCalUID,
                // Password and URL seems useless for CalendarService, plan to remove them if that's the case
                password: "MOCK_PASSWORD",
                url: "https://UNUSED_URL",
              });
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            updateEvent: async function (...rest: any[]): Promise<NewCalendarEventType> {
              if (calendarData?.updationCrash) {
                throw new Error("MockCalendarService.updateEvent fake error");
              }
              const [uid, event, externalCalendarId] = rest;
              log.silly("mockCalendar.updateEvent", JSON.stringify({ uid, event, externalCalendarId }));
              // eslint-disable-next-line prefer-rest-params
              updateEventCalls.push(rest);
              return Promise.resolve({
                type: app.type,
                additionalInfo: {},
                uid: "PROBABLY_UNUSED_UID",
                iCalUID: normalizedCalendarData.update?.iCalUID,

                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                id: normalizedCalendarData.update?.uid || "FALLBACK_MOCK_ID",
                // Password and URL seems useless for CalendarService, plan to remove them if that's the case
                password: "MOCK_PASSWORD",
                url: "https://UNUSED_URL",
              });
            },
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            deleteEvent: async (...rest: any[]) => {
              log.silly("mockCalendar.deleteEvent", JSON.stringify({ rest }));
              // eslint-disable-next-line prefer-rest-params
              deleteEventCalls.push(rest);
            },
            getAvailability: async (): Promise<EventBusyDate[]> => {
              if (calendarData?.getAvailabilityCrash) {
                throw new Error("MockCalendarService.getAvailability fake error");
              }
              return new Promise((resolve) => {
                resolve(calendarData?.busySlots || []);
              });
            },
          };
        },
      },
    });
  return {
    createEventCalls,
    deleteEventCalls,
    updateEventCalls,
  };
}

export function mockCalendarToHaveNoBusySlots(
  metadataLookupKey: keyof typeof appStoreMetadata,
  calendarData?: Parameters<typeof mockCalendar>[1]
) {
  calendarData = calendarData || {
    create: {
      uid: "MOCK_ID",
    },
    update: {
      uid: "UPDATED_MOCK_ID",
    },
  };
  return mockCalendar(metadataLookupKey, { ...calendarData, busySlots: [] });
}

export function mockCalendarToCrashOnCreateEvent(metadataLookupKey: keyof typeof appStoreMetadata) {
  return mockCalendar(metadataLookupKey, { creationCrash: true });
}

export function mockCalendarToCrashOnUpdateEvent(metadataLookupKey: keyof typeof appStoreMetadata) {
  return mockCalendar(metadataLookupKey, { updationCrash: true });
}

export function mockVideoApp({
  metadataLookupKey,
  appStoreLookupKey,
  videoMeetingData,
  creationCrash,
  updationCrash,
}: {
  metadataLookupKey: string;
  appStoreLookupKey?: string;
  videoMeetingData?: {
    password: string;
    id: string;
    url: string;
  };
  creationCrash?: boolean;
  updationCrash?: boolean;
}) {
  appStoreLookupKey = appStoreLookupKey || metadataLookupKey;
  videoMeetingData = videoMeetingData || {
    id: "MOCK_ID",
    password: "MOCK_PASS",
    url: `http://mock-${metadataLookupKey}.example.com`,
  };
  log.silly("mockVideoApp", JSON.stringify({ metadataLookupKey, appStoreLookupKey }));
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const createMeetingCalls: any[] = [];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const updateMeetingCalls: any[] = [];
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const deleteMeetingCalls: any[] = [];
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  appStoreMock.default[appStoreLookupKey as keyof typeof appStoreMock.default].mockImplementation(() => {
    return new Promise((resolve) => {
      resolve({
        lib: {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          VideoApiAdapter: (credential) => {
            return {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              createMeeting: (...rest: any[]) => {
                if (creationCrash) {
                  throw new Error("MockVideoApiAdapter.createMeeting fake error");
                }
                createMeetingCalls.push({
                  credential,
                  args: rest,
                });

                return Promise.resolve({
                  type: appStoreMetadata[metadataLookupKey as keyof typeof appStoreMetadata].type,
                  ...videoMeetingData,
                });
              },
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              updateMeeting: async (...rest: any[]) => {
                if (updationCrash) {
                  throw new Error("MockVideoApiAdapter.updateMeeting fake error");
                }
                const [bookingRef, calEvent] = rest;
                updateMeetingCalls.push({
                  credential,
                  args: rest,
                });

                if (!bookingRef.type) {
                  throw new Error("bookingRef.type is not defined");
                }
                if (!calEvent.organizer) {
                  throw new Error("calEvent.organizer is not defined");
                }
                log.silly("MockVideoApiAdapter.updateMeeting", JSON.stringify({ bookingRef, calEvent }));

                return Promise.resolve({
                  type: appStoreMetadata[metadataLookupKey as keyof typeof appStoreMetadata].type,
                  ...videoMeetingData,
                });
              },
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              deleteMeeting: async (...rest: any[]) => {
                log.silly("MockVideoApiAdapter.deleteMeeting", JSON.stringify(rest));
                deleteMeetingCalls.push({
                  credential,
                  args: rest,
                });
              },
            };
          },
        },
      });
    });
  });
  return {
    createMeetingCalls,
    updateMeetingCalls,
    deleteMeetingCalls,
  };
}

export function mockSuccessfulVideoMeetingCreation({
  metadataLookupKey,
  appStoreLookupKey,
  videoMeetingData,
}: {
  metadataLookupKey: string;
  appStoreLookupKey?: string;
  videoMeetingData?: {
    password: string;
    id: string;
    url: string;
  };
}) {
  return mockVideoApp({
    metadataLookupKey,
    appStoreLookupKey,
    videoMeetingData,
  });
}

export function mockVideoAppToCrashOnCreateMeeting({
  metadataLookupKey,
  appStoreLookupKey,
}: {
  metadataLookupKey: string;
  appStoreLookupKey?: string;
}) {
  return mockVideoApp({
    metadataLookupKey,
    appStoreLookupKey,
    creationCrash: true,
  });
}

export function mockPaymentApp({
  metadataLookupKey,
  appStoreLookupKey,
}: {
  metadataLookupKey: string;
  appStoreLookupKey?: string;
}) {
  appStoreLookupKey = appStoreLookupKey || metadataLookupKey;
  const { paymentUid, externalId, MockPaymentService } = getMockPaymentService();
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  appStoreMock.default[appStoreLookupKey as keyof typeof appStoreMock.default].mockImplementation(() => {
    return new Promise((resolve) => {
      resolve({
        lib: {
          PaymentService: MockPaymentService,
        },
      });
    });
  });

  return {
    paymentUid,
    externalId,
  };
}

export function mockErrorOnVideoMeetingCreation({
  metadataLookupKey,
  appStoreLookupKey,
}: {
  metadataLookupKey: string;
  appStoreLookupKey?: string;
}) {
  appStoreLookupKey = appStoreLookupKey || metadataLookupKey;
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  appStoreMock.default[appStoreLookupKey].mockImplementation(() => {
    return new Promise((resolve) => {
      resolve({
        lib: {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          VideoApiAdapter: () => ({
            createMeeting: () => {
              throw new MockError("Error creating Video meeting");
            },
          }),
        },
      });
    });
  });
}

export function getBooker({ name, email }: { name: string; email: string }) {
  return {
    name,
    email,
  };
}

export function getMockedStripePaymentEvent({ paymentIntentId }: { paymentIntentId: string }) {
  return {
    id: null,
    data: {
      object: {
        id: paymentIntentId,
      },
    },
  } as unknown as Stripe.Event;
}

export async function mockPaymentSuccessWebhookFromStripe({ externalId }: { externalId: string }) {
  let webhookResponse = null;
  try {
    await handleStripePaymentSuccess(getMockedStripePaymentEvent({ paymentIntentId: externalId }));
  } catch (e) {
    log.silly("mockPaymentSuccessWebhookFromStripe:catch", JSON.stringify(e));
    webhookResponse = e as HttpError;
  }
  return { webhookResponse };
}

export function getExpectedCalEventForBookingRequest({
  bookingRequest,
  eventType,
}: {
  bookingRequest: ReturnType<typeof getMockRequestDataForBooking>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  eventType: any;
}) {
  return {
    // keep adding more fields as needed, so that they can be verified in all scenarios
    type: eventType.slug,
    // Not sure why, but milliseconds are missing in cal Event.
    startTime: bookingRequest.start.replace(".000Z", "Z"),
    endTime: bookingRequest.end.replace(".000Z", "Z"),
  };
}

export function getMockBookingReference(
  bookingReference: Partial<BookingReference> & Pick<BookingReference, "type" | "uid" | "credentialId">
) {
  let credentialId = bookingReference.credentialId;
  if (bookingReference.type === appStoreMetadata.dailyvideo.type) {
    // Right now we seems to be storing credentialId for `dailyvideo` in BookingReference as null. Another possible value is 0 in there.
    credentialId = null;
    log.debug("Ensuring null credentialId for dailyvideo");
  }
  return {
    ...bookingReference,
    credentialId,
  };
}

export function getMockBookingAttendee(
  attendee: Omit<Attendee, "bookingId"> & {
    bookingSeat?: AttendeeBookingSeatInput;
  }
) {
  return {
    id: attendee.id,
    timeZone: attendee.timeZone,
    name: attendee.name,
    email: attendee.email,
    locale: attendee.locale,
    bookingSeat: attendee.bookingSeat || null,
  };
}

export const enum BookingLocations {
  CalVideo = "integrations:daily",
  ZoomVideo = "integrations:zoom",
}

const getMockAppStatus = ({
  slug,
  failures,
  success,
}: {
  slug: string;
  failures: number;
  success: number;
}) => {
  const foundEntry = Object.entries(appStoreMetadata).find(([, app]) => {
    return app.slug === slug;
  });
  if (!foundEntry) {
    throw new Error("App not found for the slug");
  }
  const foundApp = foundEntry[1];
  return {
    appName: foundApp.slug,
    type: foundApp.type,
    failures,
    success,
    errors: [],
  };
};

export const getMockFailingAppStatus = ({ slug }: { slug: string }) => {
  return getMockAppStatus({ slug, failures: 1, success: 0 });
};

export const getMockPassingAppStatus = ({ slug }: { slug: string }) => {
  return getMockAppStatus({ slug, failures: 0, success: 1 });
};
import CalendarManagerMock from "../../../../tests/libs/__mocks__/CalendarManager";
import prismock from "../../../../tests/libs/__mocks__/prisma";

import { diff } from "jest-diff";
import { describe, expect, vi, beforeEach, afterEach, test } from "vitest";

import dayjs from "@calcom/dayjs";
import type { BookingStatus } from "@calcom/prisma/enums";
import type { Slot } from "@calcom/trpc/server/routers/viewer/slots/types";
import { getAvailableSlots as getSchedule } from "@calcom/trpc/server/routers/viewer/slots/util";

import {
  getDate,
  getGoogleCalendarCredential,
  createBookingScenario,
} from "../utils/bookingScenario/bookingScenario";

vi.mock("@calcom/lib/constants", () => ({
  IS_PRODUCTION: true,
  WEBAPP_URL: "http://localhost:3000",
}));

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace jest {
    interface Matchers<R> {
      toHaveTimeSlots(expectedSlots: string[], date: { dateString: string }): R;
    }
  }
}

expect.extend({
  toHaveTimeSlots(
    schedule: { slots: Record<string, Slot[]> },
    expectedSlots: string[],
    { dateString }: { dateString: string }
  ) {
    if (!schedule.slots[`${dateString}`]) {
      return {
        pass: false,
        message: () => `has no timeslots for ${dateString}`,
      };
    }
    if (
      !schedule.slots[`${dateString}`]
        .map((slot) => slot.time)
        .every((actualSlotTime, index) => {
          return `${dateString}T${expectedSlots[index]}` === actualSlotTime;
        })
    ) {
      return {
        pass: false,
        message: () =>
          `has incorrect timeslots for ${dateString}.\n\r ${diff(
            expectedSlots.map((expectedSlot) => `${dateString}T${expectedSlot}`),
            schedule.slots[`${dateString}`].map((slot) => slot.time)
          )}`,
      };
    }
    return {
      pass: true,
      message: () => "has correct timeslots ",
    };
  },
});

const Timezones = {
  "+5:30": "Asia/Kolkata",
  "+6:00": "Asia/Dhaka",
};

const TestData = {
  selectedCalendars: {
    google: {
      integration: "google_calendar",
      externalId: "john@example.com",
    },
  },
  credentials: {
    google: getGoogleCalendarCredential(),
  },
  schedules: {
    IstWorkHours: {
      id: 1,
      name: "9:30AM to 6PM in India - 4:00AM to 12:30PM in GMT",
      availability: [
        {
          userId: null,
          eventTypeId: null,
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T09:30:00.000Z"),
          endTime: new Date("1970-01-01T18:00:00.000Z"),
          date: null,
        },
      ],
      timeZone: Timezones["+5:30"],
    },
    IstWorkHoursWithDateOverride: (dateString: string) => ({
      id: 1,
      name: "9:30AM to 6PM in India - 4:00AM to 12:30PM in GMT but with a Date Override for 2PM to 6PM IST(in GST time it is 8:30AM to 12:30PM)",
      availability: [
        {
          userId: null,
          eventTypeId: null,
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T09:30:00.000Z"),
          endTime: new Date("1970-01-01T18:00:00.000Z"),
          date: null,
        },
        {
          userId: null,
          eventTypeId: null,
          days: [0, 1, 2, 3, 4, 5, 6],
          startTime: new Date("1970-01-01T14:00:00.000Z"),
          endTime: new Date("1970-01-01T18:00:00.000Z"),
          date: dateString,
        },
      ],
      timeZone: Timezones["+5:30"],
    }),
  },
  users: {
    example: {
      name: "Example",
      username: "example",
      defaultScheduleId: 1,
      email: "example@example.com",
      timeZone: Timezones["+5:30"],
    },
  },
  apps: {
    googleCalendar: {
      slug: "google-calendar",
      dirName: "whatever",
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      //@ts-ignore
      keys: {
        expiry_date: Infinity,
        client_id: "client_id",
        client_secret: "client_secret",
        redirect_uris: ["http://localhost:3000/auth/callback"],
      },
    },
  },
};

const cleanup = async () => {
  await prismock.eventType.deleteMany();
  await prismock.user.deleteMany();
  await prismock.schedule.deleteMany();
  await prismock.selectedCalendar.deleteMany();
  await prismock.credential.deleteMany();
  await prismock.booking.deleteMany();
  await prismock.app.deleteMany();
};

beforeEach(async () => {
  await cleanup();
});

afterEach(async () => {
  await cleanup();
});

describe("getSchedule", () => {
  describe("Calendar event", () => {
    test("correctly identifies unavailable slots from calendar", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });

      CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue([
        {
          start: `${plus2DateString}T04:45:00.000Z`,
          end: `${plus2DateString}T23:00:00.000Z`,
        },
      ]);

      const scenarioData = {
        eventTypes: [
          {
            id: 1,
            slotInterval: 45,
            length: 45,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
            credentials: [getGoogleCalendarCredential()],
            selectedCalendars: [TestData.selectedCalendars.google],
          },
        ],
        apps: [TestData.apps.googleCalendar],
      };
      // An event with one accepted booking
      await createBookingScenario(scenarioData);

      const scheduleForDayWithAGoogleCalendarBooking = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      // As per Google Calendar Availability, only 4PM(4-4:45PM) GMT slot would be available
      expect(scheduleForDayWithAGoogleCalendarBooking).toHaveTimeSlots([`04:00:00.000Z`], {
        dateString: plus2DateString,
      });
    });
  });

  describe("User Event", () => {
    test("correctly identifies unavailable slots from Cal Bookings in different status", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });
      const { dateString: plus3DateString } = getDate({ dateIncrement: 3 });

      // An event with one accepted booking
      await createBookingScenario({
        // An event with length 30 minutes, slotInterval 45 minutes, and minimumBookingNotice 1440 minutes (24 hours)
        eventTypes: [
          {
            id: 1,
            // If `slotInterval` is set, it supersedes `length`
            slotInterval: 45,
            length: 45,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
          },
        ],
        bookings: [
          // That event has one accepted booking from 4:00 to 4:15 in GMT on Day + 3 which is 9:30 to 9:45 in IST
          {
            eventTypeId: 1,
            userId: 101,
            status: "ACCEPTED",
            // Booking Time is stored in GMT in DB. So, provide entry in GMT only.
            startTime: `${plus3DateString}T04:00:00.000Z`,
            endTime: `${plus3DateString}T04:15:00.000Z`,
          },
          {
            eventTypeId: 1,
            userId: 101,
            status: "REJECTED",
            // Booking Time is stored in GMT in DB. So, provide entry in GMT only.
            startTime: `${plus2DateString}T04:00:00.000Z`,
            endTime: `${plus2DateString}T04:15:00.000Z`,
          },
          {
            eventTypeId: 1,
            userId: 101,
            status: "CANCELLED",
            // Booking Time is stored in GMT in DB. So, provide entry in GMT only.
            startTime: `${plus2DateString}T05:00:00.000Z`,
            endTime: `${plus2DateString}T05:15:00.000Z`,
          },
          {
            eventTypeId: 1,
            userId: 101,
            status: "PENDING",
            // Booking Time is stored in GMT in DB. So, provide entry in GMT only.
            startTime: `${plus2DateString}T06:00:00.000Z`,
            endTime: `${plus2DateString}T06:15:00.000Z`,
          },
        ],
      });

      // Day Plus 2 is completely free - It only has non accepted bookings
      const scheduleOnCompletelyFreeDay = await getSchedule({
        input: {
          eventTypeId: 1,
          // EventTypeSlug doesn't matter for non-dynamic events
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      // getSchedule returns timeslots in GMT
      expect(scheduleOnCompletelyFreeDay).toHaveTimeSlots(
        [
          "04:00:00.000Z",
          "04:45:00.000Z",
          "05:30:00.000Z",
          "06:15:00.000Z",
          "07:00:00.000Z",
          "07:45:00.000Z",
          "08:30:00.000Z",
          "09:15:00.000Z",
          "10:00:00.000Z",
          "10:45:00.000Z",
          "11:30:00.000Z",
        ],
        {
          dateString: plus2DateString,
        }
      );

      // Day plus 3
      const scheduleForDayWithOneBooking = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus2DateString}T18:30:00.000Z`,
          endTime: `${plus3DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(scheduleForDayWithOneBooking).toHaveTimeSlots(
        [
          // "04:00:00.000Z", - This slot is unavailable because of the booking from 4:00 to 4:15
          `04:15:00.000Z`,
          `05:00:00.000Z`,
          `05:45:00.000Z`,
          `06:30:00.000Z`,
          `07:15:00.000Z`,
          `08:00:00.000Z`,
          `08:45:00.000Z`,
          `09:30:00.000Z`,
          `10:15:00.000Z`,
          `11:00:00.000Z`,
          `11:45:00.000Z`,
        ],
        {
          dateString: plus3DateString,
        }
      );
    });

    test("slots are available as per `length`, `slotInterval` of the event", async () => {
      await createBookingScenario({
        eventTypes: [
          {
            id: 1,
            length: 30,
            users: [
              {
                id: 101,
              },
            ],
          },
          {
            id: 2,
            length: 30,
            slotInterval: 120,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
          },
        ],
      });
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });
      const scheduleForEventWith30Length = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(scheduleForEventWith30Length).toHaveTimeSlots(
        [
          `04:00:00.000Z`,
          `04:30:00.000Z`,
          `05:00:00.000Z`,
          `05:30:00.000Z`,
          `06:00:00.000Z`,
          `06:30:00.000Z`,
          `07:00:00.000Z`,
          `07:30:00.000Z`,
          `08:00:00.000Z`,
          `08:30:00.000Z`,
          `09:00:00.000Z`,
          `09:30:00.000Z`,
          `10:00:00.000Z`,
          `10:30:00.000Z`,
          `11:00:00.000Z`,
          `11:30:00.000Z`,
          `12:00:00.000Z`,
        ],
        {
          dateString: plus2DateString,
        }
      );

      const scheduleForEventWith30minsLengthAndSlotInterval2hrs = await getSchedule({
        input: {
          eventTypeId: 2,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });
      // `slotInterval` takes precedence over `length`
      // 4:30 is utc so it is 10:00 in IST
      expect(scheduleForEventWith30minsLengthAndSlotInterval2hrs).toHaveTimeSlots(
        [`04:30:00.000Z`, `06:30:00.000Z`, `08:30:00.000Z`, `10:30:00.000Z`, `12:30:00.000Z`],
        {
          dateString: plus2DateString,
        }
      );
    });

    // FIXME: Fix minimumBookingNotice is respected test
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip("minimumBookingNotice is respected", async () => {
      vi.useFakeTimers().setSystemTime(
        (() => {
          const today = new Date();
          // Beginning of the day in current timezone of the system
          return new Date(today.getFullYear(), today.getMonth(), today.getDate());
        })()
      );

      await createBookingScenario({
        eventTypes: [
          {
            id: 1,
            length: 120,
            minimumBookingNotice: 13 * 60, // Would take the minimum bookable time to be 18:30UTC+13 = 7:30AM UTC
            users: [
              {
                id: 101,
              },
            ],
          },
          {
            id: 2,
            length: 120,
            minimumBookingNotice: 10 * 60, // Would take the minimum bookable time to be 18:30UTC+10 = 4:30AM UTC
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
          },
        ],
      });
      const { dateString: todayDateString } = getDate();
      const { dateString: minus1DateString } = getDate({ dateIncrement: -1 });
      const scheduleForEventWithBookingNotice13Hrs = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${minus1DateString}T18:30:00.000Z`,
          endTime: `${todayDateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });
      expect(scheduleForEventWithBookingNotice13Hrs).toHaveTimeSlots(
        [
          /*`04:00:00.000Z`, `06:00:00.000Z`, - Minimum time slot is 07:30 UTC*/ `08:00:00.000Z`,
          `10:00:00.000Z`,
          `12:00:00.000Z`,
        ],
        {
          dateString: todayDateString,
        }
      );

      const scheduleForEventWithBookingNotice10Hrs = await getSchedule({
        input: {
          eventTypeId: 2,
          eventTypeSlug: "",
          startTime: `${minus1DateString}T18:30:00.000Z`,
          endTime: `${todayDateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });
      expect(scheduleForEventWithBookingNotice10Hrs).toHaveTimeSlots(
        [
          /*`04:00:00.000Z`, - Minimum bookable time slot is 04:30 UTC but next available is 06:00*/
          `06:00:00.000Z`,
          `08:00:00.000Z`,
          `10:00:00.000Z`,
          `12:00:00.000Z`,
        ],
        {
          dateString: todayDateString,
        }
      );
      vi.useRealTimers();
    });

    test("afterBuffer and beforeBuffer tests - Non Cal Busy Time", async () => {
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });
      const { dateString: plus3DateString } = getDate({ dateIncrement: 3 });

      CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue([
        {
          start: `${plus3DateString}T04:00:00.000Z`,
          end: `${plus3DateString}T05:59:59.000Z`,
        },
      ]);

      const scenarioData = {
        eventTypes: [
          {
            id: 1,
            length: 120,
            beforeEventBuffer: 120,
            afterEventBuffer: 120,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
            credentials: [getGoogleCalendarCredential()],
            selectedCalendars: [TestData.selectedCalendars.google],
          },
        ],
        apps: [TestData.apps.googleCalendar],
      };

      await createBookingScenario(scenarioData);

      const scheduleForEventOnADayWithNonCalBooking = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus2DateString}T18:30:00.000Z`,
          endTime: `${plus3DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(scheduleForEventOnADayWithNonCalBooking).toHaveTimeSlots(
        [
          // `04:00:00.000Z`, // - 4 AM is booked
          // `06:00:00.000Z`, // - 6 AM is not available because 08:00AM slot has a `beforeEventBuffer`
          `08:00:00.000Z`, // - 8 AM is available because of availability of 06:00 - 07:59
          `10:00:00.000Z`,
          `12:00:00.000Z`,
        ],
        {
          dateString: plus3DateString,
        }
      );
    });

    test("afterBuffer and beforeBuffer tests - Cal Busy Time", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });
      const { dateString: plus3DateString } = getDate({ dateIncrement: 3 });

      CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue([
        {
          start: `${plus3DateString}T04:00:00.000Z`,
          end: `${plus3DateString}T05:59:59.000Z`,
        },
      ]);

      const scenarioData = {
        eventTypes: [
          {
            id: 1,
            length: 120,
            beforeEventBuffer: 120,
            afterEventBuffer: 120,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
            credentials: [getGoogleCalendarCredential()],
            selectedCalendars: [TestData.selectedCalendars.google],
          },
        ],
        bookings: [
          {
            userId: 101,
            eventTypeId: 1,
            startTime: `${plus2DateString}T04:00:00.000Z`,
            endTime: `${plus2DateString}T05:59:59.000Z`,
            status: "ACCEPTED" as BookingStatus,
          },
        ],
        apps: [TestData.apps.googleCalendar],
      };

      await createBookingScenario(scenarioData);

      const scheduleForEventOnADayWithCalBooking = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(scheduleForEventOnADayWithCalBooking).toHaveTimeSlots(
        [
          // `04:00:00.000Z`, // - 4 AM is booked
          // `06:00:00.000Z`, // - 6 AM is not available because of afterBuffer(120 mins) of the existing booking(4-5:59AM slot)
          // `08:00:00.000Z`, // - 8 AM is not available because of beforeBuffer(120mins) of possible booking at 08:00
          `10:00:00.000Z`,
          `12:00:00.000Z`,
        ],
        {
          dateString: plus2DateString,
        }
      );
    });

    test("Start times are offset (offsetStart)", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });

      CalendarManagerMock.getBusyCalendarTimes.mockResolvedValue([]);

      const scenarioData = {
        eventTypes: [
          {
            id: 1,
            length: 25,
            offsetStart: 5,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
            credentials: [getGoogleCalendarCredential()],
            selectedCalendars: [TestData.selectedCalendars.google],
          },
        ],
        apps: [TestData.apps.googleCalendar],
      };

      await createBookingScenario(scenarioData);

      const schedule = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(schedule).toHaveTimeSlots(
        [
          `04:05:00.000Z`,
          `04:35:00.000Z`,
          `05:05:00.000Z`,
          `05:35:00.000Z`,
          `06:05:00.000Z`,
          `06:35:00.000Z`,
          `07:05:00.000Z`,
          `07:35:00.000Z`,
          `08:05:00.000Z`,
          `08:35:00.000Z`,
          `09:05:00.000Z`,
          `09:35:00.000Z`,
          `10:05:00.000Z`,
          `10:35:00.000Z`,
          `11:05:00.000Z`,
          `11:35:00.000Z`,
          `12:05:00.000Z`,
        ],
        {
          dateString: plus2DateString,
        }
      );
    });

    test("Check for Date overrides", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });

      const scenarioData = {
        eventTypes: [
          {
            id: 1,
            length: 60,
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHoursWithDateOverride(plus2DateString)],
          },
        ],
      };

      await createBookingScenario(scenarioData);

      const scheduleForEventOnADayWithDateOverride = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(scheduleForEventOnADayWithDateOverride).toHaveTimeSlots(
        ["08:30:00.000Z", "09:30:00.000Z", "10:30:00.000Z", "11:30:00.000Z"],
        {
          dateString: plus2DateString,
        }
      );
    });

    test("that a user is considered busy when there's a booking they host", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });

      await createBookingScenario({
        eventTypes: [
          // A Collective Event Type hosted by this user
          {
            id: 1,
            slotInterval: 45,
            schedulingType: "COLLECTIVE",
            hosts: [
              {
                id: 101,
              },
              {
                id: 102,
              },
            ],
          },
          // A default Event Type which this user owns
          {
            id: 2,
            length: 15,
            slotInterval: 45,
            users: [{ id: 101 }],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
          },
          {
            ...TestData.users.example,
            id: 102,
            schedules: [TestData.schedules.IstWorkHours],
          },
        ],
        bookings: [
          // Create a booking on our Collective Event Type
          {
            userId: 101,
            attendees: [
              {
                email: "IntegrationTestUser102@example.com",
              },
            ],
            eventTypeId: 1,
            status: "ACCEPTED",
            startTime: `${plus2DateString}T04:00:00.000Z`,
            endTime: `${plus2DateString}T04:15:00.000Z`,
          },
        ],
      });

      // Requesting this user's availability for their
      // individual Event Type
      const thisUserAvailability = await getSchedule({
        input: {
          eventTypeId: 2,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: false,
        },
      });

      expect(thisUserAvailability).toHaveTimeSlots(
        [
          // `04:00:00.000Z`, // <- This slot should be occupied by the Collective Event
          `04:15:00.000Z`,
          `05:00:00.000Z`,
          `05:45:00.000Z`,
          `06:30:00.000Z`,
          `07:15:00.000Z`,
          `08:00:00.000Z`,
          `08:45:00.000Z`,
          `09:30:00.000Z`,
          `10:15:00.000Z`,
          `11:00:00.000Z`,
          `11:45:00.000Z`,
        ],
        {
          dateString: plus2DateString,
        }
      );
    });
    test("test that booking limit is working correctly if user is all day available", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });
      const { dateString: plus3DateString } = getDate({ dateIncrement: 3 });

      const scenarioData = {
        eventTypes: [
          {
            id: 1,
            length: 60,
            beforeEventBuffer: 0,
            afterEventBuffer: 0,
            bookingLimits: {
              PER_DAY: 1,
            },
            users: [
              {
                id: 101,
              },
            ],
          },
          {
            id: 2,
            length: 60,
            beforeEventBuffer: 0,
            afterEventBuffer: 0,
            bookingLimits: {
              PER_DAY: 2,
            },
            users: [
              {
                id: 101,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [
              {
                id: 1,
                name: "All Day available",
                availability: [
                  {
                    userId: null,
                    eventTypeId: null,
                    days: [0, 1, 2, 3, 4, 5, 6],
                    startTime: new Date("1970-01-01T00:00:00.000Z"),
                    endTime: new Date("1970-01-01T23:59:59.999Z"),
                    date: null,
                  },
                ],
                timeZone: Timezones["+6:00"],
              },
            ],
          },
        ],
        bookings: [
          {
            userId: 101,
            eventTypeId: 1,
            startTime: `${plus2DateString}T08:00:00.000Z`,
            endTime: `${plus2DateString}T09:00:00.000Z`,
            status: "ACCEPTED" as BookingStatus,
          },
          {
            userId: 101,
            eventTypeId: 2,
            startTime: `${plus2DateString}T08:00:00.000Z`,
            endTime: `${plus2DateString}T09:00:00.000Z`,
            status: "ACCEPTED" as BookingStatus,
          },
        ],
      };

      await createBookingScenario(scenarioData);

      const thisUserAvailabilityBookingLimitOne = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T00:00:00.000Z`,
          endTime: `${plus3DateString}T23:59:59.999Z`,
          timeZone: Timezones["+6:00"],
          isTeamEvent: false,
        },
      });

      const thisUserAvailabilityBookingLimitTwo = await getSchedule({
        input: {
          eventTypeId: 2,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T00:00:00.000Z`,
          endTime: `${plus3DateString}T23:59:59.999Z`,
          timeZone: Timezones["+6:00"],
          isTeamEvent: false,
        },
      });

      let availableSlotsInTz: dayjs.Dayjs[] = [];
      for (const date in thisUserAvailabilityBookingLimitOne.slots) {
        thisUserAvailabilityBookingLimitOne.slots[date].forEach((timeObj) => {
          availableSlotsInTz.push(dayjs(timeObj.time).tz(Timezones["+6:00"]));
        });
      }

      expect(availableSlotsInTz.filter((slot) => slot.format().startsWith(plus2DateString)).length).toBe(0); // 1 booking per day as limit

      availableSlotsInTz = [];
      for (const date in thisUserAvailabilityBookingLimitTwo.slots) {
        thisUserAvailabilityBookingLimitTwo.slots[date].forEach((timeObj) => {
          availableSlotsInTz.push(dayjs(timeObj.time).tz(Timezones["+6:00"]));
        });
      }
      expect(availableSlotsInTz.filter((slot) => slot.format().startsWith(plus2DateString)).length).toBe(23); // 2 booking per day as limit, only one booking on that
    });
  });

  describe("Team Event", () => {
    test("correctly identifies unavailable slots from calendar for all users in collective scheduling, considers bookings of users in other events as well", async () => {
      const { dateString: todayDateString } = getDate();

      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });

      await createBookingScenario({
        eventTypes: [
          // An event having two users with one accepted booking
          {
            id: 1,
            slotInterval: 45,
            schedulingType: "COLLECTIVE",
            length: 45,
            users: [
              {
                id: 101,
              },
              {
                id: 102,
              },
            ],
          },
          {
            id: 2,
            slotInterval: 45,
            length: 45,
            users: [
              {
                id: 102,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
          },
          {
            ...TestData.users.example,
            id: 102,
            schedules: [TestData.schedules.IstWorkHours],
          },
        ],
        bookings: [
          {
            userId: 101,
            eventTypeId: 1,
            status: "ACCEPTED",
            startTime: `${plus2DateString}T04:00:00.000Z`,
            endTime: `${plus2DateString}T04:15:00.000Z`,
          },
          {
            userId: 102,
            eventTypeId: 2,
            status: "ACCEPTED",
            startTime: `${plus2DateString}T05:30:00.000Z`,
            endTime: `${plus2DateString}T05:45:00.000Z`,
          },
        ],
      });

      const scheduleForTeamEventOnADayWithNoBooking = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${todayDateString}T18:30:00.000Z`,
          endTime: `${plus1DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: true,
        },
      });

      expect(scheduleForTeamEventOnADayWithNoBooking).toHaveTimeSlots(
        [
          `04:00:00.000Z`,
          `04:45:00.000Z`,
          `05:30:00.000Z`,
          `06:15:00.000Z`,
          `07:00:00.000Z`,
          `07:45:00.000Z`,
          `08:30:00.000Z`,
          `09:15:00.000Z`,
          `10:00:00.000Z`,
          `10:45:00.000Z`,
          `11:30:00.000Z`,
        ],
        {
          dateString: plus1DateString,
        }
      );

      const scheduleForTeamEventOnADayWithOneBookingForEachUser = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: true,
        },
      });

      // A user with blocked time in another event, still affects Team Event availability
      // It's a collective availability, so both user 101 and 102 are considered for timeslots
      expect(scheduleForTeamEventOnADayWithOneBookingForEachUser).toHaveTimeSlots(
        [
          //`04:00:00.000Z`, - Blocked with User 101
          `04:15:00.000Z`,
          //`05:00:00.000Z`, - Blocked with User 102 in event 2
          `05:45:00.000Z`,
          `06:30:00.000Z`,
          `07:15:00.000Z`,
          `08:00:00.000Z`,
          `08:45:00.000Z`,
          `09:30:00.000Z`,
          `10:15:00.000Z`,
          `11:00:00.000Z`,
          `11:45:00.000Z`,
        ],
        { dateString: plus2DateString }
      );
    });

    test("correctly identifies unavailable slots from calendar for all users in Round Robin scheduling, considers bookings of users in other events as well", async () => {
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const { dateString: plus2DateString } = getDate({ dateIncrement: 2 });
      const { dateString: plus3DateString } = getDate({ dateIncrement: 3 });

      await createBookingScenario({
        eventTypes: [
          // An event having two users with one accepted booking
          {
            id: 1,
            slotInterval: 45,
            length: 45,
            users: [
              {
                id: 101,
              },
              {
                id: 102,
              },
            ],
            schedulingType: "ROUND_ROBIN",
          },
          {
            id: 2,
            slotInterval: 45,
            length: 45,
            users: [
              {
                id: 102,
              },
            ],
          },
        ],
        users: [
          {
            ...TestData.users.example,
            id: 101,
            schedules: [TestData.schedules.IstWorkHours],
          },
          {
            ...TestData.users.example,
            id: 102,
            schedules: [TestData.schedules.IstWorkHours],
          },
        ],
        bookings: [
          {
            userId: 101,
            eventTypeId: 1,
            status: "ACCEPTED",
            startTime: `${plus2DateString}T04:00:00.000Z`,
            endTime: `${plus2DateString}T04:15:00.000Z`,
          },
          {
            userId: 102,
            eventTypeId: 2,
            status: "ACCEPTED",
            startTime: `${plus2DateString}T05:30:00.000Z`,
            endTime: `${plus2DateString}T05:45:00.000Z`,
          },
          {
            userId: 101,
            eventTypeId: 1,
            status: "ACCEPTED",
            startTime: `${plus3DateString}T04:00:00.000Z`,
            endTime: `${plus3DateString}T04:15:00.000Z`,
          },
          {
            userId: 102,
            eventTypeId: 2,
            status: "ACCEPTED",
            startTime: `${plus3DateString}T04:00:00.000Z`,
            endTime: `${plus3DateString}T04:15:00.000Z`,
          },
        ],
      });
      const scheduleForTeamEventOnADayWithOneBookingForEachUserButOnDifferentTimeslots = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus1DateString}T18:30:00.000Z`,
          endTime: `${plus2DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: true,
        },
      });
      // A user with blocked time in another event, still affects Team Event availability
      expect(scheduleForTeamEventOnADayWithOneBookingForEachUserButOnDifferentTimeslots).toHaveTimeSlots(
        [
          `04:00:00.000Z`, // - Blocked with User 101 but free with User 102. Being RoundRobin it is still bookable
          `04:45:00.000Z`,
          `05:30:00.000Z`, // - Blocked with User 102 but free with User 101. Being RoundRobin it is still bookable
          `06:15:00.000Z`,
          `07:00:00.000Z`,
          `07:45:00.000Z`,
          `08:30:00.000Z`,
          `09:15:00.000Z`,
          `10:00:00.000Z`,
          `10:45:00.000Z`,
          `11:30:00.000Z`,
        ],
        { dateString: plus2DateString }
      );

      const scheduleForTeamEventOnADayWithOneBookingForEachUserOnSameTimeSlot = await getSchedule({
        input: {
          eventTypeId: 1,
          eventTypeSlug: "",
          startTime: `${plus2DateString}T18:30:00.000Z`,
          endTime: `${plus3DateString}T18:29:59.999Z`,
          timeZone: Timezones["+5:30"],
          isTeamEvent: true,
        },
      });
      // A user with blocked time in another event, still affects Team Event availability
      expect(scheduleForTeamEventOnADayWithOneBookingForEachUserOnSameTimeSlot).toHaveTimeSlots(
        [
          //`04:00:00.000Z`, // - Blocked with User 101 as well as User 102, so not available in Round Robin
          `04:15:00.000Z`,
          `05:00:00.000Z`,
          `05:45:00.000Z`,
          `06:30:00.000Z`,
          `07:15:00.000Z`,
          `08:00:00.000Z`,
          `08:45:00.000Z`,
          `09:30:00.000Z`,
          `10:15:00.000Z`,
          `11:00:00.000Z`,
          `11:45:00.000Z`,
        ],
        { dateString: plus3DateString }
      );
    });
  });
});
import { expect, it, vi, beforeAll } from "vitest";

import dayjs from "@calcom/dayjs";
import { getWorkingHours } from "@calcom/lib/availability";

beforeAll(() => {
  vi.setSystemTime(new Date("2021-06-20T11:59:59Z"));
});

it("correctly translates Availability (UTC+0) to UTC workingHours", async () => {
  expect(
    getWorkingHours({ timeZone: "GMT" }, [
      {
        days: [0],
        startTime: new Date(Date.UTC(2021, 11, 16, 23)),
        endTime: new Date(Date.UTC(2021, 11, 16, 23, 59)),
      },
    ])
  ).toStrictEqual([
    {
      days: [0],
      endTime: 1439,
      startTime: 1380,
    },
  ]);
});

it("correctly translates Availability in a positive UTC offset (Pacific/Auckland) to UTC workingHours", async () => {
  // Take note that (Pacific/Auckland) is UTC+12 on 2021-06-20, NOT +13 like the other half of the year.
  expect(
    getWorkingHours({ timeZone: "Pacific/Auckland" }, [
      {
        days: [1],
        startTime: new Date(Date.UTC(2021, 11, 16, 0)),
        endTime: new Date(Date.UTC(2021, 11, 16, 23, 59)),
      },
    ])
  ).toStrictEqual([
    {
      days: [1],
      endTime: 719,
      startTime: 0,
    },
    {
      days: [0],
      endTime: 1439,
      startTime: 720, // 0 (midnight) - 12 * 60 (DST)
    },
  ]);
});

it("correctly translates Availability in a negative UTC offset (Pacific/Midway) to UTC workingHours", async () => {
  // Take note that (Pacific/Midway) is UTC-12 on 2021-06-20, NOT +13 like the other half of the year.
  expect(
    getWorkingHours({ timeZone: "Pacific/Midway" }, [
      {
        days: [1],
        startTime: new Date(Date.UTC(2021, 11, 16, 0)),
        endTime: new Date(Date.UTC(2021, 11, 16, 23, 59)),
      },
    ])
  ).toStrictEqual([
    {
      days: [2],
      endTime: 659,
      startTime: 0,
    },
    {
      days: [1],
      endTime: 1439,
      startTime: 660,
    },
  ]);
});

it("can do the same with UTC offsets", async () => {
  // Take note that (Pacific/Midway) is UTC-12 on 2021-06-20, NOT +13 like the other half of the year.
  expect(
    getWorkingHours({ utcOffset: dayjs().tz("Pacific/Midway").utcOffset() }, [
      {
        days: [1],
        startTime: new Date(Date.UTC(2021, 11, 16, 0)),
        endTime: new Date(Date.UTC(2021, 11, 16, 23, 59)),
      },
    ])
  ).toStrictEqual([
    {
      days: [2],
      endTime: 659,
      startTime: 0,
    },
    {
      days: [1],
      endTime: 1439,
      startTime: 660,
    },
  ]);
});

it("can also shift UTC into other timeZones", async () => {
  // UTC+0 time with 23:00 - 23:59 (Sunday) and 00:00 - 16:00 (Monday) when cast into UTC+1 should become 00:00 = 17:00 (Monday)
  expect(
    getWorkingHours({ utcOffset: -60 }, [
      {
        days: [0],
        startTime: new Date(Date.UTC(2021, 11, 16, 23)),
        endTime: new Date(Date.UTC(2021, 11, 16, 23, 59)),
      },
      {
        days: [1],
        startTime: new Date(Date.UTC(2021, 11, 17, 0)),
        endTime: new Date(Date.UTC(2021, 11, 17, 16)),
      },
    ])
  ).toStrictEqual([
    // TODO: Maybe the desired result is 0-1020 as a single entry, but this requires some post-processing to merge. It may work as is so leaving this as now.
    {
      days: [1],
      endTime: 59,
      startTime: 0,
    },
    {
      days: [1],
      endTime: 1020,
      startTime: 60,
    },
  ]);
  // And the other way around; UTC+0 time with 00:00 - 1:00 (Monday) and 21:00 - 24:00 (Sunday) when cast into UTC-1 should become 20:00 = 24:00 (Sunday)
  expect(
    getWorkingHours({ utcOffset: 60 }, [
      {
        days: [0],
        startTime: new Date(Date.UTC(2021, 11, 16, 21)),
        endTime: new Date(Date.UTC(2021, 11, 16, 23, 59)),
      },
      {
        days: [1],
        startTime: new Date(Date.UTC(2021, 11, 17, 0)),
        endTime: new Date(Date.UTC(2021, 11, 17, 1)),
      },
    ])
  ).toStrictEqual([
    // TODO: Maybe the desired result is 1200-1439 as a single entry, but this requires some post-processing to merge. It may work as is so leaving this as now.
    {
      days: [0],
      endTime: 1379,
      startTime: 1200,
    },
    {
      days: [0],
      endTime: 1439,
      startTime: 1380,
    },
  ]);
});
import type { Availability } from "@prisma/client";
import { expect, it, beforeAll, vi } from "vitest";

import dayjs from "@calcom/dayjs";
import { getAvailabilityFromSchedule } from "@calcom/lib/availability";

beforeAll(() => {
  vi.setSystemTime(new Date("2021-06-20T11:59:59Z"));
});

//parse "hh:mm-hh:mm" into <Availability> object
const parseWorkingHours = (workingHours: string) => {
  const times = workingHours.split("-").map((time) => dayjs(time, "hh:mm").toDate());
  return { start: times[0], end: times[1] };
};

const p = parseWorkingHours;

// mocked working hours
const fulltimeWH = p("09:00-17:00");

const morningWH = p("09:00-12:00");

const afternoonWH = p("13:00-17:00");

it("should return an empty availability array when received an empty schedule", async () => {
  const schedule = [[]];
  expect(getAvailabilityFromSchedule(schedule)).toStrictEqual([]);
});

it("should return availability for all workable days from 9:00 to 17:00", async () => {
  const schedule = [[], [fulltimeWH], [fulltimeWH], [fulltimeWH], [fulltimeWH], [fulltimeWH], []];
  const expected = [
    {
      days: [1, 2, 3, 4, 5],
      startTime: fulltimeWH.start,
      endTime: fulltimeWH.end,
    },
  ] as Availability[];

  expect(getAvailabilityFromSchedule(schedule)).toStrictEqual(expected);
});

it("should return the available days grouped by the available time slots", async () => {
  const schedule = [
    [],
    [afternoonWH],
    [afternoonWH],
    [morningWH, afternoonWH],
    [fulltimeWH],
    [morningWH],
    [],
  ];
  const expected = [
    {
      days: [1, 2, 3],
      startTime: afternoonWH.start,
      endTime: afternoonWH.end,
    },
    {
      days: [3, 5],
      startTime: morningWH.start,
      endTime: morningWH.end,
    },

    {
      days: [4],
      startTime: fulltimeWH.start,
      endTime: fulltimeWH.end,
    },
  ] as Availability[];

  expect(getAvailabilityFromSchedule(schedule)).toStrictEqual(expected);
});
import { expect, it, beforeAll, vi } from "vitest";

import { getAggregateWorkingHours } from "@calcom/core/getAggregateWorkingHours";

beforeAll(() => {
  vi.setSystemTime(new Date("2021-06-20T11:59:59Z"));
});

const HAWAII_AND_NEWYORK_TEAM = [
  {
    timeZone: "America/Detroit", // GMT -4 per 22th of Aug, 2022
    workingHours: [{ userId: 1, days: [1, 2, 3, 4, 5], startTime: 780, endTime: 1260 }],
    busy: [],
    dateOverrides: [],
  },
  {
    timeZone: "Pacific/Honolulu", // GMT -10 per 22th of Aug, 2022
    workingHours: [
      { userId: 1, days: [3, 4, 5], startTime: 0, endTime: 360 },
      { userId: 2, days: [6], startTime: 0, endTime: 180 },
      { userId: 3, days: [2, 3, 4], startTime: 780, endTime: 1439 },
      { userId: 4, days: [5], startTime: 780, endTime: 1439 },
    ],
    busy: [],
    dateOverrides: [],
  },
];

/* TODO: Make this test more "professional" */
it("Sydney and Shiraz can live in harmony 🙏", async () => {
  expect(getAggregateWorkingHours(HAWAII_AND_NEWYORK_TEAM, "COLLECTIVE")).toMatchInlineSnapshot(`
    [
      {
        "days": [
          3,
          4,
          5,
        ],
        "endTime": 360,
        "startTime": 780,
      },
      {
        "days": [
          6,
        ],
        "endTime": 180,
        "startTime": 0,
        "userId": 2,
      },
      {
        "days": [
          2,
          3,
          4,
        ],
        "endTime": 1260,
        "startTime": 780,
      },
      {
        "days": [
          5,
        ],
        "endTime": 1260,
        "startTime": 780,
      },
    ]
  `);

  expect(getAggregateWorkingHours(HAWAII_AND_NEWYORK_TEAM, "ROUND_ROBIN")).toMatchInlineSnapshot(`
    [
      {
        "days": [
          1,
          2,
          3,
          4,
          5,
        ],
        "endTime": 1260,
        "startTime": 780,
        "userId": 1,
      },
      {
        "days": [
          3,
          4,
          5,
        ],
        "endTime": 360,
        "startTime": 0,
        "userId": 1,
      },
      {
        "days": [
          6,
        ],
        "endTime": 180,
        "startTime": 0,
        "userId": 2,
      },
      {
        "days": [
          2,
          3,
          4,
        ],
        "endTime": 1439,
        "startTime": 780,
        "userId": 3,
      },
      {
        "days": [
          5,
        ],
        "endTime": 1439,
        "startTime": 780,
        "userId": 4,
      },
    ]
  `);
});
import prismaMock from "../../../../tests/libs/__mocks__/prismaMock";

import { expect, it } from "vitest";

import { getLuckyUser } from "@calcom/lib/server";
import { buildUser } from "@calcom/lib/test/builder";

it("can find lucky user with maximize availability", async () => {
  const user1 = buildUser({
    id: 1,
    username: "test",
    name: "Test User",
    email: "test@example.com",
    bookings: [
      {
        createdAt: new Date("2022-01-25T05:30:00.000Z"),
      },
      {
        createdAt: new Date("2022-01-25T06:30:00.000Z"),
      },
    ],
  });
  const user2 = buildUser({
    id: 2,
    username: "test2",
    name: "Test User 2",
    email: "tes2t@example.com",
    bookings: [
      {
        createdAt: new Date("2022-01-25T04:30:00.000Z"),
      },
    ],
  });
  const users = [user1, user2];
  // TODO: we may be able to use native prisma generics somehow?
  prismaMock.user.findMany.mockResolvedValue(users);
  prismaMock.booking.findMany.mockResolvedValue([]);

  await expect(
    getLuckyUser("MAXIMIZE_AVAILABILITY", {
      availableUsers: users,
      eventTypeId: 1,
    })
  ).resolves.toStrictEqual(users[1]);
});
import { expect, it } from "vitest";

import { filterByCities, addCitiesToDropdown, handleOptionLabel } from "@calcom/lib/timezone";

const cityData = [
  {
    city: "San Francisco",
    timezone: "America/Argentina/Cordoba",
  },
  {
    city: "Sao Francisco do Sul",
    timezone: "America/Sao_Paulo",
  },
  {
    city: "San Francisco de Macoris",
    timezone: "America/Santo_Domingo",
  },
  {
    city: "San Francisco Gotera",
    timezone: "America/El_Salvador",
  },
  {
    city: "San Francisco",
    timezone: "America/Los_Angeles",
  },
];

const option = {
  value: "America/Los_Angeles",
  label: "(GMT-8:00) San Francisco",
  offset: -8,
  abbrev: "PST",
  altName: "Pacific Standard Time",
};

it("should return empty array for an empty string", () => {
  expect(filterByCities("", cityData)).toMatchInlineSnapshot(`[]`);
});

it("should filter cities for a valid city name", () => {
  expect(filterByCities("San Francisco", cityData)).toMatchInlineSnapshot(`
    [
      {
        "city": "San Francisco",
        "timezone": "America/Argentina/Cordoba",
      },
      {
        "city": "San Francisco de Macoris",
        "timezone": "America/Santo_Domingo",
      },
      {
        "city": "San Francisco Gotera",
        "timezone": "America/El_Salvador",
      },
      {
        "city": "San Francisco",
        "timezone": "America/Los_Angeles",
      },
    ]
  `);
});

it("should return appropriate timezone(s) for a given city name array", () => {
  expect(addCitiesToDropdown(cityData)).toMatchInlineSnapshot(`
    {
      "America/Argentina/Cordoba": "San Francisco",
      "America/El_Salvador": "San Francisco Gotera",
      "America/Los_Angeles": "San Francisco",
      "America/Santo_Domingo": "San Francisco de Macoris",
      "America/Sao_Paulo": "Sao Francisco do Sul",
    }
  `);
});

it("should render city name as option label if cityData is not empty", () => {
  expect(handleOptionLabel(option, cityData)).toMatchInlineSnapshot(`"San Francisco GMT -8:00"`);
});

it("should return timezone as option label if cityData is empty", () => {
  expect(handleOptionLabel(option, [])).toMatchInlineSnapshot(`"America/Los Angeles GMT -8:00"`);
});
import { it, expect, describe, beforeAll } from "vitest";

// eslint-disable-next-line @typescript-eslint/no-var-requires
const { getSubdomainRegExp } = require("../../getSubdomainRegExp");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { match, pathToRegexp } = require("next/dist/compiled/path-to-regexp");
type MatcherRes = (path: string) => { params: Record<string, string> };

let orgUserTypeRouteMatch: MatcherRes;

let orgUserRouteMatch: MatcherRes;

beforeAll(async () => {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  process.env.NEXT_PUBLIC_WEBAPP_URL = "http://example.com";
  const {
    orgUserRoutePath,
    orgUserTypeRoutePath,
    // eslint-disable-next-line @typescript-eslint/no-var-requires
  } = require("../../pagesAndRewritePaths");

  orgUserTypeRouteMatch = match(orgUserTypeRoutePath);

  orgUserRouteMatch = match(orgUserRoutePath);
  console.log({
    regExps: {
      orgUserTypeRouteMatch: pathToRegexp(orgUserTypeRoutePath),
      orgUserRouteMatch: pathToRegexp(orgUserRoutePath),
    },
  });
});

describe("next.config.js - Org Rewrite", () => {
  const orgHostRegExp = (subdomainRegExp: string) =>
    // RegExp copied from pagesAndRewritePaths.js orgHostPath. Do make the change there as well.
    new RegExp(`^(?<orgSlug>${subdomainRegExp})\\.(?!vercel\.app).*`);

  describe("Host matching based on NEXT_PUBLIC_WEBAPP_URL", () => {
    it("https://app.cal.com", () => {
      const subdomainRegExp = getSubdomainRegExp("https://app.cal.com");
      expect(orgHostRegExp(subdomainRegExp).exec("app.cal.com")).toEqual(null);
      expect(orgHostRegExp(subdomainRegExp).exec("company.app.cal.com")?.groups?.orgSlug).toEqual("company");
      expect(orgHostRegExp(subdomainRegExp).exec("org.cal.com")?.groups?.orgSlug).toEqual("org");

      expect(orgHostRegExp(subdomainRegExp).exec("localhost:3000")).toEqual(null);
    });

    it("app.cal.com", () => {
      const subdomainRegExp = getSubdomainRegExp("app.cal.com");
      expect(orgHostRegExp(subdomainRegExp).exec("app.cal.com")).toEqual(null);
      expect(orgHostRegExp(subdomainRegExp).exec("company.app.cal.com")?.groups?.orgSlug).toEqual("company");
    });

    it("https://calcom.app.company.com", () => {
      const subdomainRegExp = getSubdomainRegExp("https://calcom.app.company.com");
      expect(orgHostRegExp(subdomainRegExp).exec("calcom.app.company.com")).toEqual(null);
      expect(orgHostRegExp(subdomainRegExp).exec("acme.calcom.app.company.com")?.groups?.orgSlug).toEqual(
        "acme"
      );
    });

    it("https://calcom.example.com", () => {
      const subdomainRegExp = getSubdomainRegExp("https://calcom.example.com");
      expect(orgHostRegExp(subdomainRegExp).exec("calcom.example.com")).toEqual(null);
      expect(orgHostRegExp(subdomainRegExp).exec("acme.calcom.example.com")?.groups?.orgSlug).toEqual("acme");
      // The following also matches which causes anything other than the domain in NEXT_PUBLIC_WEBAPP_URL to give 404
      expect(orgHostRegExp(subdomainRegExp).exec("some-other.company.com")?.groups?.orgSlug).toEqual(
        "some-other"
      );
    });
    it("Should ignore Vercel preview URLs", () => {
      const subdomainRegExp = getSubdomainRegExp("https://cal-xxxxxxxx-cal.vercel.app");
      expect(
        orgHostRegExp(subdomainRegExp).exec("https://cal-xxxxxxxx-cal.vercel.app")
      ).toMatchInlineSnapshot("null");
      expect(orgHostRegExp(subdomainRegExp).exec("cal-xxxxxxxx-cal.vercel.app")).toMatchInlineSnapshot(
        "null"
      );
    });
  });

  describe("Rewrite", () => {
    it("booking pages", () => {
      expect(orgUserTypeRouteMatch("/user/type")?.params).toContain({
        user: "user",
        type: "type",
      });

      // User slug starting with 404(which is a page route) will work
      expect(orgUserTypeRouteMatch("/404a/def")?.params).toEqual({
        user: "404a",
        type: "def",
      });

      // Team Page won't match - There is no /team prefix required for Org team event pages
      expect(orgUserTypeRouteMatch("/team/abc")).toEqual(false);

      expect(orgUserTypeRouteMatch("/abc")).toEqual(false);

      expect(orgUserRouteMatch("/abc")?.params).toContain({
        user: "abc",
      });

      // Tests that something that starts with 'd' which could accidentally match /d route is correctly identified as a booking page
      expect(orgUserRouteMatch("/designer")?.params).toContain({
        user: "designer",
      });

      // Tests that something that starts with 'apps' which could accidentally match /apps route is correctly identified as a booking page
      expect(orgUserRouteMatch("/apps-conflict-possibility")?.params).toContain({
        user: "apps-conflict-possibility",
      });

      // Tests that something that starts with '_next' which could accidentally match /_next route is correctly identified as a booking page
      expect(orgUserRouteMatch("/_next-candidate")?.params).toContain({
        user: "_next-candidate",
      });

      // Tests that something that starts with 'public' which could accidentally match /public route is correctly identified as a booking page
      expect(orgUserRouteMatch("/public-person")?.params).toContain({
        user: "public-person",
      });
    });

    it("Non booking pages", () => {
      expect(orgUserTypeRouteMatch("/_next/def")).toEqual(false);
      expect(orgUserTypeRouteMatch("/public/def")).toEqual(false);

      expect(orgUserRouteMatch("/_next/")).toEqual(false);
      expect(orgUserRouteMatch("/public/")).toEqual(false);

      expect(orgUserRouteMatch("/event-types/")).toEqual(false);
      expect(orgUserTypeRouteMatch("/event-types/")).toEqual(false);

      expect(orgUserRouteMatch("/event-types/?abc=1")).toEqual(false);
      expect(orgUserTypeRouteMatch("/event-types/?abc=1")).toEqual(false);

      expect(orgUserRouteMatch("/event-types")).toEqual(false);
      expect(orgUserTypeRouteMatch("/event-types")).toEqual(false);

      expect(orgUserRouteMatch("/event-types?abc=1")).toEqual(false);
      expect(orgUserTypeRouteMatch("/event-types?abc=1")).toEqual(false);

      expect(orgUserTypeRouteMatch("/john/avatar.png")).toEqual(false);
      expect(orgUserTypeRouteMatch("/cancel/abcd")).toEqual(false);
      expect(orgUserTypeRouteMatch("/success/abcd")).toEqual(false);
      expect(orgUserRouteMatch("/forms/xdsdf-sd")).toEqual(false);
      expect(orgUserRouteMatch("/router?form=")).toEqual(false);
    });
  });
});
import { expect, it } from "vitest";

import { parseZone } from "@calcom/lib/parse-zone";

const EXPECTED_DATE_STRING = "2021-06-20T11:59:59+02:00";

it("has the right utcOffset regardless of the local timeZone", async () => {
  expect(parseZone(EXPECTED_DATE_STRING)?.utcOffset()).toEqual(120);
  expect(parseZone(EXPECTED_DATE_STRING)?.format()).toEqual(EXPECTED_DATE_STRING);
});
import { expect, it } from "vitest";

import { availabilityAsString } from "@calcom/lib/availability";

it("correctly handles 1 day", async () => {
  const availability = {
    id: 1,
    userId: 2,
    eventTypeId: 3,
    days: [1],
    startTime: new Date(Date.UTC(1970, 1, 1, 9, 0, 0, 0)),
    endTime: new Date(Date.UTC(1970, 1, 1, 17, 0, 0, 0)),
    date: null,
    scheduleId: 1,
  };

  const result = availabilityAsString(availability, {
    locale: "en",
    hour12: true,
  });

  expect(replaceUnicodeSpace(result)).toBe("Mon, 9:00 AM - 5:00 PM");
});

it("correctly handles all days", async () => {
  const availability = {
    id: 1,
    userId: 2,
    eventTypeId: 3,
    days: [1, 2, 3, 4, 5, 6, 7],
    startTime: new Date(Date.UTC(1970, 1, 1, 9, 0, 0, 0)),
    endTime: new Date(Date.UTC(1970, 1, 1, 17, 0, 0, 0)),
    date: null,
    scheduleId: 1,
  };

  const result = availabilityAsString(availability, {
    locale: "en",
    hour12: true,
  });

  expect(replaceUnicodeSpace(result)).toBe("Mon - Sun, 9:00 AM - 5:00 PM");
});

it("correctly handles staggered days", async () => {
  const availability = {
    id: 1,
    userId: 2,
    eventTypeId: 3,
    days: [1, 3, 5, 7],
    startTime: new Date(Date.UTC(1970, 1, 1, 9, 0, 0, 0)),
    endTime: new Date(Date.UTC(1970, 1, 1, 17, 0, 0, 0)),
    date: null,
    scheduleId: 1,
  };

  const result = availabilityAsString(availability, {
    locale: "en",
    hour12: true,
  });

  expect(replaceUnicodeSpace(result)).toBe("Mon, Wed, Fri, Sun, 9:00 AM - 5:00 PM");
});

it("correctly produces days and times - 12 hours", async () => {
  const availability = {
    id: 1,
    userId: 2,
    eventTypeId: 3,
    days: [1, 2, 3],
    startTime: new Date(Date.UTC(1970, 1, 1, 9, 0, 0, 0)),
    endTime: new Date(Date.UTC(1970, 1, 1, 17, 0, 0, 0)),
    date: null,
    scheduleId: 1,
  };

  const result = availabilityAsString(availability, {
    locale: "en",
    hour12: true,
  });

  expect(replaceUnicodeSpace(result)).toBe("Mon - Wed, 9:00 AM - 5:00 PM");
});

it("correctly produces days and times - 24 hours", async () => {
  const availability = {
    id: 1,
    userId: 2,
    eventTypeId: 3,
    days: [1, 2, 3],
    startTime: new Date(Date.UTC(1970, 1, 1, 9, 0, 0, 0)),
    endTime: new Date(Date.UTC(1970, 1, 1, 17, 0, 0, 0)),
    date: null,
    scheduleId: 1,
  };

  const result = availabilityAsString(availability, {
    locale: "en",
    hour12: false,
  });

  expect(replaceUnicodeSpace(result)).toBe("Mon - Wed, 09:00 - 17:00");
});

// INFO: This is because on GitHub, the international date formatting
// produces Unicode characters. Instead of using line for line code from the
// availability.ts file, opted for this instead.
const replaceUnicodeSpace = (string: string) => {
  return string.replace(/\u202f/g, " ");
};
import prismaMock from "../../../../tests/libs/__mocks__/prismaMock";

import { describe, expect, it } from "vitest";

import dayjs from "@calcom/dayjs";
import { validateIntervalLimitOrder } from "@calcom/lib";
import { checkBookingLimits, checkBookingLimit } from "@calcom/lib/server";
import type { IntervalLimit } from "@calcom/types/Calendar";

type Mockdata = {
  id: number;
  startDate: Date;
  bookingLimits: IntervalLimit;
};

const MOCK_DATA: Mockdata = {
  id: 1,
  startDate: dayjs("2022-09-30T09:00:00+01:00").toDate(),
  bookingLimits: {
    PER_DAY: 1,
  },
};

describe("Check Booking Limits Tests", () => {
  it("Should return no errors", async () => {
    prismaMock.booking.count.mockResolvedValue(0);
    expect(
      checkBookingLimits(MOCK_DATA.bookingLimits, MOCK_DATA.startDate, MOCK_DATA.id)
    ).resolves.toBeTruthy();
  });
  it("Should throw an error", async () => {
    // Mock there being two a day
    prismaMock.booking.count.mockResolvedValue(2);
    expect(
      checkBookingLimits(MOCK_DATA.bookingLimits, MOCK_DATA.startDate, MOCK_DATA.id)
    ).rejects.toThrowError();
  });

  it("Should pass with multiple booking limits", async () => {
    prismaMock.booking.count.mockResolvedValue(0);
    expect(
      checkBookingLimits(
        {
          PER_DAY: 1,
          PER_WEEK: 2,
        },
        MOCK_DATA.startDate,
        MOCK_DATA.id
      )
    ).resolves.toBeTruthy();
  });
  it("Should pass with multiple booking limits with one undefined", async () => {
    prismaMock.booking.count.mockResolvedValue(0);
    expect(
      checkBookingLimits(
        {
          PER_DAY: 1,
          PER_WEEK: undefined,
        },
        MOCK_DATA.startDate,
        MOCK_DATA.id
      )
    ).resolves.toBeTruthy();
  });
  it("Should handle mutiple limits correctly", async () => {
    prismaMock.booking.count.mockResolvedValue(1);
    expect(
      checkBookingLimit({
        key: "PER_DAY",
        limitingNumber: 2,
        eventStartDate: MOCK_DATA.startDate,
        eventId: MOCK_DATA.id,
      })
    ).resolves.not.toThrow();
    prismaMock.booking.count.mockResolvedValue(3);
    expect(
      checkBookingLimit({
        key: "PER_WEEK",
        limitingNumber: 2,
        eventStartDate: MOCK_DATA.startDate,
        eventId: MOCK_DATA.id,
      })
    ).rejects.toThrowError();
  });
});

describe("Booking limit validation", () => {
  it("Should validate a correct limit", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 3, PER_MONTH: 5 })).toBe(true);
  });

  it("Should invalidate an incorrect limit", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 9, PER_MONTH: 5 })).toBe(false);
  });

  it("Should validate a correct limit with 'gaps' ", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 9, PER_YEAR: 25 })).toBe(true);
  });

  it("Should validate a correct limit with equal values ", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 1, PER_YEAR: 1 })).toBe(true);
  });
  it("Should validate a correct with empty", () => {
    expect(validateIntervalLimitOrder({})).toBe(true);
  });
});
import prismaMock from "../../../../tests/libs/__mocks__/prismaMock";

import { describe, expect, it } from "vitest";

import dayjs from "@calcom/dayjs";
import { validateIntervalLimitOrder } from "@calcom/lib";
import { checkDurationLimit, checkDurationLimits } from "@calcom/lib/server";

type MockData = {
  id: number;
  startDate: Date;
};

const MOCK_DATA: MockData = {
  id: 1,
  startDate: dayjs("2022-09-30T09:00:00+01:00").toDate(),
};

// Path: apps/web/test/lib/checkDurationLimits.ts
describe("Check Duration Limits Tests", () => {
  it("Should return no errors if limit is not reached", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 0 }]);
    await expect(
      checkDurationLimits({ PER_DAY: 60 }, MOCK_DATA.startDate, MOCK_DATA.id)
    ).resolves.toBeTruthy();
  });
  it("Should throw an error if limit is reached", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 60 }]);
    await expect(
      checkDurationLimits({ PER_DAY: 60 }, MOCK_DATA.startDate, MOCK_DATA.id)
    ).rejects.toThrowError();
  });
  it("Should pass with multiple duration limits", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 30 }]);
    await expect(
      checkDurationLimits(
        {
          PER_DAY: 60,
          PER_WEEK: 120,
        },
        MOCK_DATA.startDate,
        MOCK_DATA.id
      )
    ).resolves.toBeTruthy();
  });
  it("Should pass with multiple duration limits with one undefined", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 30 }]);
    await expect(
      checkDurationLimits(
        {
          PER_DAY: 60,
          PER_WEEK: undefined,
        },
        MOCK_DATA.startDate,
        MOCK_DATA.id
      )
    ).resolves.toBeTruthy();
  });
  it("Should return no errors if limit is not reached with multiple bookings", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 60 }]);
    await expect(
      checkDurationLimits(
        {
          PER_DAY: 90,
          PER_WEEK: 120,
        },
        MOCK_DATA.startDate,
        MOCK_DATA.id
      )
    ).resolves.toBeTruthy();
  });
  it("Should throw an error if one of the limit is reached with multiple bookings", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 90 }]);
    await expect(
      checkDurationLimits(
        {
          PER_DAY: 60,
          PER_WEEK: 120,
        },
        MOCK_DATA.startDate,
        MOCK_DATA.id
      )
    ).rejects.toThrowError();
  });
});

// Path: apps/web/test/lib/checkDurationLimits.ts
describe("Check Duration Limit Tests", () => {
  it("Should return no busyTimes and no error if limit is not reached", async () => {
    prismaMock.$queryRaw.mockResolvedValue([{ totalMinutes: 60 }]);
    await expect(
      checkDurationLimit({
        key: "PER_DAY",
        limitingNumber: 90,
        eventStartDate: MOCK_DATA.startDate,
        eventId: MOCK_DATA.id,
      })
    ).resolves.toBeUndefined();
  });
});

describe("Duration limit validation", () => {
  it("Should validate limit where ranges have ascending values", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 30, PER_MONTH: 60 })).toBe(true);
  });
  it("Should invalidate limit where ranges does not have a strict ascending values", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 60, PER_WEEK: 30 })).toBe(false);
  });
  it("Should validate a correct limit with 'gaps'", () => {
    expect(validateIntervalLimitOrder({ PER_DAY: 60, PER_YEAR: 120 })).toBe(true);
  });
  it("Should validate empty limit", () => {
    expect(validateIntervalLimitOrder({})).toBe(true);
  });
});
/* eslint-disable @typescript-eslint/no-unused-vars */
import prismaMock from "../../../../tests/libs/__mocks__/prismaMock";

import type { EventType } from "@prisma/client";
import { describe, expect, it, vi } from "vitest";

import updateChildrenEventTypes from "@calcom/features/ee/managed-event-types/lib/handleChildrenEventTypes";
import { buildEventType } from "@calcom/lib/test/builder";
import type { Prisma } from "@calcom/prisma/client";
import type { CompleteEventType, CompleteWorkflowsOnEventTypes } from "@calcom/prisma/zod";

const mockFindFirstEventType = (data?: Partial<CompleteEventType>) => {
  const eventType = buildEventType(data as Partial<EventType>);
  prismaMock.eventType.findFirst.mockResolvedValue(eventType as EventType);
  return eventType;
};

vi.mock("@calcom/emails/email-manager", () => {
  return {
    sendSlugReplacementEmail: () => ({}),
  };
});

vi.mock("@calcom/lib/server/i18n", () => {
  return {
    getTranslation: (key: string) => key,
  };
});

describe("handleChildrenEventTypes", () => {
  describe("Shortcircuits", () => {
    it("Returns message 'No managed event type'", async () => {
      mockFindFirstEventType();

      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [], team: { name: "" } },
        children: [],
        updatedEventType: { schedulingType: null, slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(result.newUserIds).toEqual(undefined);
      expect(result.oldUserIds).toEqual(undefined);
      expect(result.deletedUserIds).toEqual(undefined);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
      expect(result.message).toBe("No managed event type");
    });

    it("Returns message 'No managed event metadata'", async () => {
      mockFindFirstEventType();
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [], team: { name: "" } },
        children: [],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(result.newUserIds).toEqual(undefined);
      expect(result.oldUserIds).toEqual(undefined);
      expect(result.deletedUserIds).toEqual(undefined);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
      expect(result.message).toBe("No managed event metadata");
    });

    it("Returns message 'Missing event type'", async () => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      prismaMock.eventType.findFirst.mockImplementation(() => {
        return new Promise((resolve) => {
          resolve(null);
        });
      });
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [], team: { name: "" } },
        children: [],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(result.newUserIds).toEqual(undefined);
      expect(result.oldUserIds).toEqual(undefined);
      expect(result.deletedUserIds).toEqual(undefined);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
      expect(result.message).toBe("Missing event type");
    });
  });

  describe("Happy paths", () => {
    it("Adds new users", async () => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const {
        schedulingType,
        id,
        teamId,
        timeZone,
        requiresBookerEmailVerification,
        lockTimeZoneToggleOnBookingPage,
        ...evType
      } = mockFindFirstEventType({
        id: 123,
        metadata: { managedEventConfig: {} },
        locations: [],
      });
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [], team: { name: "" } },
        children: [{ hidden: false, owner: { id: 4, name: "", email: "", eventTypeSlugs: [] } }],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(prismaMock.eventType.create).toHaveBeenCalledWith({
        data: {
          ...evType,
          parentId: 1,
          users: { connect: [{ id: 4 }] },
          bookingLimits: undefined,
          durationLimits: undefined,
          recurringEvent: undefined,
          userId: 4,
        },
      });
      expect(result.newUserIds).toEqual([4]);
      expect(result.oldUserIds).toEqual([]);
      expect(result.deletedUserIds).toEqual([]);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
    });

    it("Updates old users", async () => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const {
        schedulingType,
        id,
        teamId,
        timeZone,
        locations,
        parentId,
        userId,
        scheduleId,
        requiresBookerEmailVerification,
        lockTimeZoneToggleOnBookingPage,
        ...evType
      } = mockFindFirstEventType({
        metadata: { managedEventConfig: {} },
        locations: [],
      });
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [{ userId: 4 }], team: { name: "" } },
        children: [{ hidden: false, owner: { id: 4, name: "", email: "", eventTypeSlugs: [] } }],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: "somestring",
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(prismaMock.eventType.update).toHaveBeenCalledWith({
        data: {
          ...evType,
          bookingLimits: undefined,
          durationLimits: undefined,
          recurringEvent: undefined,
          hashedLink: { create: { link: expect.any(String) } },
        },
        where: {
          userId_parentId: {
            userId: 4,
            parentId: 1,
          },
        },
      });
      expect(result.newUserIds).toEqual([]);
      expect(result.oldUserIds).toEqual([4]);
      expect(result.deletedUserIds).toEqual([]);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
    });

    it("Deletes old users", async () => {
      mockFindFirstEventType({ users: [], metadata: { managedEventConfig: {} }, locations: [] });
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [{ userId: 4 }], team: { name: "" } },
        children: [],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(result.newUserIds).toEqual([]);
      expect(result.oldUserIds).toEqual([]);
      expect(result.deletedUserIds).toEqual([4]);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
    });

    it("Adds new users and updates/delete old users", async () => {
      mockFindFirstEventType({
        metadata: { managedEventConfig: {} },
        locations: [],
      });
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [{ userId: 4 }, { userId: 1 }], team: { name: "" } },
        children: [
          { hidden: false, owner: { id: 4, name: "", email: "", eventTypeSlugs: [] } },
          { hidden: false, owner: { id: 5, name: "", email: "", eventTypeSlugs: [] } },
        ],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      // Have been called
      expect(result.newUserIds).toEqual([5]);
      expect(result.oldUserIds).toEqual([4]);
      expect(result.deletedUserIds).toEqual([1]);
      expect(result.deletedExistentEventTypes).toEqual(undefined);
    });
  });

  describe("Slug conflicts", () => {
    it("Deletes existent event types for new users added", async () => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const {
        schedulingType,
        id,
        teamId,
        timeZone,
        requiresBookerEmailVerification,
        lockTimeZoneToggleOnBookingPage,
        ...evType
      } = mockFindFirstEventType({
        id: 123,
        metadata: { managedEventConfig: {} },
        locations: [],
      });
      prismaMock.eventType.deleteMany.mockResolvedValue([123] as unknown as Prisma.BatchPayload);
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [], team: { name: "" } },
        children: [{ hidden: false, owner: { id: 4, name: "", email: "", eventTypeSlugs: ["something"] } }],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(prismaMock.eventType.create).toHaveBeenCalledWith({
        data: {
          ...evType,
          parentId: 1,
          users: { connect: [{ id: 4 }] },
          bookingLimits: undefined,
          durationLimits: undefined,
          recurringEvent: undefined,
          hashedLink: undefined,
          userId: 4,
        },
      });
      expect(result.newUserIds).toEqual([4]);
      expect(result.oldUserIds).toEqual([]);
      expect(result.deletedUserIds).toEqual([]);
      expect(result.deletedExistentEventTypes).toEqual([123]);
    });
    it("Deletes existent event types for old users updated", async () => {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      const {
        schedulingType,
        id,
        teamId,
        timeZone,
        locations,
        parentId,
        userId,
        requiresBookerEmailVerification,
        lockTimeZoneToggleOnBookingPage,
        ...evType
      } = mockFindFirstEventType({
        metadata: { managedEventConfig: {} },
        locations: [],
      });
      prismaMock.eventType.deleteMany.mockResolvedValue([123] as unknown as Prisma.BatchPayload);
      const result = await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [{ userId: 4 }], team: { name: "" } },
        children: [{ hidden: false, owner: { id: 4, name: "", email: "", eventTypeSlugs: ["something"] } }],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(prismaMock.eventType.update).toHaveBeenCalledWith({
        data: {
          ...evType,
          bookingLimits: undefined,
          durationLimits: undefined,
          recurringEvent: undefined,
          scheduleId: undefined,
        },
        where: {
          userId_parentId: {
            userId: 4,
            parentId: 1,
          },
        },
      });
      expect(result.newUserIds).toEqual([]);
      expect(result.oldUserIds).toEqual([4]);
      expect(result.deletedUserIds).toEqual([]);
      expect(result.deletedExistentEventTypes).toEqual([123]);
    });
  });

  describe("Workflows", () => {
    it("Links workflows to new and existing assigned members", async () => {
      const {
        schedulingType: _schedulingType,
        id: _id,
        teamId: _teamId,
        locations: _locations,
        timeZone: _timeZone,
        parentId: _parentId,
        userId: _userId,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        requiresBookerEmailVerification,
        lockTimeZoneToggleOnBookingPage,
        ...evType
      } = mockFindFirstEventType({
        metadata: { managedEventConfig: {} },
        locations: [],
        workflows: [
          {
            workflowId: 11,
          } as CompleteWorkflowsOnEventTypes,
        ],
      });
      prismaMock.$transaction.mockResolvedValue([{ id: 2 }]);
      await updateChildrenEventTypes({
        eventTypeId: 1,
        oldEventType: { children: [{ userId: 4 }], team: { name: "" } },
        children: [
          { hidden: false, owner: { id: 4, name: "", email: "", eventTypeSlugs: [] } },
          { hidden: false, owner: { id: 5, name: "", email: "", eventTypeSlugs: [] } },
        ],
        updatedEventType: { schedulingType: "MANAGED", slug: "something" },
        currentUserId: 1,
        hashedLink: undefined,
        connectedLink: null,
        prisma: prismaMock,
      });
      expect(prismaMock.eventType.create).toHaveBeenCalledWith({
        data: {
          ...evType,
          bookingLimits: undefined,
          durationLimits: undefined,
          recurringEvent: undefined,
          hashedLink: undefined,
          locations: [],
          parentId: 1,
          userId: 5,
          users: {
            connect: [
              {
                id: 5,
              },
            ],
          },
          workflows: {
            create: [{ workflowId: 11 }],
          },
        },
      });
      expect(prismaMock.eventType.update).toHaveBeenCalledWith({
        data: {
          ...evType,
          bookingLimits: undefined,
          durationLimits: undefined,
          recurringEvent: undefined,
          hashedLink: undefined,
          workflows: undefined,
          scheduleId: undefined,
        },
        where: {
          userId_parentId: {
            userId: 4,
            parentId: 1,
          },
        },
      });
      expect(prismaMock.workflowsOnEventTypes.upsert).toHaveBeenCalledWith({
        create: {
          eventTypeId: 2,
          workflowId: 11,
        },
        update: {},
        where: {
          workflowId_eventTypeId: {
            eventTypeId: 2,
            workflowId: 11,
          },
        },
      });
    });
  });
});
// my-test.ts
import { test as base } from "vitest";

import { getTestEmails } from "@calcom/lib/testEmails";

export interface Fixtures {
  emails: ReturnType<typeof getEmailsFixture>;
}

export const test = base.extend<Fixtures>({
  emails: async ({}, use) => {
    await use(getEmailsFixture());
  },
});

function getEmailsFixture() {
  return {
    get: getTestEmails,
  };
}
import type { Request, Response } from "express";
import type { NextApiRequest, NextApiResponse } from "next";
import { describe } from "vitest";

import { SchedulingType } from "@calcom/prisma/enums";
import { BookingStatus } from "@calcom/prisma/enums";
import type { TRequestRescheduleInputSchema } from "@calcom/trpc/server/routers/viewer/bookings/requestReschedule.schema";
import type { TrpcSessionUser } from "@calcom/trpc/server/trpc";
import { test } from "@calcom/web/test/fixtures/fixtures";
import {
  createBookingScenario,
  getGoogleCalendarCredential,
  TestData,
  getOrganizer,
  getBooker,
  getScenarioData,
  getMockBookingAttendee,
  getDate,
} from "@calcom/web/test/utils/bookingScenario/bookingScenario";
import { expectBookingRequestRescheduledEmails } from "@calcom/web/test/utils/bookingScenario/expects";

import { getSampleUserInSession } from "../utils/bookingScenario/getSampleUserInSession";
import { setupAndTeardown } from "../utils/bookingScenario/setupAndTeardown";

export type CustomNextApiRequest = NextApiRequest & Request;

export type CustomNextApiResponse = NextApiResponse & Response;

describe("Handler: requestReschedule", () => {
  setupAndTeardown();

  describe("User Event Booking", () => {
    test(`should be able to request-reschedule for a user booking
          1. RequestReschedule emails go to both attendee and the person requesting the reschedule`, async ({
      emails,
    }) => {
      const { requestRescheduleHandler } = await import(
        "@calcom/trpc/server/routers/viewer/bookings/requestReschedule.handler"
      );
      const booker = getBooker({
        email: "booker@example.com",
        name: "Booker",
      });

      const organizer = getOrganizer({
        name: "Organizer",
        email: "organizer@example.com",
        id: 101,
        schedules: [TestData.schedules.IstWorkHours],
        credentials: [getGoogleCalendarCredential()],
        selectedCalendars: [TestData.selectedCalendars.google],
      });
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const bookingUid = "MOCKED_BOOKING_UID";
      const eventTypeSlug = "event-type-1";
      await createBookingScenario(
        getScenarioData({
          webhooks: [
            {
              userId: organizer.id,
              eventTriggers: ["BOOKING_CREATED"],
              subscriberUrl: "http://my-webhook.example.com",
              active: true,
              eventTypeId: 1,
              appId: null,
            },
          ],
          eventTypes: [
            {
              id: 1,
              slug: eventTypeSlug,
              slotInterval: 45,
              length: 45,
              users: [
                {
                  id: 101,
                },
              ],
            },
          ],
          bookings: [
            {
              uid: bookingUid,
              eventTypeId: 1,
              userId: 101,
              status: BookingStatus.ACCEPTED,
              startTime: `${plus1DateString}T05:00:00.000Z`,
              endTime: `${plus1DateString}T05:15:00.000Z`,
              attendees: [
                getMockBookingAttendee({
                  id: 2,
                  name: booker.name,
                  email: booker.email,
                  // Booker's locale when the fresh booking happened earlier
                  locale: "hi",
                  // Booker's timezone when the fresh booking happened earlier
                  timeZone: "Asia/Kolkata",
                }),
              ],
            },
          ],
          organizer,
          apps: [TestData.apps["google-calendar"], TestData.apps["daily-video"]],
        })
      );

      const loggedInUser = {
        organizationId: null,
        id: 101,
        username: "reschedule-requester",
        name: "Reschedule Requester",
        email: "reschedule-requester@example.com",
      };
      await requestRescheduleHandler(
        getTrpcHandlerData({
          user: loggedInUser,
          input: {
            bookingId: bookingUid,
            rescheduleReason: "",
          },
        })
      );

      expectBookingRequestRescheduledEmails({
        booking: {
          uid: bookingUid,
        },
        booker,
        organizer: organizer,
        loggedInUser,
        emails,
        bookNewTimePath: `/${organizer.username}/${eventTypeSlug}`,
      });
    });
  });

  describe("Team Event Booking", () => {
    test(`should be able to request-reschedule for a team event booking
          1. RequestReschedule emails go to both attendee and the person requesting the reschedule`, async ({
      emails,
    }) => {
      const { requestRescheduleHandler } = await import(
        "@calcom/trpc/server/routers/viewer/bookings/requestReschedule.handler"
      );
      const booker = getBooker({
        email: "booker@example.com",
        name: "Booker",
      });

      const organizer = getOrganizer({
        name: "Organizer",
        email: "organizer@example.com",
        id: 101,
        teams: [
          {
            membership: {
              accepted: true,
            },
            team: {
              id: 1,
              name: "Team 1",
              slug: "team-1",
            },
          },
        ],
        schedules: [TestData.schedules.IstWorkHours],
        credentials: [getGoogleCalendarCredential()],
        selectedCalendars: [TestData.selectedCalendars.google],
      });
      const { dateString: plus1DateString } = getDate({ dateIncrement: 1 });
      const bookingUid = "MOCKED_BOOKING_UID";
      const eventTypeSlug = "event-type-1";
      await createBookingScenario(
        getScenarioData({
          webhooks: [
            {
              userId: organizer.id,
              eventTriggers: ["BOOKING_CREATED"],
              subscriberUrl: "http://my-webhook.example.com",
              active: true,
              eventTypeId: 1,
              appId: null,
            },
          ],
          eventTypes: [
            {
              id: 1,
              slug: eventTypeSlug,
              slotInterval: 45,
              teamId: 1,
              schedulingType: SchedulingType.COLLECTIVE,
              length: 45,
              users: [
                {
                  id: 101,
                },
              ],
            },
          ],
          bookings: [
            {
              uid: bookingUid,
              eventTypeId: 1,
              userId: 101,
              status: BookingStatus.ACCEPTED,
              startTime: `${plus1DateString}T05:00:00.000Z`,
              endTime: `${plus1DateString}T05:15:00.000Z`,
              attendees: [
                getMockBookingAttendee({
                  id: 2,
                  name: booker.name,
                  email: booker.email,
                  // Booker's locale when the fresh booking happened earlier
                  locale: "hi",
                  // Booker's timezone when the fresh booking happened earlier
                  timeZone: "Asia/Kolkata",
                }),
              ],
            },
          ],
          organizer,
          apps: [TestData.apps["google-calendar"], TestData.apps["daily-video"]],
        })
      );

      const loggedInUser = {
        organizationId: null,
        id: 101,
        username: "reschedule-requester",
        name: "Reschedule Requester",
        email: "reschedule-requester@example.com",
      };
      await requestRescheduleHandler(
        getTrpcHandlerData({
          user: loggedInUser,
          input: {
            bookingId: bookingUid,
            rescheduleReason: "",
          },
        })
      );

      expectBookingRequestRescheduledEmails({
        booking: {
          uid: bookingUid,
        },
        booker,
        organizer: organizer,
        loggedInUser,
        emails,
        bookNewTimePath: "/team/team-1/event-type-1",
      });
    });
    test.todo("Verify that the email should go to organizer as well as the team members");
  });
});

function getTrpcHandlerData({
  input,
  user,
}: {
  input: TRequestRescheduleInputSchema;
  user: Partial<Omit<NonNullable<TrpcSessionUser>, "id" | "email" | "username">> &
    Pick<NonNullable<TrpcSessionUser>, "id" | "email" | "username">;
}) {
  return {
    ctx: {
      user: {
        ...getSampleUserInSession(),
        ...user,
        avatarUrl: user.avatarUrl || null,
      } satisfies TrpcSessionUser,
    },
    input: input,
  };
}
import { getBucket } from "abTest/utils";
import type { NextMiddleware, NextRequest } from "next/server";
import { NextResponse, URLPattern } from "next/server";
import z from "zod";

import { FUTURE_ROUTES_ENABLED_COOKIE_NAME, FUTURE_ROUTES_OVERRIDE_COOKIE_NAME } from "@calcom/lib/constants";

const ROUTES: [URLPattern, boolean][] = [
  ["/event-types", process.env.APP_ROUTER_EVENT_TYPES_ENABLED === "1"] as const,
  ["/settings/admin/:path*", process.env.APP_ROUTER_SETTINGS_ADMIN_ENABLED === "1"] as const,
  ["/apps/installed/:category", process.env.APP_ROUTER_APPS_INSTALLED_CATEGORY_ENABLED === "1"] as const,
  ["/apps/:slug", process.env.APP_ROUTER_APPS_SLUG_ENABLED === "1"] as const,
  ["/apps/:slug/setup", process.env.APP_ROUTER_APPS_SLUG_SETUP_ENABLED === "1"] as const,
  ["/apps/categories", process.env.APP_ROUTER_APPS_CATEGORIES_ENABLED === "1"] as const,
  ["/apps/categories/:category", process.env.APP_ROUTER_APPS_CATEGORIES_CATEGORY_ENABLED === "1"] as const,
  ["/workflows/:path*", process.env.APP_ROUTER_WORKFLOWS_ENABLED === "1"] as const,
  ["/settings/teams/:path*", process.env.APP_ROUTER_SETTINGS_TEAMS_ENABLED === "1"] as const,
  ["/getting-started/:step", process.env.APP_ROUTER_GETTING_STARTED_STEP_ENABLED === "1"] as const,
  ["/apps", process.env.APP_ROUTER_APPS_ENABLED === "1"] as const,
  ["/bookings/:status", process.env.APP_ROUTER_BOOKINGS_STATUS_ENABLED === "1"] as const,
  ["/video/:path*", process.env.APP_ROUTER_VIDEO_ENABLED === "1"] as const,
  ["/teams", process.env.APP_ROUTER_TEAMS_ENABLED === "1"] as const,
].map(([pathname, enabled]) => [
  new URLPattern({
    pathname,
  }),
  enabled,
]);

const bucketSchema = z.union([z.literal("legacy"), z.literal("future")]);

export const abTestMiddlewareFactory =
  (next: (req: NextRequest) => Promise<NextResponse<unknown>>): NextMiddleware =>
  async (req: NextRequest) => {
    const response = await next(req);

    const { pathname } = req.nextUrl;

    const override = req.cookies.has(FUTURE_ROUTES_OVERRIDE_COOKIE_NAME);

    const route = ROUTES.find(([regExp]) => regExp.test(req.url)) ?? null;

    const enabled = route !== null ? route[1] || override : false;

    if (pathname.includes("future") || !enabled) {
      return response;
    }

    const safeParsedBucket = override
      ? { success: true as const, data: "future" as const }
      : bucketSchema.safeParse(req.cookies.get(FUTURE_ROUTES_ENABLED_COOKIE_NAME)?.value);

    if (!safeParsedBucket.success) {
      // cookie does not exist or it has incorrect value
      const bucket = getBucket();

      response.cookies.set(FUTURE_ROUTES_ENABLED_COOKIE_NAME, bucket, {
        expires: Date.now() + 1000 * 60 * 30,
        httpOnly: true,
      }); // 30 min in ms

      if (bucket === "legacy") {
        return response;
      }

      const url = req.nextUrl.clone();
      url.pathname = `future${pathname}/`;

      return NextResponse.rewrite(url, response);
    }

    if (safeParsedBucket.data === "legacy") {
      return response;
    }

    const url = req.nextUrl.clone();
    url.pathname = `future${pathname}/`;

    return NextResponse.rewrite(url, response);
  };
import { AB_TEST_BUCKET_PROBABILITY } from "@calcom/lib/constants";

const cryptoRandom = () => {
  return crypto.getRandomValues(new Uint8Array(1))[0] / 0xff;
};

export const getBucket = () => {
  return cryptoRandom() * 100 < AB_TEST_BUCKET_PROBABILITY ? "future" : "legacy";
};
import type { GetStaticPropsContext } from "next";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import superjson from "superjson";

import { CALCOM_VERSION } from "@calcom/lib/constants";
import prisma, { readonlyPrisma } from "@calcom/prisma";
import { createServerSideHelpers } from "@calcom/trpc/react/server";
import { appRouter } from "@calcom/trpc/server/routers/_app";

// eslint-disable-next-line @typescript-eslint/no-var-requires
const { i18n } = require("@calcom/config/next-i18next.config");

/**
 * Initialize static site rendering tRPC helpers.
 * Provides a method to prefetch tRPC-queries in a `getStaticProps`-function.
 * Automatically prefetches i18n based on the passed in `context`-object to prevent i18n-flickering.
 * Make sure to `return { props: { trpcState: ssr.dehydrate() } }` at the end.
 */
export async function ssgInit<TParams extends { locale?: string }>(opts: GetStaticPropsContext<TParams>) {
  const requestedLocale = opts.params?.locale || opts.locale || i18n.defaultLocale;
  const isSupportedLocale = i18n.locales.includes(requestedLocale);
  if (!isSupportedLocale) {
    console.warn(`Requested unsupported locale "${requestedLocale}"`);
  }
  const locale = isSupportedLocale ? requestedLocale : i18n.defaultLocale;

  const _i18n = await serverSideTranslations(locale, ["common"]);

  const ssg = createServerSideHelpers({
    router: appRouter,
    transformer: superjson,
    ctx: {
      prisma,
      insightsDb: readonlyPrisma,
      session: null,
      locale,
      i18n: _i18n,
    },
  });

  // i18n translations are already retrieved from serverSideTranslations call, there is no need to run a i18n.fetch
  // we can set query data directly to the queryClient
  const queryKey = [
    ["viewer", "public", "i18n"],
    { input: { locale, CalComVersion: CALCOM_VERSION }, type: "query" },
  ];

  ssg.queryClient.setQueryData(queryKey, { i18n: _i18n });

  return ssg;
}
import type { GetStaticPropsContext } from "next";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";

// eslint-disable-next-line @typescript-eslint/no-var-requires
const { i18n } = require("@calcom/config/next-i18next.config");

export async function getTranslations<TParams extends { locale?: string }>(
  opts: GetStaticPropsContext<TParams>
) {
  const requestedLocale = opts.params?.locale || opts.locale || i18n.defaultLocale;
  const isSupportedLocale = i18n.locales.includes(requestedLocale);
  if (!isSupportedLocale) {
    console.warn(`Requested unsupported locale "${requestedLocale}"`);
  }
  const locale = isSupportedLocale ? requestedLocale : i18n.defaultLocale;

  const _i18n = await serverSideTranslations(locale, ["common"]);

  return {
    i18n: _i18n,
  };
}
export const GOOGLE_API_CREDENTIALS = process.env.GOOGLE_API_CREDENTIALS || "{}";

export const { client_id: GOOGLE_CLIENT_ID, client_secret: GOOGLE_CLIENT_SECRET } =
  JSON.parse(GOOGLE_API_CREDENTIALS)?.web || {};

export const GOOGLE_LOGIN_ENABLED = process.env.GOOGLE_LOGIN_ENABLED === "true";

export const IS_GOOGLE_LOGIN_ENABLED = !!(GOOGLE_CLIENT_ID && GOOGLE_CLIENT_SECRET && GOOGLE_LOGIN_ENABLED);

export const IS_SAML_LOGIN_ENABLED = !!(process.env.SAML_DATABASE_URL && process.env.SAML_ADMINS);
import type { GetServerSidePropsContext } from "next";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import superjson from "superjson";

import { forms } from "@calcom/app-store/routing-forms/trpc/procedures/forms";
import { getLocale } from "@calcom/features/auth/lib/getLocale";
import { map } from "@calcom/features/flags/server/procedures/map";
import { CALCOM_VERSION } from "@calcom/lib/constants";
import { createServerSideHelpers } from "@calcom/trpc/react/server";
import { createContext } from "@calcom/trpc/server/createContext";
import { me } from "@calcom/trpc/server/routers/loggedInViewer/procedures/me";
import { teamsAndUserProfilesQuery } from "@calcom/trpc/server/routers/loggedInViewer/procedures/teamsAndUserProfilesQuery";
import { event } from "@calcom/trpc/server/routers/publicViewer/procedures/event";
import { session } from "@calcom/trpc/server/routers/publicViewer/procedures/session";
import { get } from "@calcom/trpc/server/routers/viewer/eventTypes/procedures/get";
import { hasTeamPlan } from "@calcom/trpc/server/routers/viewer/teams/procedures/hasTeamPlan";
import { router, mergeRouters } from "@calcom/trpc/server/trpc";

const loggedInRouter = router({
  me,
});

// Temporary workaround for OOM issue, import only procedures that are called on the server side
const routerSlice = router({
  viewer: mergeRouters(
    loggedInRouter,
    router({
      features: router({
        map,
      }),
      public: router({
        session,
        event,
      }),
      teams: router({
        hasTeamPlan,
      }),
      appRoutingForms: router({
        forms,
      }),
      teamsAndUserProfilesQuery: router({
        teamsAndUserProfilesQuery,
      }),
      eventTypes: router({
        get,
      }),
    })
  ),
});

/**
 * Initialize server-side rendering tRPC helpers.
 * Provides a method to prefetch tRPC-queries in a `getServerSideProps`-function.
 * Automatically prefetches i18n based on the passed in `context`-object to prevent i18n-flickering.
 * Make sure to `return { props: { trpcState: ssr.dehydrate() } }` at the end.
 */
export async function ssrInit(context: GetServerSidePropsContext, options?: { noI18nPreload: boolean }) {
  const ctx = await createContext(context);
  const locale = await getLocale(context.req);
  const i18n = await serverSideTranslations(locale, ["common", "vital"]);

  const ssr = createServerSideHelpers({
    router: routerSlice,
    transformer: superjson,
    ctx: { ...ctx, locale, i18n },
  });

  // i18n translations are already retrieved from serverSideTranslations call, there is no need to run a i18n.fetch
  // we can set query data directly to the queryClient
  const queryKey = [
    ["viewer", "public", "i18n"],
    { input: { locale, CalComVersion: CALCOM_VERSION }, type: "query" },
  ];
  if (!options?.noI18nPreload) {
    ssr.queryClient.setQueryData(queryKey, { i18n });
  }

  await Promise.allSettled([
    // So feature flags are available on first render
    ssr.viewer.features.map.prefetch(),
    // Provides a better UX to the users who have already upgraded.
    ssr.viewer.teams.hasTeamPlan.prefetch(),
    ssr.viewer.public.session.prefetch(),
  ]);

  return ssr;
}
import { expect } from "@playwright/test";
import path from "path";
import { uuid } from "short-uuid";

import { test } from "../lib/fixtures";
import { generateTotpCode } from "../lib/testUtils";
import { expectInvitationEmailToBeReceived } from "./expects";

test.afterAll(({ users, orgs }) => {
  users.deleteAll();
  orgs.deleteAll();
});

function capitalize(text: string) {
  if (!text) {
    return text;
  }
  return text.charAt(0).toUpperCase() + text.slice(1);
}

test.describe("Organization", () => {
  test("Admin should be able to create an organization and complete onboarding", async ({
    page,
    users,
    emails,
  }) => {
    const orgOwner = await users.create({
      role: "ADMIN",
    });

    const instanceAdmin = await users.create({
      username: `admin-${uuid()}`,
      email: users.trackEmail({ username: "admin", domain: "example.com" }),
      role: "ADMIN",
    });

    const orgDomain = `${orgOwner.username}-org`;

    const orgName = capitalize(`${orgOwner.username}-org`);
    await orgOwner.apiLogin();
    await page.goto("/settings/organizations/new");
    await page.waitForLoadState("networkidle");

    await test.step("Basic info", async () => {
      // Check required fields
      await page.locator("button[type=submit]").click();
      await expect(page.locator(".text-red-700")).toHaveCount(3);

      // Happy path
      const adminEmail = users.trackEmail({ username: "john", domain: `${orgDomain}.com` });
      await page.locator("input[name=adminEmail]").fill(adminEmail);
      expect(await page.locator("input[name=name]").inputValue()).toEqual(orgName);
      expect(await page.locator("input[name=slug]").inputValue()).toEqual(orgDomain);
      await page.locator("button[type=submit]").click();
      await page.waitForLoadState("networkidle");

      // Check admin email about code verification
      await expectInvitationEmailToBeReceived(
        page,
        emails,
        adminEmail,
        "Verify your email to create an organization"
      );

      await test.step("Verification", async () => {
        // Code verification
        await expect(page.locator("#modal-title")).toBeVisible();
        await page.locator("input[name='2fa1']").fill(generateTotpCode(`john@${orgDomain}.com`));
        // Check admin email about DNS pending action
        await expectInvitationEmailToBeReceived(
          page,
          emails,
          instanceAdmin.email,
          "New organization created: pending action"
        );

        // Waiting to be in next step URL
        await page.waitForURL("/settings/organizations/*/set-password");
      });
    });

    await test.step("Admin password", async () => {
      // Check required fields
      await page.locator("button[type=submit]").click();
      await expect(page.locator(".text-red-700")).toHaveCount(3); // 3 password hints

      // Happy path
      await page.locator("input[name='password']").fill("ADMIN_user2023$");
      await page.locator("button[type=submit]").click();

      // Waiting to be in next step URL
      await page.waitForURL("/settings/organizations/*/about");
    });

    await test.step("About the organization", async () => {
      // Choosing an avatar
      await page.locator('button:text("Upload")').click();
      const fileChooserPromise = page.waitForEvent("filechooser");
      await page.getByText("Choose a file...").click();
      const fileChooser = await fileChooserPromise;
      await fileChooser.setFiles(path.join(__dirname, "../../public/apple-touch-icon.png"));
      await page.locator('button:text("Save")').click();

      // About text
      await page.locator('textarea[name="about"]').fill("This is a testing org");
      await page.locator("button[type=submit]").click();

      // Waiting to be in next step URL
      await page.waitForURL("/settings/organizations/*/onboard-members");
    });

    await test.step("On-board administrators", async () => {
      await page.waitForSelector('[data-testid="pending-member-list"]');
      expect(await page.getByTestId("pending-member-item").count()).toBe(1);

      const adminEmail = users.trackEmail({ username: "rick", domain: `${orgDomain}.com` });

      //can add members
      await page.getByTestId("new-member-button").click();
      await page.locator('[placeholder="email\\@example\\.com"]').fill(adminEmail);
      await page.getByTestId("invite-new-member-button").click();
      await expect(page.locator(`li:has-text("${adminEmail}")`)).toBeVisible();
      // Check if invited admin received the invitation email
      await expectInvitationEmailToBeReceived(
        page,
        emails,
        adminEmail,
        `${orgName}'s admin invited you to join the organization ${orgName} on Cal.com`
      );
      await expect(page.getByTestId("pending-member-item")).toHaveCount(2);

      // can remove members
      await expect(page.getByTestId("pending-member-item")).toHaveCount(2);
      const lastRemoveMemberButton = page.getByTestId("remove-member-button").last();
      await lastRemoveMemberButton.click();
      await page.waitForLoadState("networkidle");
      await expect(page.getByTestId("pending-member-item")).toHaveCount(1);
      await page.getByTestId("publish-button").click();
      // Waiting to be in next step URL
      await page.waitForURL("/settings/organizations/*/add-teams");
    });

    await test.step("Create teams", async () => {
      // Initial state
      await expect(page.locator('input[name="teams.0.name"]')).toHaveCount(1);
      await expect(page.locator('button:text("Continue")')).toBeDisabled();

      // Filling one team
      await page.locator('input[name="teams.0.name"]').fill("Marketing");
      await expect(page.locator('button:text("Continue")')).toBeEnabled();

      // Adding another team
      await page.locator('button:text("Add a team")').click();
      await expect(page.locator('button:text("Continue")')).toBeDisabled();
      await expect(page.locator('input[name="teams.1.name"]')).toHaveCount(1);
      await page.locator('input[name="teams.1.name"]').fill("Sales");
      await expect(page.locator('button:text("Continue")')).toBeEnabled();

      // Finishing the creation wizard
      await page.locator('button:text("Continue")').click();
      await page.waitForURL("/event-types");
    });
  });
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";
import { JSDOM } from "jsdom";
// eslint-disable-next-line no-restricted-imports
import type { Messages } from "mailhog";
import type { createEmailsFixture } from "playwright/fixtures/emails";

import { getEmailsReceivedByUser } from "../lib/testUtils";

export async function expectInvitationEmailToBeReceived(
  page: Page,
  emails: ReturnType<typeof createEmailsFixture>,
  userEmail: string,
  subject: string,
  returnLink?: string
) {
  if (!emails) return null;
  // We need to wait for the email to go through, otherwise it will fail
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(2000);
  const receivedEmails = await getEmailsReceivedByUser({ emails, userEmail });
  expect(receivedEmails?.total).toBe(1);
  const [firstReceivedEmail] = (receivedEmails as Messages).items;
  expect(firstReceivedEmail.subject).toBe(subject);
  if (!returnLink) return;
  const dom = new JSDOM(firstReceivedEmail.html);
  const anchor = dom.window.document.querySelector(`a[href*="${returnLink}"]`);
  return anchor?.getAttribute("href");
}
import type { Browser, Page } from "@playwright/test";
import { expect } from "@playwright/test";

import prisma from "@calcom/prisma";

import { test } from "../lib/fixtures";
import { getInviteLink } from "../lib/testUtils";
import { expectInvitationEmailToBeReceived } from "./expects";

test.describe.configure({ mode: "parallel" });

test.afterEach(async ({ users, orgs }) => {
  await users.deleteAll();
  await orgs.deleteAll();
});

test.describe("Organization", () => {
  test.describe("Email not matching orgAutoAcceptEmail", () => {
    test("Org Invitation", async ({ browser, page, users, emails }) => {
      const orgOwner = await users.create(undefined, { hasTeam: true, isOrg: true });
      const { team: org } = await orgOwner.getOrgMembership();
      await orgOwner.apiLogin();
      await page.goto("/settings/organizations/members");
      await page.waitForLoadState("networkidle");

      await test.step("By email", async () => {
        const invitedUserEmail = users.trackEmail({ username: "rick", domain: "domain.com" });
        // '-domain' because the email doesn't match orgAutoAcceptEmail
        const usernameDerivedFromEmail = `${invitedUserEmail.split("@")[0]}-domain`;

        await inviteAnEmail(page, invitedUserEmail);

        const inviteLink = await expectInvitationEmailToBeReceived(
          page,
          emails,
          invitedUserEmail,
          `${org.name}'s admin invited you to join the organization ${org.name} on Cal.com`,
          "signup?token"
        );

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: false,
          email: invitedUserEmail,
        });

        assertInviteLink(inviteLink);
        await signupFromEmailInviteLink({
          browser,
          inviteLink,
          expectedEmail: invitedUserEmail,
          expectedUsername: usernameDerivedFromEmail,
        });

        const dbUser = await prisma.user.findUnique({ where: { email: invitedUserEmail } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });
      });

      await test.step("By invite link", async () => {
        const inviteLink = await copyInviteLink(page);

        const email = users.trackEmail({ username: "rick", domain: "domain.com" });
        // '-domain' because the email doesn't match orgAutoAcceptEmail
        const usernameDerivedFromEmail = `${email.split("@")[0]}-domain`;
        await signupFromInviteLink({ browser, inviteLink, email });

        const dbUser = await prisma.user.findUnique({ where: { email } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);
        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email,
        });
      });
    });

    test("Team invitation", async ({ browser, page, users, emails }) => {
      const orgOwner = await users.create(undefined, { hasTeam: true, isOrg: true, hasSubteam: true });
      await orgOwner.apiLogin();
      const { team } = await orgOwner.getFirstTeamMembership();
      const { team: org } = await orgOwner.getOrgMembership();

      await test.step("By email", async () => {
        await page.goto(`/settings/teams/${team.id}/members`);
        await page.waitForLoadState("networkidle");

        const invitedUserEmail = users.trackEmail({ username: "rick", domain: "domain.com" });
        // '-domain' because the email doesn't match orgAutoAcceptEmail
        const usernameDerivedFromEmail = `${invitedUserEmail.split("@")[0]}-domain`;
        await inviteAnEmail(page, invitedUserEmail);
        await expectUserToBeAMemberOfTeam({
          page,
          teamId: team.id,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: false,
          email: invitedUserEmail,
        });

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: false,
          email: invitedUserEmail,
        });

        await page.waitForLoadState("networkidle");

        const inviteLink = await expectInvitationEmailToBeReceived(
          page,
          emails,
          invitedUserEmail,
          `${team.name}'s admin invited you to join the team ${team.name} of organization ${org.name} on Cal.com`,
          "signup?token"
        );

        assertInviteLink(inviteLink);

        await signupFromEmailInviteLink({
          browser,
          inviteLink,
          expectedEmail: invitedUserEmail,
          expectedUsername: usernameDerivedFromEmail,
        });

        const dbUser = await prisma.user.findUnique({ where: { email: invitedUserEmail } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);

        await expectUserToBeAMemberOfTeam({
          page,
          teamId: team.id,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });
      });

      await test.step("By invite link", async () => {
        await page.goto(`/settings/teams/${team.id}/members`);

        const inviteLink = await copyInviteLink(page);

        const email = users.trackEmail({ username: "rick", domain: "domain.com" });
        // '-domain' because the email doesn't match orgAutoAcceptEmail
        const usernameDerivedFromEmail = `${email.split("@")[0]}-domain`;
        await signupFromInviteLink({ browser, inviteLink, email });

        const dbUser = await prisma.user.findUnique({ where: { email } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);
        await expectUserToBeAMemberOfTeam({
          teamId: team.id,
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: email,
        });

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: email,
        });
      });
    });
  });

  test.describe("Email matching orgAutoAcceptEmail and a Verified Organization", () => {
    test("Org Invitation", async ({ browser, page, users, emails }) => {
      const orgOwner = await users.create(undefined, { hasTeam: true, isOrg: true, isOrgVerified: true });
      const { team: org } = await orgOwner.getOrgMembership();
      await orgOwner.apiLogin();
      await page.goto("/settings/organizations/members");
      await page.waitForLoadState("networkidle");

      await test.step("By email", async () => {
        const invitedUserEmail = users.trackEmail({ username: "rick", domain: "example.com" });

        const usernameDerivedFromEmail = invitedUserEmail.split("@")[0];
        await inviteAnEmail(page, invitedUserEmail);

        const inviteLink = await expectInvitationEmailToBeReceived(
          page,
          emails,
          invitedUserEmail,
          `${org.name}'s admin invited you to join the organization ${org.name} on Cal.com`,
          "signup?token"
        );

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });

        assertInviteLink(inviteLink);
        await signupFromEmailInviteLink({
          browser,
          inviteLink,
          expectedEmail: invitedUserEmail,
          expectedUsername: usernameDerivedFromEmail,
        });

        const dbUser = await prisma.user.findUnique({ where: { email: invitedUserEmail } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });
      });

      await test.step("By invite link", async () => {
        const inviteLink = await copyInviteLink(page);

        const email = users.trackEmail({ username: "rick", domain: "example.com" });

        const usernameDerivedFromEmail = email.split("@")[0];
        await signupFromInviteLink({ browser, inviteLink, email });

        const dbUser = await prisma.user.findUnique({ where: { email } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);
        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email,
        });
      });
    });

    test("Team Invitation", async ({ browser, page, users, emails }) => {
      const orgOwner = await users.create(undefined, {
        hasTeam: true,
        isOrg: true,
        hasSubteam: true,
        isOrgVerified: true,
      });
      const { team: org } = await orgOwner.getOrgMembership();
      const { team } = await orgOwner.getFirstTeamMembership();

      await orgOwner.apiLogin();

      await test.step("By email", async () => {
        await page.goto(`/settings/teams/${team.id}/members`);
        await page.waitForLoadState("networkidle");

        const invitedUserEmail = users.trackEmail({ username: "rick", domain: "example.com" });

        const usernameDerivedFromEmail = invitedUserEmail.split("@")[0];
        await inviteAnEmail(page, invitedUserEmail);
        await expectUserToBeAMemberOfTeam({
          page,
          teamId: team.id,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });

        const inviteLink = await expectInvitationEmailToBeReceived(
          page,
          emails,
          invitedUserEmail,
          `${team.name}'s admin invited you to join the organization ${org.name} on Cal.com`,
          "signup?token"
        );

        assertInviteLink(inviteLink);

        await signupFromEmailInviteLink({
          browser,
          inviteLink,
          expectedEmail: invitedUserEmail,
          expectedUsername: usernameDerivedFromEmail,
        });

        const dbUser = await prisma.user.findUnique({ where: { email: invitedUserEmail } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);

        await expectUserToBeAMemberOfTeam({
          page,
          teamId: team.id,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });

        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: invitedUserEmail,
        });
      });

      await test.step("By invite link", async () => {
        await page.goto(`/settings/teams/${team.id}/members`);

        const inviteLink = await copyInviteLink(page);

        const email = users.trackEmail({ username: "rick", domain: "example.com" });
        // '-domain' because the email doesn't match orgAutoAcceptEmail
        const usernameDerivedFromEmail = `${email.split("@")[0]}`;

        await signupFromInviteLink({ browser, inviteLink, email });

        const dbUser = await prisma.user.findUnique({ where: { email } });
        expect(dbUser?.username).toBe(usernameDerivedFromEmail);
        await expectUserToBeAMemberOfTeam({
          teamId: team.id,
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: email,
        });
        await expectUserToBeAMemberOfOrganization({
          page,
          username: usernameDerivedFromEmail,
          role: "member",
          isMemberShipAccepted: true,
          email: email,
        });
      });
    });
  });
});

async function signupFromInviteLink({
  browser,
  inviteLink,
  email,
}: {
  browser: Browser;
  inviteLink: string;
  email: string;
}) {
  const context = await browser.newContext();
  const inviteLinkPage = await context.newPage();
  await inviteLinkPage.goto(inviteLink);
  await inviteLinkPage.waitForLoadState("networkidle");

  // Check required fields
  const button = inviteLinkPage.locator("button[type=submit][disabled]");
  await expect(button).toBeVisible(); // email + 3 password hints

  await inviteLinkPage.locator("input[name=email]").fill(email);
  await inviteLinkPage.locator("input[name=password]").fill(`P4ssw0rd!`);
  await inviteLinkPage.locator("button[type=submit]").click();
  await inviteLinkPage.waitForURL("/getting-started");
  return { email };
}

async function signupFromEmailInviteLink({
  browser,
  inviteLink,
  expectedUsername,
  expectedEmail,
}: {
  browser: Browser;
  inviteLink: string;
  expectedUsername: string;
  expectedEmail: string;
}) {
  // Follow invite link in new window
  const context = await browser.newContext();
  const signupPage = await context.newPage();

  signupPage.goto(inviteLink);
  await signupPage.locator(`[data-testid="signup-usernamefield"]`).waitFor({ state: "visible" });
  await expect(signupPage.locator(`[data-testid="signup-usernamefield"]`)).toBeDisabled();
  // await for value. initial value is ""
  await expect(signupPage.locator(`[data-testid="signup-usernamefield"]`)).toHaveValue(expectedUsername);

  await expect(signupPage.locator(`[data-testid="signup-emailfield"]`)).toBeDisabled();
  await expect(signupPage.locator(`[data-testid="signup-emailfield"]`)).toHaveValue(expectedEmail);

  await signupPage.waitForLoadState("networkidle");
  // Check required fields
  await signupPage.locator("input[name=password]").fill(`P4ssw0rd!`);
  await signupPage.locator("button[type=submit]").click();
  await signupPage.waitForURL("/getting-started?from=signup");
  await context.close();
  await signupPage.close();
}

async function inviteAnEmail(page: Page, invitedUserEmail: string) {
  await page.locator('button:text("Add")').click();
  await page.locator('input[name="inviteUser"]').fill(invitedUserEmail);
  await page.locator('button:text("Send invite")').click();
  await page.waitForLoadState("networkidle");
}

async function expectUserToBeAMemberOfOrganization({
  page,
  username,
  email,
  role,
  isMemberShipAccepted,
}: {
  page: Page;
  username: string;
  role: string;
  isMemberShipAccepted: boolean;
  email: string;
}) {
  // Check newly invited member is not pending anymore
  await page.goto("/settings/organizations/members");
  expect(await page.locator(`[data-testid="member-${username}-username"]`).textContent()).toBe(username);
  expect(await page.locator(`[data-testid="member-${username}-email"]`).textContent()).toBe(email);
  expect((await page.locator(`[data-testid="member-${username}-role"]`).textContent())?.toLowerCase()).toBe(
    role.toLowerCase()
  );
  if (isMemberShipAccepted) {
    await expect(page.locator(`[data-testid2="member-${username}-pending"]`)).toBeHidden();
  } else {
    await expect(page.locator(`[data-testid2="member-${username}-pending"]`)).toBeVisible();
  }
}

async function expectUserToBeAMemberOfTeam({
  page,
  teamId,
  email,
  role,
  username,
  isMemberShipAccepted,
}: {
  page: Page;
  username: string;
  role: string;
  teamId: number;
  isMemberShipAccepted: boolean;
  email: string;
}) {
  // Check newly invited member is not pending anymore
  await page.goto(`/settings/teams/${teamId}/members`);
  await page.reload();
  expect(
    (
      await page.locator(`[data-testid="member-${username}"] [data-testid=member-role]`).textContent()
    )?.toLowerCase()
  ).toBe(role.toLowerCase());
  if (isMemberShipAccepted) {
    await expect(page.locator(`[data-testid="email-${email.replace("@", "")}-pending"]`)).toBeHidden();
  } else {
    await expect(page.locator(`[data-testid="email-${email.replace("@", "")}-pending"]`)).toBeVisible();
  }
}

function assertInviteLink(inviteLink: string | null | undefined): asserts inviteLink is string {
  if (!inviteLink) throw new Error("Invite link not found");
}

async function copyInviteLink(page: Page) {
  await page.locator('button:text("Add")').click();
  await page.locator(`[data-testid="copy-invite-link-button"]`).click();
  const inviteLink = await getInviteLink(page);
  return inviteLink;
}
import { expect } from "@playwright/test";

import { WEBAPP_URL } from "@calcom/lib/constants";
import prisma from "@calcom/prisma";

import { test } from "../../lib/fixtures";

test.afterAll(({ users }) => {
  users.deleteAll();
});

test.describe("user1NotMemberOfOrg1 is part of team1MemberOfOrg1", () => {
  test("Team1 profile should show correct domain if logged in as User1", async ({ page, users, orgs }) => {
    const org = await orgs.create({
      name: "TestOrg",
    });

    const user1NotMemberOfOrg1 = await users.create(undefined, {
      hasTeam: true,
    });

    const { team: team1MemberOfOrg1 } = await user1NotMemberOfOrg1.getFirstTeamMembership();
    await moveTeamToOrg({ team: team1MemberOfOrg1, org });

    await user1NotMemberOfOrg1.apiLogin();

    await page.goto(`/settings/teams/${team1MemberOfOrg1.id}/profile`);

    const domain = await page.locator(".testid-leading-text-team-url").textContent();
    expect(domain).toContain(org.slug);
  });

  test("EventTypes listing should show correct link for user events and team1MemberOfOrg1's events", async ({
    page,
    users,
    orgs,
  }) => {
    const org = await orgs.create({
      name: "TestOrg",
    });

    const user1NotMemberOfOrg1 = await users.create(undefined, {
      hasTeam: true,
    });

    const { team: team1MemberOfOrg1 } = await user1NotMemberOfOrg1.getFirstTeamMembership();
    await moveTeamToOrg({ team: team1MemberOfOrg1, org });

    await user1NotMemberOfOrg1.apiLogin();
    await page.goto("/event-types");
    await page.waitForLoadState("networkidle");

    const userEventLinksLocators = await page
      .locator(`[data-testid=slug-${user1NotMemberOfOrg1.username}] [data-testid="preview-link-button"]`)
      .all();

    expect(userEventLinksLocators.length).toBeGreaterThan(0);

    for (const userEventLinkLocator of userEventLinksLocators) {
      const href = await userEventLinkLocator.getAttribute("href");
      expect(href).toContain(WEBAPP_URL);
    }

    const teamEventLinksLocators = await page
      .locator(`[data-testid=slug-${team1MemberOfOrg1.slug}] [data-testid="preview-link-button"]`)
      .all();

    expect(teamEventLinksLocators.length).toBeGreaterThan(0);

    for (const teamEventLinksLocator of teamEventLinksLocators) {
      const href = await teamEventLinksLocator.getAttribute("href");
      expect(href).not.toContain(WEBAPP_URL);
      expect(href).toContain(org.slug);
    }
  });
});

async function moveTeamToOrg({
  team,
  org,
}: {
  team: {
    id: number;
  };
  org: {
    id: number;
  };
}) {
  await prisma.team.update({
    where: {
      id: team.id,
    },
    data: {
      parent: {
        connect: {
          id: org.id,
        },
      },
    },
  });
}
import { IS_SAML_LOGIN_ENABLED } from "../server/lib/constants";
import { login } from "./fixtures/users";
import { test } from "./lib/fixtures";

test.describe("SAML tests", () => {
  test("test SAML configuration UI with pro@example.com", async ({ page }) => {
    // TODO: Figure out a way to use the users from fixtures here, right now we cannot set
    // the SAML_ADMINS env variables dynamically
    await login({ username: "pro", email: "pro@example.com", password: "pro" }, page);
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(!IS_SAML_LOGIN_ENABLED, "It should only run if SAML is enabled");
    // Try to go Security page
    await page.goto("/settings/security/sso");
    // It should redirect you to the event-types page
    // await page.waitForSelector("[data-testid=saml_config]");
  });
});
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

test.describe("Users can impersonate", async () => {
  test.afterAll(async ({ users }) => {
    await users.deleteAll();
  });
  test("App Admin can impersonate users with impersonation enabled", async ({ page, users }) => {
    // log in trail user
    const user = await users.create({
      role: "ADMIN",
      password: "ADMINadmin2022!",
    });

    const userToImpersonate = await users.create({ disableImpersonation: false });

    await user.apiLogin();
    await page.waitForLoadState();

    await page.goto("/settings/admin/impersonation");
    await page.waitForLoadState();

    const adminInput = page.getByTestId("admin-impersonation-input");
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore the username does exist
    await adminInput.fill(userToImpersonate.username);
    await page.getByTestId("impersonation-submit").click();

    // // Wait for sign in to complete
    await page.waitForURL("/settings/my-account/profile");

    const stopImpersonatingButton = page.getByTestId("stop-impersonating-button");

    const impersonatedUsernameInput = page.locator("input[name='username']");

    const impersonatedUser = await impersonatedUsernameInput.inputValue();

    await expect(stopImpersonatingButton).toBeVisible();
    await expect(impersonatedUser).toBe(userToImpersonate.username);

    await stopImpersonatingButton.click();

    await page.waitForLoadState("networkidle");
    // Return to user
    const ogUser = await impersonatedUsernameInput.inputValue();

    expect(ogUser).toBe(user.username);
  });
});
import { expect } from "@playwright/test";
import path from "path";

import { prisma } from "@calcom/prisma";

import { test } from "../lib/fixtures";

test.describe("UploadAvatar", async () => {
  test("can upload an image", async ({ page, users }) => {
    const user = await users.create({});
    await user.apiLogin();

    await test.step("Can upload an initial picture", async () => {
      await page.goto("/settings/my-account/profile");

      await page.getByTestId("open-upload-avatar-dialog").click();

      const [fileChooser] = await Promise.all([
        // It is important to call waitForEvent before click to set up waiting.
        page.waitForEvent("filechooser"),
        // Opens the file chooser.
        page.getByTestId("open-upload-image-filechooser").click(),
      ]);

      await fileChooser.setFiles(`${path.dirname(__filename)}/../fixtures/cal.png`);

      await page.getByTestId("upload-avatar").click();

      await page.locator("input[name='name']").fill(user.email);

      await page.getByText("Update").click();
      await page.waitForSelector("text=Settings updated successfully");

      const response = await prisma.avatar.findUniqueOrThrow({
        where: {
          teamId_userId: {
            userId: user.id,
            teamId: 0,
          },
        },
      });

      // todo: remove this; ideally the organization-avatar is updated the moment
      //       'Settings updated succesfully' is saved.
      await page.waitForLoadState("networkidle");
      const avatar = page.getByTestId("profile-upload-avatar").locator("img");

      const src = await avatar.getAttribute("src");

      await expect(src).toContain(response.objectKey);

      const urlResponse = await page.request.get(`/api/avatar/${response.objectKey}.png`, {
        maxRedirects: 0,
      });

      await expect(urlResponse?.status()).toBe(200);
    });
  });
});
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";
import { installAppleCalendar } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });

test.afterEach(({ users }) => users.deleteAll());

testBothFutureAndLegacyRoutes.describe("App Store - Authed", (routeVariant) => {
  test("should render /apps page", async ({ page, users, context }) => {
    test.skip(routeVariant === "future", "Future route not ready yet");

    const user = await users.create();

    await user.apiLogin();

    await page.goto("/apps/");

    await page.waitForLoadState();

    const locator = page.getByRole("heading", { name: "App Store" });

    await expect(locator).toBeVisible();
  });

  test("Browse apple-calendar and try to install", async ({ page, users }) => {
    const pro = await users.create();
    await pro.apiLogin();

    await installAppleCalendar(page);

    await expect(page.locator(`text=Connect to Apple Server`)).toBeVisible();
  });

  test("Installed Apps - Navigation", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();
    await page.goto("/apps/installed");
    await page.waitForSelector('[data-testid="connect-calendar-apps"]');
    await page.click('[data-testid="vertical-tab-payment"]');
    await page.waitForSelector('[data-testid="connect-payment-apps"]');
    await page.click('[data-testid="vertical-tab-automation"]');
    await page.waitForSelector('[data-testid="connect-automation-apps"]');
  });
});

test.describe("App Store - Unauthed", () => {
  test("Browse apple-calendar and try to install", async ({ page }) => {
    await installAppleCalendar(page);

    await expect(page.locator(`[data-testid="login-form"]`)).toBeVisible();
  });
});
import { expect } from "@playwright/test";

import { MembershipRole } from "@calcom/prisma/client";

import { test } from "./lib/fixtures";
import {
  bookTimeSlot,
  doOnOrgDomain,
  selectFirstAvailableTimeSlotNextMonth,
  selectSecondAvailableTimeSlotNextMonth,
} from "./lib/testUtils";

test.afterEach(({ users }) => users.deleteAll());

test("dynamic booking", async ({ page, users }) => {
  const pro = await users.create();
  await pro.apiLogin();

  const free = await users.create({ username: "free.example" });
  await page.goto(`/${pro.username}+${free.username}`);

  await test.step("book an event first day in next month", async () => {
    await selectFirstAvailableTimeSlotNextMonth(page);

    // Fill what is this meeting about? title
    await page.locator('[name="title"]').fill("Test meeting");

    await bookTimeSlot(page);

    await expect(page.locator("[data-testid=success-page]")).toBeVisible();
  });

  await test.step("can reschedule a booking", async () => {
    // Logged in
    await page.goto("/bookings/upcoming");
    await page.locator('[data-testid="edit_booking"]').nth(0).click();
    await page.locator('[data-testid="reschedule"]').click();
    await page.waitForURL((url) => {
      const bookingId = url.searchParams.get("rescheduleUid");
      return !!bookingId;
    });
    await selectSecondAvailableTimeSlotNextMonth(page);

    // No need to fill fields since they should be already filled
    await page.locator('[data-testid="confirm-reschedule-button"]').click();
    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();
  });

  await test.step("Can cancel the recently created booking", async () => {
    await page.goto("/bookings/upcoming");
    await page.locator('[data-testid="cancel"]').click();
    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });
    await page.locator('[data-testid="confirm_cancel"]').click();

    const cancelledHeadline = page.locator('[data-testid="cancelled-headline"]');
    await expect(cancelledHeadline).toBeVisible();
  });
});

test.describe("Organization:", () => {
  test.afterEach(({ orgs, users }) => {
    orgs.deleteAll();
    users.deleteAll();
  });
  test("Can book a time slot for an organization", async ({ page, users, orgs }) => {
    const org = await orgs.create({
      name: "TestOrg",
    });

    const user1 = await users.create({
      organizationId: org.id,
      name: "User 1",
      roleInOrganization: MembershipRole.ADMIN,
    });

    const user2 = await users.create({
      organizationId: org.id,
      name: "User 2",
      roleInOrganization: MembershipRole.ADMIN,
    });
    await doOnOrgDomain(
      {
        orgSlug: org.slug,
        page,
      },
      async () => {
        await page.goto(`/${user1.username}+${user2.username}`);
        await selectFirstAvailableTimeSlotNextMonth(page);
        await bookTimeSlot(page, {
          title: "Test meeting",
        });
        await expect(page.getByTestId("success-page")).toBeVisible();
        // All the teammates should be in the booking
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        await expect(page.getByText(user1.name!, { exact: true })).toBeVisible();
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        await expect(page.getByText(user2.name!, { exact: true })).toBeVisible();
      }
    );
  });
});
import { expect } from "@playwright/test";

import { bookTimeSlot, selectFirstAvailableTimeSlotNextMonth } from "@calcom/web/playwright/lib/testUtils";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";

test.describe.configure({ mode: "parallel" });

testBothFutureAndLegacyRoutes.describe("Payment", (routeVariant) => {
  test.describe("user", () => {
    test.afterEach(async ({ users }) => {
      await users.deleteAll();
    });

    test("should create a mock payment for a user", async ({ context, users, page }) => {
      test.skip(routeVariant === "future", "Future route not ready yet");
      test.skip(process.env.MOCK_PAYMENT_APP_ENABLED === undefined, "Skipped as Stripe is not installed");

      const user = await users.create();
      await user.apiLogin();
      await page.goto("/apps");

      await page.getByPlaceholder("Search").click();
      await page.getByPlaceholder("Search").fill("mock");

      await page.getByTestId("install-app-button").click();

      await page.waitForURL((url) => url.pathname.endsWith("/apps/installed/payment"));

      await page.getByRole("link", { name: "Event Types" }).click();

      await page.getByRole("link", { name: /^30 min/ }).click();
      await page.getByTestId("vertical-tab-apps").click();
      await page.locator("#event-type-form").getByRole("switch").click();
      await page.getByPlaceholder("Price").click();
      await page.getByPlaceholder("Price").fill("1");

      await page.locator("#test-mock-payment-app-currency-id").click();
      await page.getByTestId("select-option-USD").click();

      await page.getByTestId("update-eventtype").click();

      await page.goto(`${user.username}/30-min`);

      await page.waitForLoadState("networkidle");

      await selectFirstAvailableTimeSlotNextMonth(page);
      await bookTimeSlot(page);
      await page.waitForURL((url) => url.pathname.includes("/payment/"));

      const dataNextJsRouter = await page.evaluate(() =>
        window.document.documentElement.getAttribute("data-nextjs-router")
      );

      expect(dataNextJsRouter).toEqual("app");

      await page.getByText("Payment", { exact: true }).waitFor();
    });
  });
});
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";

test.describe.configure({ mode: "parallel" });

testBothFutureAndLegacyRoutes.describe("Settings/admin tests", () => {
  test("should render /settings/admin page", async ({ page, users, context }) => {
    const user = await users.create({
      role: "ADMIN",
    });
    await user.apiLogin();

    await page.goto("/settings/admin");

    await page.waitForLoadState();

    const locator = page.getByRole("heading", { name: "Feature Flags" });

    await expect(locator).toBeVisible();
  });
});
import { expect } from "@playwright/test";

import stripe from "@calcom/features/ee/payments/server/stripe";
import { WEBAPP_URL } from "@calcom/lib/constants";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

const IS_STRIPE_ENABLED = !!(
  process.env.STRIPE_CLIENT_ID &&
  process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY &&
  process.env.STRIPE_PRIVATE_KEY
);

const IS_SELF_HOSTED = !(
  new URL(WEBAPP_URL).hostname.endsWith(".cal.dev") || !!new URL(WEBAPP_URL).hostname.endsWith(".cal.com")
);

test.describe("Change username on settings", () => {
  test.afterEach(async ({ users }) => {
    await users.deleteAll();
  });

  test("User can change username", async ({ page, users, prisma }) => {
    const user = await users.create();

    await user.apiLogin();
    // Try to go homepage
    await page.goto("/settings/my-account/profile");
    // Change username from normal to normal
    const usernameInput = page.locator("[data-testid=username-input]");

    await usernameInput.fill("demousernamex");
    await page.click("[data-testid=update-username-btn]");
    await Promise.all([
      page.click("[data-testid=save-username]"),
      page.getByTestId("toast-success").waitFor(),
    ]);

    const newUpdatedUser = await prisma.user.findUniqueOrThrow({
      where: {
        id: user.id,
      },
    });

    expect(newUpdatedUser.username).toBe("demousernamex");
  });

  test("User can change username to include periods(or dots)", async ({ page, users, prisma }) => {
    const user = await users.create();

    await user.apiLogin();
    // Try to go homepage
    await page.goto("/settings/my-account/profile");
    // Change username from normal to normal
    const usernameInput = page.locator("[data-testid=username-input]");
    // User can change username to include dots(or periods)
    await usernameInput.fill("demo.username");
    await page.click("[data-testid=update-username-btn]");
    await Promise.all([
      page.click("[data-testid=save-username]"),
      page.getByTestId("toast-success").waitFor(),
    ]);
    await page.waitForLoadState("networkidle");

    const updatedUser = await prisma.user.findUniqueOrThrow({
      where: {
        id: user.id,
      },
    });

    expect(updatedUser.username).toBe("demo.username");

    // Check if user avatar can be accessed and response headers contain 'image/' in the content type
    const response = await page.goto("/demo.username/avatar.png");
    expect(response?.headers()?.["content-type"]).toContain("image/");
  });

  test("User can update to PREMIUM username", async ({ page, users }, testInfo) => {
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(!IS_STRIPE_ENABLED, "It should only run if Stripe is installed");
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(IS_SELF_HOSTED, "It shouldn't run on self hosted");

    const user = await users.create();
    await stripe.customers.create({ email: `${user?.username}@example.com` });

    await user.apiLogin();
    await page.goto("/settings/my-account/profile");

    // Change username from normal to premium
    const usernameInput = page.locator("[data-testid=username-input]");

    await usernameInput.fill(`xx${testInfo.workerIndex}`);

    // Click on save button
    await page.click('button[type="submit"]');

    // Validate modal text fields
    const currentUsernameText = page.locator("[data-testid=current-username]").innerText();

    const newUsernameText = page.locator("[data-testid=new-username]").innerText();

    expect(currentUsernameText).not.toBe(newUsernameText);

    // Click on Go to billing
    await page.click("[data-testid=go-to-billing]", { timeout: 300 });

    await page.waitForLoadState();

    await expect(page).toHaveURL(/.*checkout.stripe.com/);
  });
});
import { expect, test } from "@playwright/test";

import { IS_GOOGLE_LOGIN_ENABLED, IS_SAML_LOGIN_ENABLED } from "../server/lib/constants";

test("Should display Google Login button", async ({ page }) => {
  // eslint-disable-next-line playwright/no-skipped-test
  test.skip(!IS_GOOGLE_LOGIN_ENABLED, "It should only run if Google Login is installed");

  await page.goto(`/auth/login`);

  await expect(page.locator(`[data-testid=google]`)).toBeVisible();
});

test("Should display SAML Login button", async ({ page }) => {
  // eslint-disable-next-line playwright/no-skipped-test
  test.skip(!IS_SAML_LOGIN_ENABLED, "It should only run if SAML Login is installed");

  // TODO: Fix this later
  // Button is visible only if there is a SAML connection exists (self-hosted)
  // await page.goto(`/auth/login`);
  // await expect(page.locator(`[data-testid=saml]`)).toBeVisible();
});
import { test } from "./lib/fixtures";

test.describe("AppListCard", async () => {
  test("should remove the highlight from the URL", async ({ page, users }) => {
    const user = await users.create({});
    await user.apiLogin();

    await page.goto("/apps/installed/conferencing?hl=daily-video");

    await page.waitForLoadState();

    await page.waitForURL("/apps/installed/conferencing");
  });
});
import { expect } from "@playwright/test";

import { randomString } from "@calcom/lib/random";
import { SchedulingType } from "@calcom/prisma/client";
import type { Schedule, TimeRange } from "@calcom/types/schedule";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";
import {
  bookFirstEvent,
  bookOptinEvent,
  bookTimeSlot,
  expectEmailsToHaveSubject,
  selectFirstAvailableTimeSlotNextMonth,
  testEmail,
  testName,
} from "./lib/testUtils";

const freeUserObj = { name: `Free-user-${randomString(3)}` };
test.describe.configure({ mode: "parallel" });
test.afterEach(async ({ users }) => {
  await users.deleteAll();
});

testBothFutureAndLegacyRoutes.describe("free user", () => {
  test.beforeEach(async ({ page, users }) => {
    const free = await users.create(freeUserObj);
    await page.goto(`/${free.username}`);
  });

  test("cannot book same slot multiple times", async ({ page, users, emails }) => {
    const [user] = users.get();

    const bookerObj = {
      email: users.trackEmail({ username: "testEmail", domain: "example.com" }),
      name: "testBooker",
    };
    // Click first event type
    await page.click('[data-testid="event-type-link"]');

    await selectFirstAvailableTimeSlotNextMonth(page);

    await bookTimeSlot(page, bookerObj);

    // save booking url
    const bookingUrl: string = page.url();

    // Make sure we're navigated to the success page
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    const { title: eventTitle } = await user.getFirstEventAsOwner();

    await expectEmailsToHaveSubject({
      emails,
      organizer: user,
      booker: bookerObj,
      eventTitle,
    });
    await page.goto(bookingUrl);

    // book same time spot again
    await bookTimeSlot(page);

    await page.locator("[data-testid=booking-fail]").waitFor({ state: "visible" });
  });
});

testBothFutureAndLegacyRoutes.describe("pro user", () => {
  test.beforeEach(async ({ page, users }) => {
    const pro = await users.create();
    await page.goto(`/${pro.username}`);
  });

  test("pro user's page has at least 2 visible events", async ({ page }) => {
    const $eventTypes = page.locator("[data-testid=event-types] > *");
    expect(await $eventTypes.count()).toBeGreaterThanOrEqual(2);
  });

  test("book an event first day in next month", async ({ page }) => {
    await bookFirstEvent(page);
  });

  test("can reschedule a booking", async ({ page, users, bookings }) => {
    const [pro] = users.get();

    const [eventType] = pro.eventTypes;
    await bookings.create(pro.id, pro.username, eventType.id);

    await pro.apiLogin();
    await page.goto("/bookings/upcoming");
    await page.waitForSelector('[data-testid="bookings"]');
    await page.locator('[data-testid="edit_booking"]').nth(0).click();
    await page.locator('[data-testid="reschedule"]').click();
    await page.waitForURL((url) => {
      const bookingId = url.searchParams.get("rescheduleUid");
      return !!bookingId;
    });
    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();
    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });
  });

  test("Can cancel the recently created booking and rebook the same timeslot", async ({
    page,
    users,
  }, testInfo) => {
    // Because it tests the entire booking flow + the cancellation + rebooking
    test.setTimeout(testInfo.timeout * 3);
    await bookFirstEvent(page);
    await expect(page.locator(`[data-testid="attendee-email-${testEmail}"]`)).toHaveText(testEmail);
    await expect(page.locator(`[data-testid="attendee-name-${testName}"]`)).toHaveText(testName);

    const [pro] = users.get();
    await pro.apiLogin();

    await page.goto("/bookings/upcoming");
    await page.locator('[data-testid="cancel"]').click();
    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking/");
    });
    await page.locator('[data-testid="confirm_cancel"]').click();

    const cancelledHeadline = page.locator('[data-testid="cancelled-headline"]');
    await expect(cancelledHeadline).toBeVisible();

    await expect(page.locator(`[data-testid="attendee-email-${testEmail}"]`)).toHaveText(testEmail);
    await expect(page.locator(`[data-testid="attendee-name-${testName}"]`)).toHaveText(testName);

    await page.goto(`/${pro.username}`);
    await bookFirstEvent(page);
  });

  test("Can cancel the recently created booking and shouldn't be allowed to reschedule it", async ({
    page,
    users,
  }, testInfo) => {
    // Because it tests the entire booking flow + the cancellation + rebooking
    test.setTimeout(testInfo.timeout * 3);
    await bookFirstEvent(page);
    await expect(page.locator(`[data-testid="attendee-email-${testEmail}"]`)).toHaveText(testEmail);
    await expect(page.locator(`[data-testid="attendee-name-${testName}"]`)).toHaveText(testName);

    const [pro] = users.get();
    await pro.apiLogin();

    await page.goto("/bookings/upcoming");
    await page.locator('[data-testid="cancel"]').click();
    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking/");
    });
    await page.locator('[data-testid="confirm_cancel"]').click();

    const cancelledHeadline = page.locator('[data-testid="cancelled-headline"]');
    await expect(cancelledHeadline).toBeVisible();

    const bookingCancelledId = new URL(page.url()).pathname.split("/booking/")[1];
    await page.goto(`/reschedule/${bookingCancelledId}`);
    // Should be redirected to the booking details page which shows the cancelled headline
    await expect(page.locator('[data-testid="cancelled-headline"]')).toBeVisible();
  });

  test("can book an event that requires confirmation and then that booking can be accepted by organizer", async ({
    page,
    users,
  }) => {
    await bookOptinEvent(page);

    const [pro] = users.get();
    await pro.apiLogin();

    await page.goto("/bookings/unconfirmed");
    await Promise.all([
      page.click('[data-testid="confirm"]'),
      page.waitForResponse((response) => response.url().includes("/api/trpc/bookings/confirm")),
    ]);
    // This is the only booking in there that needed confirmation and now it should be empty screen
    await expect(page.locator('[data-testid="empty-screen"]')).toBeVisible();
  });

  test("can book with multiple guests", async ({ page, users }) => {
    const additionalGuests = ["test@gmail.com", "test2@gmail.com"];

    await page.click('[data-testid="event-type-link"]');
    await selectFirstAvailableTimeSlotNextMonth(page);
    await page.fill('[name="name"]', "test1234");
    await page.fill('[name="email"]', "test1234@example.com");
    await page.locator('[data-testid="add-guests"]').click();

    await page.locator('input[type="email"]').nth(1).fill(additionalGuests[0]);
    await page.locator('[data-testid="add-another-guest"]').click();
    await page.locator('input[type="email"]').nth(2).fill(additionalGuests[1]);

    await page.locator('[data-testid="confirm-book-button"]').click();

    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    const promises = additionalGuests.map(async (email) => {
      await expect(page.locator(`[data-testid="attendee-email-${email}"]`)).toHaveText(email);
    });
    await Promise.all(promises);
  });

  test("Time slots should be reserved when selected", async ({ context, page }) => {
    await page.click('[data-testid="event-type-link"]');

    const initialUrl = page.url();
    await selectFirstAvailableTimeSlotNextMonth(page);

    const pageTwo = await context.newPage();
    await pageTwo.goto(initialUrl);
    await pageTwo.waitForURL(initialUrl);

    await pageTwo.waitForSelector('[data-testid="event-type-link"]');

    const eventTypeLink = pageTwo.locator('[data-testid="event-type-link"]').first();
    await eventTypeLink.click();

    await pageTwo.waitForLoadState("networkidle");
    await pageTwo.locator('[data-testid="incrementMonth"]').waitFor();
    await pageTwo.click('[data-testid="incrementMonth"]');
    await pageTwo.waitForLoadState("networkidle");
    await pageTwo.locator('[data-testid="day"][data-disabled="false"]').nth(0).waitFor();
    await pageTwo.locator('[data-testid="day"][data-disabled="false"]').nth(0).click();

    // 9:30 should be the first available time slot
    await pageTwo.locator('[data-testid="time"]').nth(0).waitFor();

    const firstSlotAvailable = pageTwo.locator('[data-testid="time"]').nth(0);
    // Find text inside the element
    const firstSlotAvailableText = await firstSlotAvailable.innerText();
    expect(firstSlotAvailableText).toContain("9:30");
  });

  test("Time slots are not reserved when going back via Cancel button on Event Form", async ({
    context,
    page,
  }) => {
    const initialUrl = page.url();
    await page.waitForSelector('[data-testid="event-type-link"]');

    const eventTypeLink = page.locator('[data-testid="event-type-link"]').first();
    await eventTypeLink.click();
    await selectFirstAvailableTimeSlotNextMonth(page);

    const pageTwo = await context.newPage();
    await pageTwo.goto(initialUrl);
    await pageTwo.waitForURL(initialUrl);

    await pageTwo.waitForSelector('[data-testid="event-type-link"]');

    const eventTypeLinkTwo = pageTwo.locator('[data-testid="event-type-link"]').first();
    await eventTypeLinkTwo.click();

    await page.locator('[data-testid="back"]').waitFor();
    await page.click('[data-testid="back"]');

    await pageTwo.waitForLoadState("networkidle");
    await pageTwo.locator('[data-testid="incrementMonth"]').waitFor();
    await pageTwo.click('[data-testid="incrementMonth"]');
    await pageTwo.waitForLoadState("networkidle");
    await pageTwo.locator('[data-testid="day"][data-disabled="false"]').nth(0).waitFor();
    await pageTwo.locator('[data-testid="day"][data-disabled="false"]').nth(0).click();

    await pageTwo.locator('[data-testid="time"]').nth(0).waitFor();

    const firstSlotAvailable = pageTwo.locator('[data-testid="time"]').nth(0);

    // Find text inside the element
    const firstSlotAvailableText = await firstSlotAvailable.innerText();
    expect(firstSlotAvailableText).toContain("9:00");
  });
});

testBothFutureAndLegacyRoutes.describe("prefill", () => {
  test("logged in", async ({ page, users }) => {
    const prefill = await users.create({ name: "Prefill User" });
    await prefill.apiLogin();
    await page.goto("/pro/30min");

    await test.step("from session", async () => {
      await selectFirstAvailableTimeSlotNextMonth(page);
      await expect(page.locator('[name="name"]')).toHaveValue(prefill.name || "");
      await expect(page.locator('[name="email"]')).toHaveValue(prefill.email);
    });

    await test.step("from query params", async () => {
      const url = new URL(page.url());
      url.searchParams.set("name", testName);
      url.searchParams.set("email", testEmail);
      await page.goto(url.toString());

      await expect(page.locator('[name="name"]')).toHaveValue(testName);
      await expect(page.locator('[name="email"]')).toHaveValue(testEmail);
    });
  });

  test("Persist the field values when going back and coming back to the booking form", async ({
    page,
    users,
  }) => {
    await page.goto("/pro/30min");
    await selectFirstAvailableTimeSlotNextMonth(page);
    await page.fill('[name="name"]', "John Doe");
    await page.fill('[name="email"]', "john@example.com");
    await page.fill('[name="notes"]', "Test notes");
    await page.click('[data-testid="back"]');

    await selectFirstAvailableTimeSlotNextMonth(page);
    await expect(page.locator('[name="name"]')).toHaveValue("John Doe");
    await expect(page.locator('[name="email"]')).toHaveValue("john@example.com");
    await expect(page.locator('[name="notes"]')).toHaveValue("Test notes");
  });

  test("logged out", async ({ page, users }) => {
    await page.goto("/pro/30min");

    await test.step("from query params", async () => {
      await selectFirstAvailableTimeSlotNextMonth(page);

      const url = new URL(page.url());
      url.searchParams.set("name", testName);
      url.searchParams.set("email", testEmail);
      await page.goto(url.toString());

      await expect(page.locator('[name="name"]')).toHaveValue(testName);
      await expect(page.locator('[name="email"]')).toHaveValue(testEmail);
    });
  });
});

testBothFutureAndLegacyRoutes.describe("Booking on different layouts", () => {
  test.beforeEach(async ({ page, users }) => {
    const user = await users.create();
    await page.goto(`/${user.username}`);
  });

  test("Book on week layout", async ({ page }) => {
    // Click first event type
    await page.click('[data-testid="event-type-link"]');

    await page.click('[data-testid="toggle-group-item-week_view"]');

    await page.click('[data-testid="incrementMonth"]');

    await page.locator('[data-testid="calendar-empty-cell"]').nth(0).click();

    // Fill what is this meeting about? name email and notes
    await page.locator('[name="name"]').fill("Test name");
    await page.locator('[name="email"]').fill(`${randomString(4)}@example.com`);
    await page.locator('[name="notes"]').fill("Test notes");

    await page.click('[data-testid="confirm-book-button"]');

    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });

    // expect page to be booking page
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();
  });

  test("Book on column layout", async ({ page }) => {
    // Click first event type
    await page.click('[data-testid="event-type-link"]');

    await page.click('[data-testid="toggle-group-item-column_view"]');

    await page.click('[data-testid="incrementMonth"]');

    await page.locator('[data-testid="time"]').nth(0).click();

    // Fill what is this meeting about? name email and notes
    await page.locator('[name="name"]').fill("Test name");
    await page.locator('[name="email"]').fill(`${randomString(4)}@example.com`);
    await page.locator('[name="notes"]').fill("Test notes");

    await page.click('[data-testid="confirm-book-button"]');

    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });

    // expect page to be booking page
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();
  });
});

testBothFutureAndLegacyRoutes.describe("Booking round robin event", () => {
  test.beforeEach(async ({ page, users }) => {
    const teamMatesObj = [{ name: "teammate-1" }];

    const dateRanges: TimeRange = {
      start: new Date(new Date().setUTCHours(10, 0, 0, 0)), //one hour after default schedule (teammate-1's schedule)
      end: new Date(new Date().setUTCHours(17, 0, 0, 0)),
    };

    const schedule: Schedule = [[], [dateRanges], [dateRanges], [dateRanges], [dateRanges], [dateRanges], []];

    const testUser = await users.create(
      { schedule },
      {
        hasTeam: true,
        schedulingType: SchedulingType.ROUND_ROBIN,
        teamEventLength: 120,
        teammates: teamMatesObj,
      }
    );

    const team = await testUser.getFirstTeamMembership();
    await page.goto(`/team/${team.team.slug}`);
  });

  test("Does not book round robin host outside availability with date override", async ({ page, users }) => {
    const [testUser] = users.get();
    await testUser.apiLogin();

    const team = await testUser.getFirstTeamMembership();

    // Click first event type (round robin)
    await page.click('[data-testid="event-type-link"]');

    await page.click('[data-testid="incrementMonth"]');

    // books 9AM slots for 120 minutes (test-user is not available at this time, availability starts at 10)
    await page.locator('[data-testid="time"]').nth(0).click();

    await page.waitForLoadState("networkidle");

    await page.locator('[name="name"]').fill("Test name");
    await page.locator('[name="email"]').fill(`${randomString(4)}@example.com`);

    await page.click('[data-testid="confirm-book-button"]');

    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });

    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    const host = page.locator('[data-testid="booking-host-name"]');

    const hostName = await host.innerText();

    //expect teammate-1 to be booked, test-user is not available at this time
    expect(hostName).toBe("teammate-1");

    // make another booking to see if also for the second booking teammate-1 is booked
    await page.goto(`/team/${team.team.slug}`);

    await page.click('[data-testid="event-type-link"]');

    await page.click('[data-testid="incrementMonth"]');
    await page.click('[data-testid="incrementMonth"]');

    // Again book a 9AM slot for 120 minutes where test-user is not available
    await page.locator('[data-testid="time"]').nth(0).click();

    await page.waitForLoadState("networkidle");

    await page.locator('[name="name"]').fill("Test name");
    await page.locator('[name="email"]').fill(`${randomString(4)}@example.com`);

    await page.click('[data-testid="confirm-book-button"]');

    await page.waitForURL((url) => {
      return url.pathname.startsWith("/booking");
    });

    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    const hostSecondBooking = page.locator('[data-testid="booking-host-name"]');

    const hostNameSecondBooking = await hostSecondBooking.innerText();
    expect(hostNameSecondBooking).toBe("teammate-1"); // teammate-1 should be booked again
  });
});
import { expect } from "@playwright/test";
import { uuid } from "short-uuid";

import { verifyPassword } from "@calcom/features/auth/lib/verifyPassword";
import prisma from "@calcom/prisma";

import { test } from "../lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "../lib/future-legacy-routes";

test.afterEach(({ users }) => users.deleteAll());

testBothFutureAndLegacyRoutes.describe("Forgot password", async () => {
  test("Can reset forgotten password", async ({ page, users }) => {
    const user = await users.create();

    // Got to reset password flow
    await page.goto("/auth/forgot-password");

    await page.fill('input[name="email"]', `${user.username}@example.com`);
    await page.press('input[name="email"]', "Enter");

    // wait for confirm page.
    await page.waitForSelector("text=Reset link sent");

    // As a workaround, we query the db for the last created password request
    // there should be one, otherwise we throw
    const { id } = await prisma.resetPasswordRequest.findFirstOrThrow({
      where: {
        email: user.email,
      },
      select: {
        id: true,
      },
      orderBy: {
        createdAt: "desc",
      },
    });

    // Test when a user changes his email after starting the password reset flow
    await prisma.user.update({
      where: {
        email: user.email,
      },
      data: {
        email: `${user.username}-2@example.com`,
      },
    });

    await page.goto(`/auth/forgot-password/${id}`);

    await page.waitForSelector("text=That request is expired.");

    // Change the email back to continue testing.
    await prisma.user.update({
      where: {
        email: `${user.username}-2@example.com`,
      },
      data: {
        email: user.email,
      },
    });

    await page.goto(`/auth/forgot-password/${id}`);

    const newPassword = `${user.username}-123CAL-${uuid().toString()}`; // To match the password policy

    // Wait for page to fully load
    await page.waitForSelector("text=Reset Password");

    await page.fill('input[name="new_password"]', newPassword);
    await page.click('button[type="submit"]');

    await page.waitForSelector("text=Password updated");

    await expect(page.locator(`text=Password updated`)).toBeVisible();
    // now we check our DB to confirm the password was indeed updated.
    // we're not logging in to the UI to speed up test performance.
    const updatedUser = await prisma.user.findUniqueOrThrow({
      where: {
        email: user.email,
      },
      select: {
        id: true,
        password: true,
      },
    });

    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    expect(await verifyPassword(newPassword, updatedUser.password!)).toBeTruthy();

    // finally, make sure the same URL cannot be used to reset the password again, as it should be expired.
    await page.goto(`/auth/forgot-password/${id}`);

    await expect(page.locator(`text=Whoops`)).toBeVisible();
  });
});
import { test } from "../lib/fixtures";

test.describe("Can signup from a team invite", async () => {
  test.beforeEach(async ({ users }) => {
    const proUser = await users.create();
    await proUser.apiLogin();
  });
  test.afterEach(async ({ users }) => users.deleteAll());

  test("Team invites validations work and can accept invite", async ({ browser, page, users, prisma }) => {
    const [proUser] = users.get();

    const teamName = `${proUser.username}'s Team`;

    const testUser = {
      username: `${proUser.username}-member`,
      password: `${proUser.username}-member`,
      email: `${proUser.username}-member@example.com`,
    };
    await page.goto("/settings/teams/new");
    await page.waitForLoadState("networkidle");

    // Create a new team
    await page.locator('input[name="name"]').fill(teamName);
    await page.locator('input[name="slug"]').fill(teamName);
    await page.locator('button[type="submit"]').click();

    // Add new member to team
    await page.click('[data-testid="new-member-button"]');
    await page.fill('input[id="inviteUser"]', testUser.email);
    await page.click('[data-testid="invite-new-member-button"]');

    // TODO: Adapt to new flow

    // Wait for the invite to be sent
    /*await page.waitForSelector(`[data-testid="member-email"][data-email="${testUser.email}"]`);

      const tokenObj = await prisma.verificationToken.findFirstOrThrow({
        where: { identifier: testUser.email },
        select: { token: true },
      });

      if (!proUser.username) throw Error("Test username is null, can't continue");

      // Open a new user window to accept the invite
      const newPage = await browser.newPage();
      await newPage.goto(`/auth/signup?token=${tokenObj.token}&callbackUrl=${WEBAPP_URL}/settings/teams`);

      // Fill in form
      await newPage.fill('input[name="username"]', proUser.username); // Invalid username
      await newPage.fill('input[name="email"]', testUser.email);
      await newPage.fill('input[name="password"]', testUser.password);
      await newPage.fill('input[name="passwordcheck"]', testUser.password);
      await newPage.press('input[name="passwordcheck"]', "Enter"); // Press Enter to submit

      await expect(newPage.locator('text="Username already taken"')).toBeVisible();

      // Email address is already registered
      // TODO: Form errors don't disappear when corrected and resubmitted, so we need to refresh
      await newPage.reload();
      await newPage.fill('input[name="username"]', testUser.username);
      await newPage.fill('input[name="email"]', `${proUser.username}@example.com`); // Taken email
      await newPage.fill('input[name="password"]', testUser.password);
      await newPage.fill('input[name="passwordcheck"]', testUser.password);
      await newPage.press('input[name="passwordcheck"]', "Enter"); // Press Enter to submit
      await expect(newPage.locator('text="Email address is already registered"')).toBeVisible();

      // Successful signup
      // TODO: Form errors don't disappear when corrected and resubmitted, so we need to refresh
      await newPage.reload();
      await newPage.fill('input[name="username"]', testUser.username);
      await newPage.fill('input[name="email"]', testUser.email);
      await newPage.fill('input[name="password"]', testUser.password);
      await newPage.fill('input[name="passwordcheck"]', testUser.password);
      await newPage.press('input[name="passwordcheck"]', "Enter"); // Press Enter to submit
      await expect(newPage.locator(`[data-testid="login-form"]`)).toBeVisible();

      // We don't need the new browser anymore
      await newPage.close();

      const createdUser = await prisma.user.findUniqueOrThrow({
        where: { email: testUser.email },
        include: { teams: { include: { team: true } } },
      });

      console.log("createdUser", createdUser);

      // Check that the user was created
      expect(createdUser).not.toBeNull();
      expect(createdUser.username).toBe(testUser.username);
      expect(createdUser.password).not.toBeNull();
      expect(createdUser.emailVerified).not.toBeNull();
      // Check that the user accepted the team invite
      expect(createdUser.teams).toHaveLength(1);
      expect(createdUser.teams[0].team.name).toBe(teamName);
      expect(createdUser.teams[0].role).toBe("MEMBER");
      expect(createdUser.teams[0].accepted).toBe(true);*/
  });
});
import { expect } from "@playwright/test";

import { test } from "../lib/fixtures";

test.afterEach(({ users }) => users.deleteAll());

test("Can delete user account", async ({ page, users }) => {
  const user = await users.create({
    username: "delete-me",
  });
  await user.apiLogin();
  await page.goto(`/settings/my-account/profile`);
  await page.waitForSelector("[data-testid=dashboard-shell]");

  await page.click("[data-testid=delete-account]");

  expect(user.username).toBeTruthy();

  const $passwordField = page.locator("[data-testid=password]");
  await $passwordField.fill(String(user.username));

  await Promise.all([
    page.waitForURL((url) => url.pathname === "/auth/logout"),
    page.click("text=Delete my account"),
  ]);

  await expect(page.locator(`[id="modal-title"]`)).toHaveText("You've been logged out");
});
import { loginUser } from "../../fixtures/regularBookings";
import { test } from "../../lib/fixtures";

test.describe("Booking With Address Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users }) => {
    await loginUser(users);
    await page.goto("/event-types");
  });

  test.describe("Booking With Address Question and Checkbox Group Question", () => {
    test("Address required and checkbox group required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Checkbox Group question (both required)",
        secondQuestion: "checkbox",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and checkbox group not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Checkbox Group question (only address required)",
        secondQuestion: "checkbox",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Checkbox Question", () => {
    test("Address required and checkbox required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Checkbox question (both required)",
        secondQuestion: "boolean",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Addres and checkbox not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Checkbox question (only address required)",
        secondQuestion: "boolean",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Long text Question", () => {
    test("Addres required and Long Text required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Long Text question (both required)",
        secondQuestion: "textarea",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and Long Text not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", false, "textarea test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Long Text question (only address required)",
        secondQuestion: "textarea",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Multi email Question", () => {
    test("Address required and Multi email required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multiemail question (both required)",
        secondQuestion: "multiemail",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and Multi email not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        false,
        "multiemail test"
      );
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multiemail question (only address required)",
        secondQuestion: "multiemail",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and multiselect Question", () => {
    test("Address required and multiselect text required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multi Select question (both required)",
        secondQuestion: "multiselect",
        options: { ...bookingOptions, isMultiSelect: true },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and multiselect text not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multi Select question (only address required)",
        secondQuestion: "multiselect",
        options: { ...bookingOptions, isMultiSelect: true, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Number Question", () => {
    test("Address required and Number required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("number", "number-test", "number test", true, "number test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Number question (both required)",
        secondQuestion: "number",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and Number not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("number", "number-test", "number test", false, "number test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Number question (only address required)",
        secondQuestion: "number",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Phone Question", () => {
    test("Address required and Phone required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone-test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multi Select question (both required)",
        secondQuestion: "phone",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and Phone not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("phone", "phone-test", "phone test", false, "phone-test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multi Select question (only address required)",
        secondQuestion: "phone",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Radio group Question", () => {
    test("Address required and Radio group required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Radio question (both required)",
        secondQuestion: "radio",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and Radio group not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("radio", "radio-test", "radio test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Radio question (only address required)",
        secondQuestion: "radio",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and select Question", () => {
    test("Address required and select required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Select question (both required)",
        secondQuestion: "select",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and select not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("select", "select-test", "select test", false, "select test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Select question (both required)",
        secondQuestion: "select",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Address Question and Short text question", () => {
    test("Address required and Short text required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multi Select question (both required)",
        secondQuestion: "text",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Address and Short text not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "address",
        fillText: "Test Address question and Multi Select question (only address required)",
        secondQuestion: "text",
        options: { ...bookingOptions, isRequired: true },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With Checkbox Group Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  test.describe("Booking With Checkbox Group Question and Address Question", () => {
    test("Checkbox Group required and Address required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "checkbox",
        fillText: "Test Checkbox Group question and Address question (both required)",
        secondQuestion: "address",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Checkbox Group and Address not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
      await bookingPage.addQuestion("address", "address-test", "address test", false, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "checkbox",
        fillText: "Test Checkbox Group question and Address question (only checkbox required)",
        secondQuestion: "address",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test.describe("Booking With Checkbox Group Question and Phone Question", () => {
      test("Checkbox Group required and Phone required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and phone question (both required)",
          secondQuestion: "phone",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and Phone not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("phone", "phone-test", "phone test", false, "phone test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Phone question (only checkbox required)",
          secondQuestion: "phone",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and checkbox Question", () => {
      test("Checkbox Group required and checkbox required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and checkbox question (both required)",
          secondQuestion: "boolean",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and checkbox not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and checkbox (only checkbox required)",
          secondQuestion: "boolean",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and Long text Question", () => {
      test("Checkbox Group required and Long text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Long Text question (both required)",
          secondQuestion: "textarea",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and Long text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", false, "textarea test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Long Text question (only checkbox required)",
          secondQuestion: "textarea",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and Multi email Question", () => {
      test("Checkbox Group required and Multi email required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Multi Email question (both required)",
          secondQuestion: "multiemail",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and Multi email not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          false,
          "multiemail test"
        );
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Multi Email question (only checkbox required)",
          secondQuestion: "multiemail",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and multiselect Question", () => {
      test("Checkbox Group required and multiselect text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Multi Select question (both required)",
          secondQuestion: "multiselect",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and multiselect text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Multi Select question (only checkbox required)",
          secondQuestion: "multiselect",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and Number Question", () => {
      test("Checkbox Group required and Number required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("number", "number-test", "number test", true, "number test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Number question (both required)",
          secondQuestion: "number",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and Number not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("number", "number-test", "number test", false, "number test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Number question (only checkbox required)",
          secondQuestion: "number",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and Radio group Question", () => {
      test("Checkbox Group required and Radio group required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Radio question (both required)",
          secondQuestion: "radio",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and Radio group not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("radio", "radio-test", "radio test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Radio question (only checkbox required)",
          secondQuestion: "radio",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and select Question", () => {
      test("Checkbox Group required and select required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Select question (both required)",
          secondQuestion: "select",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and select not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("select", "select-test", "select test", false, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Select question (only checkbox required)",
          secondQuestion: "select",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Checkbox Group Question and Short text question", () => {
      test("Checkbox Group required and Short Text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Text question (both required)",
          secondQuestion: "text",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Checkbox Group and Short Text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "checkbox",
          fillText: "Test Checkbox Group question and Text question (only checkbox required)",
          secondQuestion: "text",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });
  });
});
/* eslint-disable playwright/no-conditional-in-test */
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

const resolutions = [
  {
    width: 1920,
    height: 1080,
  },
  {
    width: 1280,
    height: 720,
  },
  {
    width: 640,
    height: 480,
  },
];

test.describe("Booking With All Questions", () => {
  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");

    const allQuestions = [
      "phone",
      "address",
      "checkbox",
      "boolean",
      "textarea",
      "multiemail",
      "multiselect",
      "number",
      "radio",
      "select",
      "text",
    ];

    for (const question of allQuestions) {
      if (
        question !== "number" &&
        question !== "select" &&
        question !== "checkbox" &&
        question !== "boolean" &&
        question !== "multiselect" &&
        question !== "radio"
      ) {
        await bookingPage.addQuestion(
          question,
          `${question}-test`,
          `${question} test`,
          true,
          `${question} test`
        );
      } else {
        await bookingPage.addQuestion(question, `${question}-test`, `${question} test`, true);
      }
      await bookingPage.checkField(question);
    }
  });

  for (const resolution of resolutions) {
    test(`Booking with ${resolution.width}x${resolution.height} resolution and all questions`, async ({
      bookingPage,
    }) => {
      await bookingPage.setResolution(resolution.width, resolution.height);
      await bookingPage.updateEventType();
    });
  }
});

test.describe("Booking With no questions", () => {
  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  for (const resolution of resolutions) {
    test(`Booking with ${resolution.width}x${resolution.height} resolution and no questions`, async ({
      bookingPage,
    }) => {
      await bookingPage.setResolution(resolution.width, resolution.height);
      await bookingPage.updateEventType();
    });
  }
});

test.describe("Booking page with no questions", () => {
  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  for (const resolution of resolutions) {
    test(`Booking page with ${resolution.width}x${resolution.height} resolution`, async ({ bookingPage }) => {
      const eventTypePage = await bookingPage.previewEventType();
      await eventTypePage.setViewportSize({ width: resolution.width, height: resolution.height });
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.confirmBooking(eventTypePage);
    });
  }
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With Phone Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  test.describe("Booking With Phone Question and Address Question", () => {
    test("Phone and Address required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "phone",
        fillText: "Test Phone question and Address question (both required)",
        secondQuestion: "address",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Phone required and Address not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
      await bookingPage.addQuestion("address", "address-test", "address test", false, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "phone",
        fillText: "Test Phone question and Address question (only phone required)",
        secondQuestion: "address",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test.describe("Booking With Phone Question and checkbox group Question", () => {
      const bookingOptions = { hasPlaceholder: false, isRequired: true };
      test("Phone and checkbox group required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and checkbox group question (both required)",
          secondQuestion: "checkbox",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and checkbox group not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and checkbox group question (only phone required)",
          secondQuestion: "checkbox",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and checkbox Question", () => {
      test("Phone and checkbox required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and checkbox question (both required)",
          secondQuestion: "boolean",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
      test("Phone required and checkbox not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and checkbox (only phone required)",
          secondQuestion: "boolean",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and Long text Question", () => {
      test("Phone and Long text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Long Text question (both required)",
          secondQuestion: "textarea",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and Long text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", false, "textarea test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Long Text question (only phone required)",
          secondQuestion: "textarea",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and Multi email Question", () => {
      const bookingOptions = { hasPlaceholder: true, isRequired: true };
      test("Phone and Multi email required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Multi Email question (both required)",
          secondQuestion: "multiemail",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and Multi email not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          false,
          "multiemail test"
        );
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Multi Email question (only phone required)",
          secondQuestion: "multiemail",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and multiselect Question", () => {
      test("Phone and multiselect text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Multi Select question (both required)",
          secondQuestion: "multiselect",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and multiselect text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Multi Select question (only phone required)",
          secondQuestion: "multiselect",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and Number Question", () => {
      test("Phone and Number required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("number", "number-test", "number test", true, "number test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Number question (both required)",
          secondQuestion: "number",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and Number not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("number", "number-test", "number test", false, "number test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Number question (only phone required)",
          secondQuestion: "number",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and Radio group Question", () => {
      test("Phone and Radio group required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Radio question (both required)",
          secondQuestion: "radio",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and Radio group not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("radio", "radio-test", "radio test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Radio question (only phone required)",
          secondQuestion: "radio",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and select Question", () => {
      test("Phone and select required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Select question (both required)",
          secondQuestion: "select",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and select not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("select", "select-test", "select test", false, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Select question (only phone required)",
          secondQuestion: "select",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Phone Question and Short text question", () => {
      test("Phone and Short text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Text question (both required)",
          secondQuestion: "text",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Phone required and Short text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "phone",
          fillText: "Test Phone question and Text question (only phone required)",
          secondQuestion: "text",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });
  });
});
import { test } from "../../lib/fixtures";

test.describe("Collective event type", () => {
  const teamEventTitle = "Test Managed Event Type";
  let userId: number;
  test.beforeEach(async ({ page, users, bookingPage }) => {
    const userFixture = await users.create(
      { name: "testuser" },
      { hasTeam: true, schedulingType: "COLLECTIVE", teamEventTitle }
    );
    await userFixture.apiLogin();
    userId = userFixture.id;
    await page.goto("/event-types");
    await bookingPage.goToEventType(teamEventTitle);
  });
  test("Book a Collective event type", async ({ bookingPage }) => {
    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillEmailAndName(eventTypePage);
    await bookingPage.confirmBooking(eventTypePage);
    await bookingPage.backToBookings(eventTypePage);
    await bookingPage.assertLabelWithCorrectTeamName(eventTypePage, teamEventTitle);
    await bookingPage.assertBookingWithCorrectTitleAndDescription(eventTypePage, {
      profileName: "testuser",
      bookingName: teamEventTitle,
      teamName: `user-id-${userId}'s Team`,
    });
    await bookingPage.clickOnBooking(eventTypePage, teamEventTitle);
    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBookingWithReason(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });
  test("Book a Collective event type (with added guest)", async ({ bookingPage }) => {
    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillEmailAndName(eventTypePage);
    await bookingPage.addGuests(eventTypePage, { guests: ["test@example.com"] });
    await bookingPage.confirmBooking(eventTypePage);
    await bookingPage.backToBookings(eventTypePage);
    await bookingPage.assertLabelWithCorrectTeamName(eventTypePage, teamEventTitle);
    await bookingPage.assertBookingWithCorrectTitleAndDescription(eventTypePage, {
      profileName: "testuser",
      bookingName: teamEventTitle,
      teamName: `user-id-${userId}'s Team`,
      aditionalGuestEmail: "test@example.com",
    });
    await bookingPage.clickOnBooking(eventTypePage, teamEventTitle);
    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBookingWithReason(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With Phone Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  test.describe("Booking With Select Question and Address Question", () => {
    test("Select required and Address required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and Address question (both required)",
        secondQuestion: "address",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Address not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("address", "address-test", "address test", false, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and Address question (only select required)",
        secondQuestion: "address",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and checkbox group Question", () => {
    test("Select required and checkbox group required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and Checkbox question (both required)",
        secondQuestion: "checkbox",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and checkbox group not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and Checkbox question (only Select required)",
        secondQuestion: "checkbox",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and checkbox Question", () => {
    test("Select required and checkbox required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and boolean question (both required)",
        secondQuestion: "boolean",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and checkbox not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and boolean question (only select required)",
        secondQuestion: "boolean",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and Long text Question", () => {
    test("Select required and Long text required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and textarea question (both required)",
        secondQuestion: "textarea",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Long text not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", false, "textarea test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and textarea question (only select required)",
        secondQuestion: "textarea",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and Multi email Question", () => {
    test("Select required and Multi email required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and multiemail question (both required)",
        secondQuestion: "multiemail",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Multi email not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        false,
        "multiemail test"
      );
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and multiemail question (only select required)",
        secondQuestion: "multiemail",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and multiselect Question", () => {
    test("Select required and multiselect text required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and multiselect question (both required)",
        secondQuestion: "multiselect",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and multiselect text not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and multiselect question (only select required)",
        secondQuestion: "multiselect",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and Number Question", () => {
    test("Select required and Number required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("number", "number-test", "number test", true, "number test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and number question (both required)",
        secondQuestion: "number",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Number not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("number", "number-test", "number test", false, "number test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and number question (only select required)",
        secondQuestion: "number",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and Phone Question", () => {
    test("Select required and select required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and phone question (both required)",
        secondQuestion: "phone",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Phone not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("phone", "phone-test", "phone test", false, "phone test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and phone question (only select required)",
        secondQuestion: "phone",
        options: { ...bookingOptions, isRequired: false },
      });
    });
  });

  test.describe("Booking With Select Question and Radio group Question", () => {
    test("Select required and Radio group required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and radio question (both required)",
        secondQuestion: "radio",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Radio group not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("radio", "radio-test", "radio test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and radio question (only select required)",
        secondQuestion: "radio",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Select Question and Short text question", () => {
    test("Select required and Short text required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and text question (both required)",
        secondQuestion: "text",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Select and Short text not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
      await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "select",
        fillText: "Test Select question and text question (only select required)",
        secondQuestion: "text",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With Radio Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  test.describe("Booking With Radio Question and Address Question", () => {
    test("Radio required and Address required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "radio",
        fillText: "Test Radio question and Address question (both required)",
        secondQuestion: "address",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Radio and Address not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
      await bookingPage.addQuestion("address", "address-test", "address test", false, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "radio",
        fillText: "Test Radio question and Address question (only radio required)",
        secondQuestion: "address",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test.describe("Booking With Radio Question and checkbox group Question", () => {
      test("Radio required and checkbox group required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and checkbox group question (both required)",
          secondQuestion: "checkbox",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and checkbox group not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and checkbox group question (only radio required)",
          secondQuestion: "checkbox",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and checkbox Question", () => {
      test("Radio required and checkbox required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and checkbox question (both required)",
          secondQuestion: "boolean",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
      test("Radio and checkbox not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and checkbox (only radio required)",
          secondQuestion: "boolean",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and Long text Question", () => {
      test("Radio required and Long text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Long Text question (both required)",
          secondQuestion: "textarea",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and Long text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", false, "textarea test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Long Text question (only radio required)",
          secondQuestion: "textarea",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and Multi email Question", () => {
      test("Radio required and Multi email required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Multi Email question (both required)",
          secondQuestion: "multiemail",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and Multi email not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          false,
          "multiemail test"
        );
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Multi Email question (only radio required)",
          secondQuestion: "multiemail",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and multiselect Question", () => {
      test("Radio required and multiselect text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Multi Select question (both required)",
          secondQuestion: "multiselect",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and multiselect text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Multi Select question (only radio required)",
          secondQuestion: "multiselect",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and Number Question", () => {
      test("Radio required and Number required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("number", "number-test", "number test", true, "number test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Number question (both required)",
          secondQuestion: "number",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and Number not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("number", "number-test", "number test", false, "number test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Number question (only radio required)",
          secondQuestion: "number",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and Phone Question", () => {
      test("Radio required and Phone required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Phone question (both required)",
          secondQuestion: "phone",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and Phone not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("phone", "phone-test", "phone test", false, "phone test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Phone question (only radio required)",
          secondQuestion: "phone",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and select Question", () => {
      test("Radio required and select required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Select question (both required)",
          secondQuestion: "select",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and select not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("select", "select-test", "select test", false, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Select question (only radio required)",
          secondQuestion: "select",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Radio Question and Short text question", () => {
      test("Radio required and Short text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Text question (both required)",
          secondQuestion: "text",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Radio and Short text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
        await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "radio",
          fillText: "Test Radio question and Text question (only radio required)",
          secondQuestion: "text",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });
  });
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With Long Text Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users }) => {
    await loginUser(users);
    await page.goto("/event-types");
  });

  test("Long Text and Address required", async ({ bookingPage }) => {
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
    await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
    await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillAndConfirmBooking({
      eventTypePage,
      placeholderText: "Please share anything that will help prepare for our meeting.",
      question: "textarea",
      fillText: "Test Long Text question and Address question (both required)",
      secondQuestion: "address",
      options: bookingOptions,
    });
    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBooking(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });

  test("Long Text required and Address not required", async ({ bookingPage }) => {
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
    await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
    await bookingPage.addQuestion("address", "address-test", "address test", false, "address test");
    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillAndConfirmBooking({
      eventTypePage,
      placeholderText: "Please share anything that will help prepare for our meeting.",
      question: "textarea",
      fillText: "Test Long Text question and Address question (only Long Text required)",
      secondQuestion: "address",
      options: { ...bookingOptions, isRequired: false },
    });
    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBooking(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });

  test.describe("Booking With Long Text Question and Checkbox Group Question", () => {
    test("Long Text and Checkbox Group required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Checkbox Group question (both required)",
        secondQuestion: "checkbox",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and Checkbox Group not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Checkbox Group question (only Long Text required)",
        secondQuestion: "checkbox",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and checkbox Question", () => {
    test("Long Text and checkbox required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Checkbox question (only Long Text required)",
        secondQuestion: "boolean",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and checkbox not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Checkbox question (only Long Text required)",
        secondQuestion: "boolean",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and Multiple email Question", () => {
    const bookingOptions = { hasPlaceholder: true, isRequired: true };
    test("Long Text and Multiple email required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Multiple email question (both required)",
        secondQuestion: "multiemail",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and Multiple email not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        false,
        "multiemail test"
      );
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Multiple email question (only Long Text required)",
        secondQuestion: "multiemail",
        options: { hasPlaceholder: true, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and multiselect Question", () => {
    test("Long Text and multiselect text required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and multiselect question (both required)",
        secondQuestion: "multiselect",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and multiselect text not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and multiselect question (only long text required)",
        secondQuestion: "multiselect",
        options: { hasPlaceholder: false, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and Number Question", () => {
    test("Long Text and Number required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Number question (both required)",
        secondQuestion: "multiselect",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test("Long Text required and Number not required", async ({ bookingPage }) => {
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
    await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
    await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillAndConfirmBooking({
      eventTypePage,
      placeholderText: "Please share anything that will help prepare for our meeting.",
      question: "textarea",
      fillText: "Test Long Text question and Number question (only Long Textß required)",
      secondQuestion: "multiselect",
      options: { hasPlaceholder: false, isRequired: false },
    });
    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBooking(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });

  test.describe("Booking With Long Text Question and Phone Question", () => {
    test("Long Text and Phone required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Phone question (both required)",
        secondQuestion: "phone",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and Phone not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("phone", "phone-test", "phone test", false, "phone test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Phone question (only Long Text required)",
        secondQuestion: "phone",
        options: { hasPlaceholder: false, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and Radio group Question", () => {
    test("Long Text and Radio group required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Radio Group question (both required)",
        secondQuestion: "radio",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and Radio group not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("radio", "radio-test", "radio test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Radio Group question (only Long Text required)",
        secondQuestion: "radio",
        options: { hasPlaceholder: false, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and select Question", () => {
    test("Long Text and select required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("select", "select-test", "select test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Select question (both required)",
        secondQuestion: "select",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and select not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("select", "select-test", "select test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Select question (only Long Text required)",
        secondQuestion: "select",
        options: { hasPlaceholder: false, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Long Text Question and Short text question", () => {
    const bookingOptions = { hasPlaceholder: true, isRequired: true };
    test("Long Text and Short text required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Text question (both required)",
        secondQuestion: "text",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Long Text required and Short text not required", async ({ bookingPage }) => {
      await bookingPage.goToEventType("30 min");
      await bookingPage.goToTab("event_advanced_tab_title");
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "textarea",
        fillText: "Test Long Text question and Text question (only Long Text required)",
        secondQuestion: "text",
        options: { hasPlaceholder: false, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });
});
/* eslint-disable playwright/no-conditional-in-test */
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe.configure({ mode: "serial" });

test.describe("Booking with recurring checked", () => {
  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("recurring");
  });

  test("Updates event type with recurring events", async ({ page, bookingPage }) => {
    await bookingPage.updateRecurringTab("2", "3");
    await bookingPage.updateEventType();
    await page.getByRole("link", { name: "Event Types" }).click();
    await bookingPage.assertRepeatEventType();
  });

  test("Updates and shows recurring schedule correctly in booking page", async ({ bookingPage }) => {
    await bookingPage.updateRecurringTab("2", "3");
    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.fillRecurringFieldAndConfirm(eventTypePage);
  });
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With Multiple Email Question and Each Other Question", () => {
  const bookingOptions = { hasPlaceholder: true, isRequired: true };

  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  test.describe("Booking With Multiple Email Question and Address Question", () => {
    test("Multiple Email required and Address required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("address", "address-test", "address test", true, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Address question (both required)",
        secondQuestion: "address",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and Address not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("address", "address-test", "address test", false, "address test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Address question (only Multiple Email required)",
        secondQuestion: "address",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple Email Question and checkbox group Question", () => {
    test("Multiple Email required and checkbox group required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and checkbox group question (both required)",
        secondQuestion: "checkbox",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and checkbox group not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("checkbox", "checkbox-test", "checkbox test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and checkbox group question (only Multiple Email required)",
        secondQuestion: "checkbox",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple Email Question and checkbox Question", () => {
    test("Multiple Email required and checkbox required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and checkbox question (both required)",
        secondQuestion: "boolean",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and checkbox not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("boolean", "boolean-test", "boolean test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and checkbox (only Multiple Email required)",
        secondQuestion: "boolean",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple Email Question and Long text Question", () => {
    test("Multiple Email required and Long text required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", true, "textarea test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Long Text question (both required)",
        secondQuestion: "textarea",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and Long text not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("textarea", "textarea-test", "textarea test", false, "textarea test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Long Text question (only Multiple Email required)",
        secondQuestion: "textarea",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple Email Question and multiselect Question", () => {
    test("Multiple Email required and multiselect text required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Multi Select question (both required)",
        secondQuestion: "multiselect",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and multiselect text not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("multiselect", "multiselect-test", "multiselect test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Multi Select question (only  Multiple Email required)",
        secondQuestion: "multiselect",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple Email Question and Number Question", () => {
    test("Multiple Email required and Number required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("number", "number-test", "number test", true, "number test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Number question (both required)",
        secondQuestion: "number",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and Number not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("number", "number-test", "number test", false, "number test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Number question (only Multiple Email required)",
        secondQuestion: "number",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple email Question and phone Question", () => {
    test("Multiple email required and Phone required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("phone", "phone-test", "phone test", true, "phone test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Phone question (both required)",
        secondQuestion: "phone",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple email and Phone not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("phone", "phone-test", "phone test", false, "phone test");
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Phone question (both required)",
        secondQuestion: "phone",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });
  });

  test.describe("Booking With Multiple Email Question and Radio group Question", () => {
    test("Multiple Email required and Radio group required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("radio", "radio-test", "radio test", true);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test  Multiple Email question and Radio question (both required)",
        secondQuestion: "radio",
        options: bookingOptions,
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test("Multiple Email and Radio group not required", async ({ bookingPage }) => {
      await bookingPage.addQuestion(
        "multiemail",
        "multiemail-test",
        "multiemail test",
        true,
        "multiemail test"
      );
      await bookingPage.addQuestion("radio", "radio-test", "radio test", false);
      await bookingPage.updateEventType();
      const eventTypePage = await bookingPage.previewEventType();
      await bookingPage.selectTimeSlot(eventTypePage);
      await bookingPage.fillAndConfirmBooking({
        eventTypePage,
        placeholderText: "Please share anything that will help prepare for our meeting.",
        question: "multiemail",
        fillText: "Test Multiple Email question and Radio question (only  Multiple Email required)",
        secondQuestion: "radio",
        options: { ...bookingOptions, isRequired: false },
      });
      await bookingPage.rescheduleBooking(eventTypePage);
      await bookingPage.assertBookingRescheduled(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);
      await bookingPage.assertBookingCanceled(eventTypePage);
    });

    test.describe("Booking With Multiple Email Question and select Question", () => {
      test("Multiple Email required and select required", async ({ bookingPage }) => {
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.addQuestion("select", "select-test", "select test", true, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "multiemail",
          fillText: "Test Multiple Email question and Select question (both required)",
          secondQuestion: "select",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Multiple Email and select not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.addQuestion("select", "select-test", "select test", false, "select test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "multiemail",
          fillText: "Test Multiple Email question and Select question (only Multiple Email required)",
          secondQuestion: "select",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });

    test.describe("Booking With Multiple Email Question and Short text question", () => {
      test("Multiple Email required and Short text required", async ({ bookingPage }) => {
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.addQuestion("text", "text-test", "text test", true, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "multiemail",
          fillText: "Test Multiple Email question and Text question (both required)",
          secondQuestion: "text",
          options: bookingOptions,
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });

      test("Multiple Email and Short text not required", async ({ bookingPage }) => {
        await bookingPage.addQuestion(
          "multiemail",
          "multiemail-test",
          "multiemail test",
          true,
          "multiemail test"
        );
        await bookingPage.addQuestion("text", "text-test", "text test", false, "text test");
        await bookingPage.updateEventType();

        const eventTypePage = await bookingPage.previewEventType();
        await bookingPage.selectTimeSlot(eventTypePage);
        await bookingPage.fillAndConfirmBooking({
          eventTypePage,
          placeholderText: "Please share anything that will help prepare for our meeting.",
          question: "multiemail",
          fillText: "Test Multiple Email question and Text question (only Multiple Email required)",
          secondQuestion: "text",
          options: { ...bookingOptions, isRequired: false },
        });
        await bookingPage.rescheduleBooking(eventTypePage);
        await bookingPage.assertBookingRescheduled(eventTypePage);
        await bookingPage.cancelBooking(eventTypePage);
        await bookingPage.assertBookingCanceled(eventTypePage);
      });
    });
  });
});
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Check availability tab in a event-type", () => {
  test("Check availability in event type", async ({ eventTypePage, users }) => {
    await loginUser(users);
    await eventTypePage.goToEventTypesPage();

    await eventTypePage.goToEventType("30 min");
    await eventTypePage.goToTab("availability");
    await eventTypePage.checkAvailabilityTab();
    await eventTypePage.goToAvailabilityPage();
    await eventTypePage.checkAvailabilityPage();
  });
});
/* eslint-disable playwright/no-conditional-in-test */
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Booking With All Questions", () => {
  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_advanced_tab_title");
  });

  const bookingOptions = { isAllRequired: true };

  test("Selecting and filling all questions as required", async ({ bookingPage }) => {
    const allQuestions = [
      "phone",
      "address",
      "checkbox",
      "boolean",
      "textarea",
      "multiemail",
      "multiselect",
      "number",
      "radio",
      "select",
      "text",
    ];

    for (const question of allQuestions) {
      if (
        question !== "number" &&
        question !== "select" &&
        question !== "checkbox" &&
        question !== "boolean" &&
        question !== "multiselect" &&
        question !== "radio"
      ) {
        await bookingPage.addQuestion(
          question,
          `${question}-test`,
          `${question} test`,
          true,
          `${question} test`
        );
      } else {
        await bookingPage.addQuestion(question, `${question}-test`, `${question} test`, true);
      }
      await bookingPage.checkField(question);
    }

    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillAllQuestions(eventTypePage, allQuestions, bookingOptions);
    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBooking(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });

  test("Selecting and filling all questions as optional", async ({ bookingPage }) => {
    const allQuestions = [
      "phone",
      "address",
      "checkbox",
      "boolean",
      "textarea",
      "multiemail",
      "multiselect",
      "number",
      "radio",
      "select",
      "text",
    ];

    for (const question of allQuestions) {
      if (
        question !== "number" &&
        question !== "select" &&
        question !== "checkbox" &&
        question !== "boolean" &&
        question !== "multiselect" &&
        question !== "radio"
      ) {
        await bookingPage.addQuestion(
          question,
          `${question}-test`,
          `${question} test`,
          false,
          `${question} test`
        );
      } else {
        await bookingPage.addQuestion(question, `${question}-test`, `${question} test`, false);
      }
      await bookingPage.checkField(question, { isOptional: true });
    }

    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();
    await bookingPage.selectTimeSlot(eventTypePage);
    await bookingPage.fillAllQuestions(eventTypePage, allQuestions, {
      ...bookingOptions,
      isAllRequired: false,
    });

    await bookingPage.rescheduleBooking(eventTypePage);
    await bookingPage.assertBookingRescheduled(eventTypePage);
    await bookingPage.cancelBooking(eventTypePage);
    await bookingPage.assertBookingCanceled(eventTypePage);
  });
});
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";

test.afterEach(({ users }) => users.deleteAll());

test.describe("Change Password Test", () => {
  test("change password", async ({ page, users }) => {
    const pro = await users.create();
    await pro.apiLogin();
    // Go to http://localhost:3000/settings/security
    await page.goto("/settings/security/password");

    expect(pro.username).toBeTruthy();

    await page.waitForLoadState("networkidle");

    // Fill form
    await page.locator('[name="oldPassword"]').fill(String(pro.username));

    const $newPasswordField = page.locator('[name="newPassword"]');
    $newPasswordField.fill(`${pro.username}Aa1111`);

    await page.locator("text=Update").click();

    const toast = await page.waitForSelector('[data-testid="toast-success"]');

    expect(toast).toBeTruthy();
  });
});
import { expect } from "@playwright/test";

import { login } from "./fixtures/users";
import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";
import { localize } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });

// a test to logout requires both a succesfull login as logout, to prevent
// a doubling of tests failing on logout & logout, we can group them.
testBothFutureAndLegacyRoutes.describe("user can login & logout succesfully", async () => {
  test.afterAll(async ({ users }) => {
    await users.deleteAll();
  });
  test("login flow user & logout using dashboard", async ({ page, users }) => {
    // log in trail user
    await test.step("Log in", async () => {
      const user = await users.create();
      await user.login();

      const shellLocator = page.locator(`[data-testid=dashboard-shell]`);
      await page.waitForURL("/event-types");
      await expect(shellLocator).toBeVisible();
    });

    //
    await test.step("Log out", async () => {
      const signOutLabel = (await localize("en"))("sign_out");
      const userDropdownDisclose = async () => page.locator("[data-testid=user-dropdown-trigger]").click();

      // disclose and click the sign out button from the user dropdown
      await userDropdownDisclose();
      const signOutBtn = page.locator(`text=${signOutLabel}`);
      await signOutBtn.click();

      await page.locator("[data-testid=logout-btn]").click();

      // Reroute to the home page to check if the login form shows up
      await expect(page.locator(`[data-testid=login-form]`)).toBeVisible();
    });
  });
});

testBothFutureAndLegacyRoutes.describe("Login and logout tests", () => {
  test.afterAll(async ({ users }) => {
    await users.deleteAll();
  });

  test.afterEach(async ({ users, page }) => {
    await users.logout();

    // check if we are at the login page
    await page.goto("/");
    await expect(page.locator(`[data-testid=login-form]`)).toBeVisible();
  });

  testBothFutureAndLegacyRoutes.describe("Login flow validations", async () => {
    test("Should warn when user does not exist", async ({ page }) => {
      const alertMessage = (await localize("en"))("incorrect_email_password");

      // Login with a non-existent user
      const never = "never";
      await login({ username: never }, page);

      // assert for the visibility of the localized alert message
      await expect(page.locator(`text=${alertMessage}`)).toBeVisible();
    });

    test("Should warn when password is incorrect", async ({ page, users }) => {
      const alertMessage = (await localize("en"))("incorrect_email_password");
      // by default password===username with the users fixture
      const pro = await users.create({ username: "pro" });

      // login with a wrong password
      await login({ username: pro.username, password: "wrong" }, page);

      // assert for the visibility of the localized  alert message
      await expect(page.locator(`text=${alertMessage}`)).toBeVisible();
    });
  });
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";

import { WEBAPP_URL } from "@calcom/lib/constants";
import { randomString } from "@calcom/lib/random";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";
import { bookTimeSlot, createNewEventType, selectFirstAvailableTimeSlotNextMonth } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });

testBothFutureAndLegacyRoutes.describe("Event Types A/B tests", () => {
  test("should render the /future/event-types page", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/event-types");

    const locator = page.getByRole("heading", { name: "Event Types" });

    await expect(locator).toBeVisible();
  });
});

testBothFutureAndLegacyRoutes.describe("Event Types tests", () => {
  test.describe("user", () => {
    test.beforeEach(async ({ page, users }) => {
      const user = await users.create();
      await user.apiLogin();
      await page.goto("/event-types");

      // We wait until loading is finished
      await page.waitForSelector('[data-testid="event-types"]');
    });

    test.afterEach(async ({ users }) => {
      await users.deleteAll();
    });

    test("has at least 2 events", async ({ page }) => {
      const $eventTypes = page.locator("[data-testid=event-types] > li a");
      const count = await $eventTypes.count();
      expect(count).toBeGreaterThanOrEqual(2);
    });

    test("can add new event type", async ({ page }) => {
      const nonce = randomString(3);
      const eventTitle = `hello ${nonce}`;
      await createNewEventType(page, { eventTitle });
      await page.goto("/event-types");
      await expect(page.locator(`text='${eventTitle}'`)).toBeVisible();
    });

    test("enabling recurring event comes with default options", async ({ page }) => {
      const nonce = randomString(3);
      const eventTitle = `my recurring event ${nonce}`;
      await createNewEventType(page, { eventTitle });

      await page.click("[data-testid=vertical-tab-recurring]");
      await expect(page.locator("[data-testid=recurring-event-collapsible]")).toBeHidden();
      await page.click("[data-testid=recurring-event-check]");
      await expect(page.locator("[data-testid=recurring-event-collapsible]")).toBeVisible();

      expect(
        await page
          .locator("[data-testid=recurring-event-collapsible] input[type=number]")
          .nth(0)
          .getAttribute("value")
      ).toBe("1");
      expect(
        await page.locator("[data-testid=recurring-event-collapsible] div[class$=singleValue]").textContent()
      ).toBe("week");
      expect(
        await page
          .locator("[data-testid=recurring-event-collapsible] input[type=number]")
          .nth(1)
          .getAttribute("value")
      ).toBe("12");
    });

    test("can duplicate an existing event type", async ({ page }) => {
      const firstElement = await page.waitForSelector(
        '[data-testid="event-types"] a[href^="/event-types/"] >> nth=0'
      );
      const href = await firstElement.getAttribute("href");
      expect(href).toBeTruthy();
      const [eventTypeId] = new URL(WEBAPP_URL + href).pathname.split("/").reverse();
      const firstTitle = await page.locator(`[data-testid=event-type-title-${eventTypeId}]`).innerText();
      const firstFullSlug = await page.locator(`[data-testid=event-type-slug-${eventTypeId}]`).innerText();
      const firstSlug = firstFullSlug.split("/")[2];

      await page.click(`[data-testid=event-type-options-${eventTypeId}]`);
      await page.click(`[data-testid=event-type-duplicate-${eventTypeId}]`);
      // Wait for the dialog to appear so we can get the URL
      await page.waitForSelector('[data-testid="dialog-title"]');

      const url = page.url();
      const params = new URLSearchParams(url);

      expect(params.get("title")).toBe(firstTitle);
      expect(params.get("slug")).toContain(firstSlug);

      const formTitle = await page.inputValue("[name=title]");
      const formSlug = await page.inputValue("[name=slug]");

      expect(formTitle).toBe(firstTitle);
      expect(formSlug).toContain(firstSlug);
    });

    test("edit first event", async ({ page }) => {
      const $eventTypes = page.locator("[data-testid=event-types] > li a");
      const firstEventTypeElement = $eventTypes.first();
      await firstEventTypeElement.click();
      await page.waitForURL((url) => {
        return !!url.pathname.match(/\/event-types\/.+/);
      });
      await page.locator("[data-testid=update-eventtype]").click();
      const toast = await page.waitForSelector('[data-testid="toast-success"]');
      expect(toast).toBeTruthy();
    });

    test("can add multiple organizer address", async ({ page }) => {
      const $eventTypes = page.locator("[data-testid=event-types] > li a");
      const firstEventTypeElement = $eventTypes.first();
      await firstEventTypeElement.click();
      await page.waitForURL((url) => {
        return !!url.pathname.match(/\/event-types\/.+/);
      });

      const locationData = ["location 1", "location 2", "location 3"];

      await fillLocation(page, locationData[0], 0);

      await page.locator("[data-testid=add-location]").click();
      await fillLocation(page, locationData[1], 1);

      await page.locator("[data-testid=add-location]").click();
      await fillLocation(page, locationData[2], 2);

      await page.locator("[data-testid=update-eventtype]").click();

      await page.goto("/event-types");

      const previewLink = await page
        .locator("[data-testid=preview-link-button]")
        .first()
        .getAttribute("href");

      /**
       * Verify first organizer address
       */
      await page.goto(previewLink ?? "");
      await selectFirstAvailableTimeSlotNextMonth(page);
      await page.locator(`span:has-text("${locationData[0]}")`).click();
      await bookTimeSlot(page);
      await expect(page.locator("[data-testid=success-page]")).toBeVisible();
      await expect(page.locator(`[data-testid="where"]`)).toHaveText(locationData[0]);

      /**
       * Verify second organizer address
       */
      await page.goto(previewLink ?? "");
      await selectFirstAvailableTimeSlotNextMonth(page);
      await page.locator(`span:has-text("${locationData[1]}")`).click();
      await bookTimeSlot(page);
      await expect(page.locator("[data-testid=success-page]")).toBeVisible();
      await expect(page.locator(`[data-testid="where"]`)).toHaveText(locationData[1]);
    });

    test.describe("Different Locations Tests", () => {
      test("can add Attendee Phone Number location and book with it", async ({ page }) => {
        await gotoFirstEventType(page);
        await selectAttendeePhoneNumber(page);
        await saveEventType(page);
        await gotoBookingPage(page);
        await selectFirstAvailableTimeSlotNextMonth(page);

        await page.locator(`[data-fob-field-name="location"] input`).fill("9199999999");
        await bookTimeSlot(page);

        await expect(page.locator("[data-testid=success-page]")).toBeVisible();
        await expect(page.locator("text=+19199999999")).toBeVisible();
      });

      test("Can add Organzer Phone Number location and book with it", async ({ page }) => {
        await gotoFirstEventType(page);

        await page.locator("#location-select").click();
        await page.locator(`text="Organizer Phone Number"`).click();

        const locationInputName = "locations[0].hostPhoneNumber";
        await page.locator(`input[name="${locationInputName}"]`).waitFor();
        await page.locator(`input[name="${locationInputName}"]`).fill("9199999999");

        await saveEventType(page);
        await gotoBookingPage(page);
        await selectFirstAvailableTimeSlotNextMonth(page);

        await bookTimeSlot(page);

        await expect(page.locator("[data-testid=success-page]")).toBeVisible();
        await expect(page.locator("text=+19199999999")).toBeVisible();
      });

      test("Can add Cal video location and book with it", async ({ page }) => {
        await gotoFirstEventType(page);

        await page.locator("#location-select").click();
        await page.locator(`text="Cal Video (Global)"`).click();

        await saveEventType(page);
        await page.getByTestId("toast-success").waitFor();
        await gotoBookingPage(page);
        await selectFirstAvailableTimeSlotNextMonth(page);

        await bookTimeSlot(page);

        await expect(page.locator("[data-testid=success-page]")).toBeVisible();
        await expect(page.locator("[data-testid=where] ")).toContainText("Cal Video");
      });

      test("Can add Link Meeting as location and book with it", async ({ page }) => {
        await gotoFirstEventType(page);

        await page.locator("#location-select").click();
        await page.locator(`text="Link meeting"`).click();

        const locationInputName = `locations[0].link`;

        const testUrl = "https://cal.ai/";
        await page.locator(`input[name="${locationInputName}"]`).fill(testUrl);

        await saveEventType(page);
        await page.getByTestId("toast-success").waitFor();
        await gotoBookingPage(page);
        await selectFirstAvailableTimeSlotNextMonth(page);

        await bookTimeSlot(page);

        await expect(page.locator("[data-testid=success-page]")).toBeVisible();

        const linkElement = await page.locator("[data-testid=where] > a");
        expect(await linkElement.getAttribute("href")).toBe(testUrl);
      });

      test("Can remove location from multiple locations that are saved", async ({ page }) => {
        await gotoFirstEventType(page);

        // Add Attendee Phone Number location
        await selectAttendeePhoneNumber(page);

        // Add Cal Video location
        await addAnotherLocation(page, "Cal Video (Global)");

        await saveEventType(page);
        await page.waitForLoadState("networkidle");

        // Remove Attendee Phone Number Location
        const removeButtomId = "delete-locations.0.type";
        await page.getByTestId(removeButtomId).click();

        await saveEventType(page);
        await page.waitForLoadState("networkidle");

        await gotoBookingPage(page);
        await selectFirstAvailableTimeSlotNextMonth(page);

        await bookTimeSlot(page);

        await expect(page.locator("[data-testid=success-page]")).toBeVisible();
        await expect(page.locator("[data-testid=where]")).toHaveText(/Cal Video/);
      });

      test("can add single organizer address location without display location public option", async ({
        page,
      }) => {
        const $eventTypes = page.locator("[data-testid=event-types] > li a");

        const firstEventTypeElement = $eventTypes.first();
        await firstEventTypeElement.click();
        await page.waitForURL((url) => {
          return !!url.pathname.match(/\/event-types\/.+/);
        });

        const locationAddress = "New Delhi";

        await fillLocation(page, locationAddress, 0, false);
        await page.locator("[data-testid=update-eventtype]").click();

        await page.goto("/event-types");

        const previewLink = await page
          .locator("[data-testid=preview-link-button]")
          .first()
          .getAttribute("href");

        await page.goto(previewLink ?? "");
        await selectFirstAvailableTimeSlotNextMonth(page);
        await bookTimeSlot(page);
        await expect(page.locator("[data-testid=success-page]")).toBeVisible();
        await expect(page.locator(`[data-testid="where"]`)).toHaveText(locationAddress);
      });

      test("can select 'display on booking page' option when multiple organizer input type are present", async ({
        page,
      }) => {
        await gotoFirstEventType(page);

        await page.locator("#location-select").click();
        await page.locator(`text="Link meeting"`).click();

        const locationInputName = (idx: number) => `locations[${idx}].link`;

        const testUrl1 = "https://cal.ai/";
        await page.locator(`input[name="${locationInputName(0)}"]`).fill(testUrl1);
        await page.locator("[data-testid=display-location]").last().check();
        await checkDisplayLocation(page);
        await unCheckDisplayLocation(page);

        await page.locator("[data-testid=add-location]").click();

        const testUrl2 = "https://cal.com/ai";
        await page.locator(`text="Link meeting"`).last().click();
        await page.locator(`input[name="${locationInputName(1)}"]`).waitFor();
        await page.locator(`input[name="${locationInputName(1)}"]`).fill(testUrl2);
        await checkDisplayLocation(page);
        await unCheckDisplayLocation(page);

        // Remove Both of the locations
        const removeButtomId = "delete-locations.0.type";
        await page.getByTestId(removeButtomId).click();
        await page.getByTestId(removeButtomId).click();

        // Add Multiple Organizer Phone Number options
        await page.locator("#location-select").click();
        await page.locator(`text="Organizer Phone Number"`).click();

        const organizerPhoneNumberInputName = (idx: number) => `locations[${idx}].hostPhoneNumber`;

        const testPhoneInputValue1 = "9199999999";
        await page.locator(`input[name="${organizerPhoneNumberInputName(0)}"]`).waitFor();
        await page.locator(`input[name="${organizerPhoneNumberInputName(0)}"]`).fill(testPhoneInputValue1);
        await page.locator("[data-testid=display-location]").last().check();
        await checkDisplayLocation(page);
        await unCheckDisplayLocation(page);
        await page.locator("[data-testid=add-location]").click();

        const testPhoneInputValue2 = "9188888888";
        await page.locator(`text="Organizer Phone Number"`).last().click();
        await page.locator(`input[name="${organizerPhoneNumberInputName(1)}"]`).waitFor();
        await page.locator(`input[name="${organizerPhoneNumberInputName(1)}"]`).fill(testPhoneInputValue2);
        await checkDisplayLocation(page);
        await unCheckDisplayLocation(page);
      });
    });
  });
});

const selectAttendeePhoneNumber = async (page: Page) => {
  const locationOptionText = "Attendee Phone Number";
  await page.locator("#location-select").click();
  await page.locator(`text=${locationOptionText}`).click();
};

async function gotoFirstEventType(page: Page) {
  const $eventTypes = page.locator("[data-testid=event-types] > li a");
  const firstEventTypeElement = $eventTypes.first();
  await firstEventTypeElement.click();
  await page.waitForURL((url) => {
    return !!url.pathname.match(/\/event-types\/.+/);
  });
}

async function saveEventType(page: Page) {
  await page.locator("[data-testid=update-eventtype]").click();
}

async function gotoBookingPage(page: Page) {
  const previewLink = await page.locator("[data-testid=preview-button]").getAttribute("href");

  await page.goto(previewLink ?? "");
}

/**
 * Adds n+1 location to the event type
 */
async function addAnotherLocation(page: Page, locationOptionText: string) {
  await page.locator("[data-testid=add-location]").click();
  // When adding another location, the dropdown opens automatically. So, we don't need to open it here.
  //
  await page.locator(`text="${locationOptionText}"`).click();
}

const fillLocation = async (page: Page, inputText: string, index: number, selectDisplayLocation = true) => {
  // Except the first location, dropdown automatically opens when adding another location
  if (index == 0) {
    await page.locator("#location-select").last().click();
  }
  await page.locator("text=In Person (Organizer Address)").last().click();

  const locationInputName = `locations[${index}].address`;
  await page.locator(`input[name="${locationInputName}"]`).waitFor();
  await page.locator(`input[name="locations[${index}].address"]`).fill(inputText);
  if (selectDisplayLocation) {
    await page.locator("[data-testid=display-location]").last().check();
  }
};

const checkDisplayLocation = async (page: Page) => {
  await page.locator("[data-testid=display-location]").last().check();
  await expect(page.locator("[data-testid=display-location]").last()).toBeChecked();
};

const unCheckDisplayLocation = async (page: Page) => {
  await page.locator("[data-testid=display-location]").last().uncheck();
  await expect(page.locator("[data-testid=display-location]").last()).toBeChecked({ checked: false });
};
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "serial" });

test.describe("unauthorized user sees correct translations (de)", async () => {
  test.use({
    locale: "de",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    // we dont need to wait for styles and images, only for dom
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=de]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("Willkommen zurück", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (ar)", async () => {
  test.use({
    locale: "ar",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=ar]").waitFor({ state: "attached" });
    await page.locator("html[dir=rtl]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("أهلاً بك من جديد", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (zh)", async () => {
  test.use({
    locale: "zh",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=zh]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("欢迎回来", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (zh-CN)", async () => {
  test.use({
    locale: "zh-CN",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=zh-CN]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("欢迎回来", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (zh-TW)", async () => {
  test.use({
    locale: "zh-TW",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=zh-TW]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("歡迎回來", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (pt)", async () => {
  test.use({
    locale: "pt",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=pt]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("Olá novamente", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (pt-br)", async () => {
  test.use({
    locale: "pt-BR",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    await page.locator("html[lang=pt-BR]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("Bem-vindo(a) novamente", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("unauthorized user sees correct translations (es-419)", async () => {
  test.use({
    locale: "es-419",
  });

  test("should use correct translations and html attributes", async ({ page }) => {
    await page.goto("/");
    await page.waitForLoadState("domcontentloaded");

    // es-419 is disabled in i18n config, so es should be used as fallback
    await page.locator("html[lang=es]").waitFor({ state: "attached" });
    await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

    {
      const locator = page.getByText("Bienvenido de nuevo", { exact: true });
      expect(await locator.count()).toEqual(1);
    }

    {
      const locator = page.getByText("Welcome back", { exact: true });
      expect(await locator.count()).toEqual(0);
    }
  });
});

test.describe("authorized user sees correct translations (de)", async () => {
  test.use({
    locale: "en",
  });

  test("should return correct translations and html attributes", async ({ page, users }) => {
    await test.step("should create a de user", async () => {
      const user = await users.create({
        locale: "de",
      });
      await user.apiLogin();
    });

    await test.step("should navigate to /event-types and show German translations", async () => {
      await page.goto("/event-types");

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=de]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "Ereignistypen", exact: true });
        // locator.count() does not wait for elements
        // but event-types page is client side, so it takes some time to render html
        // thats why we need to use method that awaits for the element
        // https://github.com/microsoft/playwright/issues/14278#issuecomment-1131754679
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Event Types", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should navigate to /bookings and show German translations", async () => {
      await page.goto("/bookings");

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=de]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "Buchungen", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Bookings", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should reload the /bookings and show German translations", async () => {
      await page.reload();

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=de]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "Buchungen", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Bookings", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });
  });
});

test.describe("authorized user sees correct translations (pt-br)", async () => {
  test.use({
    locale: "en",
  });

  test("should return correct translations and html attributes", async ({ page, users }) => {
    await test.step("should create a pt-br user", async () => {
      const user = await users.create({
        locale: "pt-br",
      });
      await user.apiLogin();
    });

    await test.step("should navigate to /event-types and show Brazil-Portuguese translations", async () => {
      await page.goto("/event-types");

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=pt-br]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "Tipos de Eventos", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Event Types", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should navigate to /bookings and show Brazil-Portuguese translations", async () => {
      await page.goto("/bookings");

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=pt-br]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "Reservas", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Bookings", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should reload the /bookings and show Brazil-Portuguese translations", async () => {
      await page.reload();

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=pt-br]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "Reservas", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Bookings", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });
  });
});

test.describe("authorized user sees correct translations (ar)", async () => {
  test.use({
    locale: "en",
  });

  test("should return correct translations and html attributes", async ({ page, users }) => {
    await test.step("should create a de user", async () => {
      const user = await users.create({
        locale: "ar",
      });
      await user.apiLogin();
    });

    await test.step("should navigate to /event-types and show Arabic translations", async () => {
      await page.goto("/event-types");

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=ar]").waitFor({ state: "attached" });
      await page.locator("html[dir=rtl]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "أنواع الحدث", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Event Types", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should navigate to /bookings and show Arabic translations", async () => {
      await page.goto("/bookings");

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=ar]").waitFor({ state: "attached" });
      await page.locator("html[dir=rtl]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "عمليات الحجز", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Bookings", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should reload the /bookings and show Arabic translations", async () => {
      await page.reload();

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=ar]").waitFor({ state: "attached" });
      await page.locator("html[dir=rtl]").waitFor({ state: "attached" });

      {
        const locator = page.getByRole("heading", { name: "عمليات الحجز", exact: true });
        await expect(locator).toHaveCount(1);
      }

      {
        const locator = page.getByText("Bookings", { exact: true });
        await expect(locator).toHaveCount(0);
      }
    });
  });
});

test.describe("authorized user sees changed translations (de->ar)", async () => {
  test.use({
    locale: "en",
  });

  test("should return correct translations and html attributes", async ({ page, users }) => {
    await test.step("should create a de user", async () => {
      const user = await users.create({
        locale: "de",
      });
      await user.apiLogin();
    });

    await test.step("should change the language and show Arabic translations", async () => {
      await page.goto("/settings/my-account/general");

      await page.waitForLoadState("domcontentloaded");

      await page.locator(".bg-default > div > div:nth-child(2)").first().click();
      await page.locator("#react-select-2-option-0").click();

      await page.getByRole("button", { name: "Aktualisieren" }).click();

      await page
        .getByRole("button", { name: "Einstellungen erfolgreich aktualisiert" })
        .waitFor({ state: "visible" });

      await page.locator("html[lang=ar]").waitFor({ state: "attached" });
      await page.locator("html[dir=rtl]").waitFor({ state: "attached" });

      {
        // at least one is visible
        const locator = page.getByText("عام", { exact: true }).last(); // "general"
        await expect(locator).toBeVisible();
      }

      {
        const locator = page.getByText("Allgemein", { exact: true }); // "general"
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should reload and show Arabic translations", async () => {
      await page.reload();

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=ar]").waitFor({ state: "attached" });
      await page.locator("html[dir=rtl]").waitFor({ state: "attached" });

      {
        const locator = page.getByText("عام", { exact: true }).last(); // "general"
        await expect(locator).toBeVisible();
      }

      {
        const locator = page.getByText("Allgemein", { exact: true }); // "general"
        await expect(locator).toHaveCount(0);
      }
    });
  });
});

test.describe("authorized user sees changed translations (de->pt-BR) [locale1]", async () => {
  test.use({
    locale: "en",
  });

  test("should return correct translations and html attributes", async ({ page, users }) => {
    await test.step("should create a de user", async () => {
      const user = await users.create({
        locale: "de",
      });
      await user.apiLogin();
    });

    await test.step("should change the language and show Brazil-Portuguese translations", async () => {
      await page.goto("/settings/my-account/general");

      await page.waitForLoadState("domcontentloaded");

      await page.locator(".bg-default > div > div:nth-child(2)").first().click();
      await page.locator("#react-select-2-option-14").click();

      await page.getByRole("button", { name: "Aktualisieren" }).click();

      await page
        .getByRole("button", { name: "Einstellungen erfolgreich aktualisiert" })
        .waitFor({ state: "visible" });

      await page.locator("html[lang=pt-BR]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByText("Geral", { exact: true }).last(); // "general"
        await expect(locator).toBeVisible();
      }

      {
        const locator = page.getByText("Allgemein", { exact: true }); // "general"
        await expect(locator).toHaveCount(0);
      }
    });

    await test.step("should reload and show Brazil-Portuguese translations", async () => {
      await page.reload();

      await page.waitForLoadState("domcontentloaded");

      await page.locator("html[lang=pt-BR]").waitFor({ state: "attached" });
      await page.locator("html[dir=ltr]").waitFor({ state: "attached" });

      {
        const locator = page.getByText("Geral", { exact: true }).last(); // "general"
        await expect(locator).toBeVisible();
      }

      {
        const locator = page.getByText("Allgemein", { exact: true }); // "general"
        await expect(locator).toHaveCount(0);
      }
    });
  });
});
import { expect } from "@playwright/test";
import { v4 as uuidv4 } from "uuid";

import dayjs from "@calcom/dayjs";
import { randomString } from "@calcom/lib/random";
import prisma from "@calcom/prisma";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });
test.afterEach(({ users }) => users.deleteAll());

test.describe("Out of office", () => {
  test("User can create out of office entry", async ({ page, users }) => {
    const user = await users.create({ name: "userOne" });

    await user.apiLogin();

    await page.goto("/settings/my-account/out-of-office");

    await page.locator("data-testid=create-entry-ooo-redirect").click();

    await expect(page.locator(`data-testid=table-redirect-n-a`)).toBeVisible();
  });

  test("User can configure booking redirect", async ({ page, users }) => {
    const user = await users.create({ name: "userOne" });

    const userTo = await users.create({ name: "userTwo" });

    const team = await prisma.team.create({
      data: {
        name: "test-insights",
        slug: `test-insights-${Date.now()}-${randomString(5)}}`,
      },
    });

    // create memberships
    await prisma.membership.createMany({
      data: [
        {
          userId: user.id,
          teamId: team.id,
          accepted: true,
          role: "ADMIN",
        },
        {
          userId: userTo.id,
          teamId: team.id,
          accepted: true,
          role: "ADMIN",
        },
      ],
    });

    await user.apiLogin();

    await page.goto(`/settings/my-account/out-of-office`);

    await page.getByTestId("profile-redirect-switch").click();
    await page
      .getByTestId("team_username_select")
      .locator("div")
      .filter({ hasText: "Select team member" })
      .first()
      .click();
    await page.locator("#react-select-2-option-0 div").click();

    // send request
    await page.getByTestId("create-entry-ooo-redirect").click();

    // expect table-redirect-toUserId to be visible
    await expect(page.locator(`data-testid=table-redirect-${userTo.username}`)).toBeVisible();
  });

  test("Profile redirection", async ({ page, users }) => {
    const user = await users.create({ name: "userOne" });

    const userTo = await users.create({ name: "userTwo" });

    const uuid = uuidv4();
    await prisma.outOfOfficeEntry.create({
      data: {
        start: dayjs().startOf("day").toDate(),
        end: dayjs().startOf("day").add(1, "w").toDate(),
        uuid,
        user: { connect: { id: user.id } },
        toUser: { connect: { id: userTo.id } },
        createdAt: new Date(),
      },
    });

    await page.goto(`/${user.username}`);

    await page.waitForLoadState("networkidle");

    // regex to match username
    expect(page.url()).toMatch(new RegExp(`/${userTo.username}`));

    await page.goto(`/${userTo.username}/30-min`);

    expect(page.url()).toMatch(new RegExp(`/${userTo.username}/30-min`));
  });
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";

test.describe.configure({ mode: "parallel" });

const ensureAppDir = async (page: Page) => {
  const dataNextJsRouter = await page.evaluate(() =>
    window.document.documentElement.getAttribute("data-nextjs-router")
  );

  expect(dataNextJsRouter).toEqual("app");
};

testBothFutureAndLegacyRoutes.describe("apps/ A/B tests", (routeVariant) => {
  test("should render the /apps/installed/[category]", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/apps/installed/messaging");

    const locator = page.getByRole("heading", { name: "Messaging" });

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toBeVisible();
  });

  test("should render the /apps/[slug]", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/apps/telegram");

    const locator = page.getByRole("heading", { name: "Telegram" });

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toBeVisible();
  });

  test("should render the /apps/[slug]/setup", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/apps/apple-calendar/setup");

    const locator = page.getByRole("heading", { name: "Connect to Apple Server" });

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toBeVisible();
  });

  test("should render the /apps/categories", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/apps/categories");

    const locator = page.getByTestId("app-store-category-messaging");

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toBeVisible();
  });

  test("should render the /apps/categories/[category]", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/apps/categories/messaging");

    const locator = page.getByText(/messaging apps/i);

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toBeVisible();
  });

  test("should render the /bookings/[status]", async ({ page, users }) => {
    const user = await users.create();

    await user.apiLogin();

    await page.goto("/bookings/upcoming/");

    const locator = page.getByTestId("horizontal-tab-upcoming");

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toHaveClass(/bg-emphasis/);
  });

  test("should render the /getting-started", async ({ page, users }) => {
    const user = await users.create({ completedOnboarding: false, name: null });

    await user.apiLogin();

    await page.goto("/getting-started/connected-calendar");

    const locator = page.getByText("Apple Calendar");

    if (routeVariant === "future") {
      await ensureAppDir(page);
    }

    await expect(locator).toBeVisible();
  });
});
import { expect } from "@playwright/test";
import type Prisma from "@prisma/client";

import prisma from "@calcom/prisma";
import { SchedulingType } from "@calcom/prisma/enums";
import { EventTypeMetaDataSchema } from "@calcom/prisma/zod-utils";

import { test } from "./lib/fixtures";
import type { Fixtures } from "./lib/fixtures";
import { todo, selectFirstAvailableTimeSlotNextMonth } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });
test.afterEach(({ users }) => users.deleteAll());

const IS_STRIPE_ENABLED = !!(
  process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY &&
  process.env.STRIPE_CLIENT_ID &&
  process.env.STRIPE_PRIVATE_KEY &&
  process.env.PAYMENT_FEE_FIXED &&
  process.env.PAYMENT_FEE_PERCENTAGE
);

test.describe("Stripe integration", () => {
  // eslint-disable-next-line playwright/no-skipped-test
  test.skip(!IS_STRIPE_ENABLED, "It should only run if Stripe is installed");

  test.describe("Stripe integration dashboard", () => {
    test("Can add Stripe integration", async ({ page, users }) => {
      const user = await users.create();
      await user.apiLogin();
      await page.goto("/apps/installed");

      await user.getPaymentCredential();

      await expect(page.locator(`h3:has-text("Stripe")`)).toBeVisible();
      await page.getByRole("list").getByRole("button").click();
      await expect(page.getByRole("button", { name: "Remove App" })).toBeVisible();
    });
  });

  test("when enabling Stripe, credentialId is included", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();
    await page.goto("/apps/installed");

    await user.getPaymentCredential();

    const eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
    await user.setupEventWithPrice(eventType, "stripe");

    // Need to wait for the DB to be updated with the metadata
    await page.waitForResponse((res) => res.url().includes("update") && res.status() === 200);

    // Check event type metadata to see if credentialId is included
    const eventTypeMetadata = await prisma.eventType.findFirst({
      where: {
        id: eventType.id,
      },
      select: {
        metadata: true,
      },
    });

    const metadata = EventTypeMetaDataSchema.parse(eventTypeMetadata?.metadata);

    const stripeAppMetadata = metadata?.apps?.stripe;

    expect(stripeAppMetadata).toHaveProperty("credentialId");
    expect(typeof stripeAppMetadata?.credentialId).toBe("number");
  });

  test("when enabling Stripe, team credentialId is included", async ({ page, users }) => {
    const ownerObj = { username: "pro-user", name: "pro-user" };

    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(ownerObj, {
      hasTeam: true,
      teammates: teamMatesObj,
      schedulingType: SchedulingType.COLLECTIVE,
    });
    await owner.apiLogin();

    const { team } = await owner.getFirstTeamMembership();

    const { title: teamEventTitle, slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);

    const teamEvent = await owner.getFirstTeamEvent(team.id);

    await page.goto("/apps/stripe");

    /** We start the Stripe flow */
    await Promise.all([
      page.waitForURL("https://connect.stripe.com/oauth/v2/authorize?*"),
      page.click('[data-testid="install-app-button"]'),
      page.click('[data-testid="anything else"]'),
    ]);

    await Promise.all([
      page.waitForURL("/apps/installed/payment?hl=stripe"),
      /** We skip filling Stripe forms (testing mode only) */
      page.click('[id="skip-account-app"]'),
    ]);

    await owner.setupEventWithPrice(teamEvent, "stripe");

    // Need to wait for the DB to be updated with the metadata
    await page.waitForResponse((res) => res.url().includes("update") && res.status() === 200);

    // Check event type metadata to see if credentialId is included
    const eventTypeMetadata = await prisma.eventType.findFirst({
      where: {
        id: teamEvent.id,
      },
      select: {
        metadata: true,
      },
    });

    const metadata = EventTypeMetaDataSchema.parse(eventTypeMetadata?.metadata);

    const stripeAppMetadata = metadata?.apps?.stripe;

    expect(stripeAppMetadata).toHaveProperty("credentialId");
    expect(typeof stripeAppMetadata?.credentialId).toBe("number");
  });

  test("Can book a paid booking", async ({ page, users }) => {
    const user = await users.create();

    const eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
    await user.apiLogin();
    await page.goto("/apps/installed");

    await user.getPaymentCredential();
    await user.setupEventWithPrice(eventType, "stripe");
    await user.bookAndPayEvent(eventType);
    // success
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();
  });

  test("Pending payment booking should not be confirmed by default", async ({ page, users }) => {
    const user = await users.create();

    const eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
    await user.apiLogin();
    await page.goto("/apps/installed");

    await user.getPaymentCredential();
    await user.setupEventWithPrice(eventType, "stripe");

    // booking process without payment
    await page.goto(`${user.username}/${eventType?.slug}`);
    await selectFirstAvailableTimeSlotNextMonth(page);
    // --- fill form
    await page.fill('[name="name"]', "Stripe Stripeson");
    await page.fill('[name="email"]', "test@example.com");

    await Promise.all([page.waitForURL("/payment/*"), page.press('[name="email"]', "Enter")]);

    await page.goto(`/bookings/upcoming`);

    await expect(page.getByText("Unconfirmed")).toBeVisible();
    await expect(page.getByText("Pending payment").last()).toBeVisible();
  });

  test("Paid booking should be able to be rescheduled", async ({ page, users }) => {
    const user = await users.create();

    const eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
    await user.apiLogin();
    await page.goto("/apps/installed");

    await user.getPaymentCredential();
    await user.setupEventWithPrice(eventType, "stripe");
    await user.bookAndPayEvent(eventType);

    // Rescheduling the event
    await Promise.all([page.waitForURL("/booking/*"), page.click('[data-testid="reschedule-link"]')]);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await Promise.all([
      page.waitForURL("/payment/*"),
      page.click('[data-testid="confirm-reschedule-button"]'),
    ]);

    await user.makePaymentUsingStripe();
  });

  test("Paid booking should be able to be cancelled", async ({ page, users }) => {
    const user = await users.create();

    const eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
    await user.apiLogin();
    await page.goto("/apps/installed");

    await user.getPaymentCredential();
    await user.setupEventWithPrice(eventType, "stripe");
    await user.bookAndPayEvent(eventType);

    await page.click('[data-testid="cancel"]');
    await page.click('[data-testid="confirm_cancel"]');

    await expect(await page.locator('[data-testid="cancelled-headline"]').first()).toBeVisible();
  });

  test.describe("When event is paid and confirmed", () => {
    let user: Awaited<ReturnType<Fixtures["users"]["create"]>>;

    let eventType: Prisma.EventType;

    test.beforeEach(async ({ page, users }) => {
      user = await users.create();
      eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
      await user.apiLogin();
      await page.goto("/apps/installed");

      await user.getPaymentCredential();
      await user.setupEventWithPrice(eventType, "stripe");
      await user.bookAndPayEvent(eventType);
      await user.confirmPendingPayment();
    });

    test("Cancelled paid booking should be refunded", async ({ page, users, request }) => {
      await page.click('[data-testid="cancel"]');
      await page.click('[data-testid="confirm_cancel"]');

      await expect(await page.locator('[data-testid="cancelled-headline"]').first()).toBeVisible();
      await expect(page.getByText("This booking payment has been refunded")).toBeVisible();
    });

    test("Payment should confirm pending payment booking", async ({ page, users }) => {
      await page.goto("/bookings/upcoming");

      const paidBadge = page.locator('[data-testid="paid_badge"]').first();

      await expect(paidBadge).toBeVisible();
      expect(await paidBadge.innerText()).toBe("Paid");
    });

    test("Paid and confirmed booking should be able to be rescheduled", async ({ page, users }) => {
      await Promise.all([page.waitForURL("/booking/*"), page.click('[data-testid="reschedule-link"]')]);

      await selectFirstAvailableTimeSlotNextMonth(page);

      await page.click('[data-testid="confirm-reschedule-button"]');

      await expect(page.getByText("This meeting is scheduled")).toBeVisible();
    });

    todo("Payment should trigger a BOOKING_PAID webhook");
  });

  test.describe("Change stripe presented currency", () => {
    test("Should be able to change currency", async ({ page, users }) => {
      const user = await users.create();
      const eventType = user.eventTypes.find((e) => e.slug === "paid") as Prisma.EventType;
      await user.apiLogin();

      await user.getPaymentCredential();

      // Edit currency inside event type page
      await page.goto(`/event-types/${eventType?.id}?tabName=apps`);

      // Enable Stripe
      await page.locator("#event-type-form").getByRole("switch").click();

      // Set price
      await page.getByTestId("stripe-price-input").fill("200");

      // Select currency in dropdown
      await page.getByTestId("stripe-currency-select").click();
      await page.locator("#react-select-2-input").fill("mexi");
      await page.locator("#react-select-2-option-81").click();

      await page.getByTestId("update-eventtype").click();

      // Book event
      await page.goto(`${user.username}/${eventType?.slug}`);

      // Confirm MXN currency it's displayed use expect
      await expect(await page.getByText("MX$200.00")).toBeVisible();

      await selectFirstAvailableTimeSlotNextMonth(page);

      // Confirm again in book form page
      await expect(await page.getByText("MX$200.00")).toBeVisible();

      // --- fill form
      await page.fill('[name="name"]', "Stripe Stripeson");
      await page.fill('[name="email"]', "stripe@example.com");

      // Confirm booking
      await page.click('[data-testid="confirm-book-button"]');

      // wait for url to be payment
      await page.waitForURL("/payment/*");

      // Confirm again in book form page
      await expect(await page.getByText("MX$200.00")).toBeVisible();
    });
  });
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";

import { IS_TEAM_BILLING_ENABLED } from "@calcom/lib/constants";

import { test } from "./lib/fixtures";
import {
  bookTimeSlot,
  fillStripeTestCheckout,
  localize,
  selectFirstAvailableTimeSlotNextMonth,
} from "./lib/testUtils";

test.afterEach(({ users }) => users.deleteAll());

test.describe("Managed Event Types tests", () => {
  test("Can create managed event type", async ({ page, users }) => {
    // Creating the owner user of the team
    const adminUser = await users.create();
    // Creating the member user of the team
    const memberUser = await users.create();
    // First we work with owner user, logging in
    await adminUser.apiLogin();

    // Let's create a team
    await page.goto("/settings/teams/new");

    await test.step("Managed event option exists for team admin", async () => {
      // Filling team creation form wizard
      await page.locator('input[name="name"]').fill(`${adminUser.username}'s Team`);
      await page.click("[type=submit]");
      // TODO: Figure out a way to make this more reliable
      // eslint-disable-next-line playwright/no-conditional-in-test
      if (IS_TEAM_BILLING_ENABLED) await fillStripeTestCheckout(page);
      await page.waitForURL(/\/settings\/teams\/(\d+)\/onboard-members.*$/i);
      await page.getByTestId("new-member-button").click();
      await page.locator('[placeholder="email\\@example\\.com"]').fill(`${memberUser.username}@example.com`);
      await page.getByTestId("invite-new-member-button").click();
      // wait for the second member to be added to the pending-member-list.
      await page.getByTestId("pending-member-list").locator("li:nth-child(2)").waitFor();
      // and publish
      await page.locator("[data-testid=publish-button]").click();
      await expect(page).toHaveURL(/\/settings\/teams\/(\d+)\/profile$/i);
      // Going to create an event type
      await page.goto("/event-types");
      await page.getByTestId("new-event-type").click();
      await page.getByTestId("option-team-1").click();
      // Expecting we can add a managed event type as team owner
      await expect(page.locator('button[value="MANAGED"]')).toBeVisible();

      // Actually creating a managed event type to test things further
      await page.click('button[value="MANAGED"]');
      await page.fill("[name=title]", "managed");
      await page.click("[type=submit]");

      await page.waitForURL("event-types/**");
    });

    await test.step("Managed event type has unlocked fields for admin", async () => {
      await page.getByTestId("update-eventtype").waitFor();
      await expect(page.locator('input[name="title"]')).toBeEditable();
      await expect(page.locator('input[name="slug"]')).toBeEditable();
      await expect(page.locator('input[name="length"]')).toBeEditable();
      await adminUser.logout();
    });

    await test.step("Managed event type exists for added member", async () => {
      // Now we need to accept the invitation as member and come back in as admin to
      // assign the member in the managed event type
      await memberUser.apiLogin();

      await page.goto("/teams");
      await page.locator('button[data-testid^="accept-invitation"]').click();
      await page.getByText("Member").waitFor();

      await memberUser.logout();

      // Coming back as team owner to assign member user to managed event
      await adminUser.apiLogin();
      await page.goto("/event-types");
      await page.getByTestId("event-types").locator('a[title="managed"]').click();
      await page.getByTestId("vertical-tab-assignment").click();
      await page.getByTestId("assignment-dropdown").click();

      await page.getByTestId(`select-option-${memberUser.id}`).click();
      await page.locator('[type="submit"]').click();
      await page.getByTestId("toast-success").waitFor();
    });

    await test.step("Managed event type can use Organizer's default app as location", async () => {
      await page.getByTestId("vertical-tab-event_setup_tab_title").click();

      await page.locator("#location-select").click();
      const optionText = (await localize("en"))("organizer_default_conferencing_app");
      await page.locator(`text=${optionText}`).click();
      await page.locator("[data-testid=update-eventtype]").click();
      await page.getByTestId("toast-success").waitFor();
      await page.waitForLoadState("networkidle");

      await page.getByTestId("vertical-tab-assignment").click();
      await gotoBookingPage(page);
      await selectFirstAvailableTimeSlotNextMonth(page);
      await bookTimeSlot(page);

      await expect(page.getByTestId("success-page")).toBeVisible();
    });

    await test.step("Managed event type has locked fields for added member", async () => {
      await adminUser.logout();

      // Coming back as member user to see if there is a managed event present after assignment
      await memberUser.apiLogin();
      await page.goto("/event-types");

      await page.getByTestId("event-types").locator('a[title="managed"]').click();
      await page.waitForURL("event-types/**");

      await expect(page.locator('input[name="title"]')).not.toBeEditable();
      await expect(page.locator('input[name="slug"]')).not.toBeEditable();
      await expect(page.locator('input[name="length"]')).not.toBeEditable();
    });
  });
});

async function gotoBookingPage(page: Page) {
  const previewLink = await page.getByTestId("preview-button").getAttribute("href");

  await page.goto(previewLink ?? "");
}
import type { Locator, Page, PlaywrightTestArgs } from "@playwright/test";
import { expect } from "@playwright/test";
import type { createUsersFixture } from "playwright/fixtures/users";
import { uuid } from "short-uuid";

import prisma from "@calcom/prisma";
import { WebhookTriggerEvents } from "@calcom/prisma/enums";
import type { CalendarEvent } from "@calcom/types/Calendar";

import { test } from "./lib/fixtures";
import { createHttpServer, selectFirstAvailableTimeSlotNextMonth } from "./lib/testUtils";

async function getLabelText(field: Locator) {
  return await field.locator("label").first().locator("span").first().innerText();
}

test.describe.configure({ mode: "parallel" });
test.describe("Manage Booking Questions", () => {
  test.afterEach(async ({ users }) => {
    await users.deleteAll();
  });

  test.describe("For User EventType", () => {
    test("Do a booking with a user added question and verify a few thing in b/w", async ({
      page,
      users,
      context,
    }, testInfo) => {
      // Considering there are many steps in it, it would need more than default test timeout
      test.setTimeout(testInfo.timeout * 3);
      const user = await createAndLoginUserWithEventTypes({ users, page });

      const webhookReceiver = await addWebhook(user);

      await test.step("Go to EventType Page ", async () => {
        const $eventTypes = page.locator("[data-testid=event-types] > li a");

        const firstEventTypeElement = $eventTypes.first();

        await firstEventTypeElement.click();
      });

      await runTestStepsCommonForTeamAndUserEventType(page, context, webhookReceiver);
    });

    test("Split 'Full name' into 'First name' and 'Last name'", async ({
      page,
      users,
      context,
    }, testInfo) => {
      // Considering there are many steps in it, it would need more than default test timeout
      test.setTimeout(testInfo.timeout * 3);
      const user = await createAndLoginUserWithEventTypes({ page, users });
      const webhookReceiver = await addWebhook(user);
      await test.step("Go to first EventType Page ", async () => {
        const $eventTypes = page.locator("[data-testid=event-types] > li a");

        const firstEventTypeElement = $eventTypes.first();

        await firstEventTypeElement.click();
      });

      await test.step("Open the 'Name' field dialog", async () => {
        await page.click('[href$="tabName=advanced"]');
        await page.locator('[data-testid="field-name"] [data-testid="edit-field-action"]').click();
      });

      await test.step("Toggle on the variant toggle and save Event Type", async () => {
        await page.click('[data-testid="variant-toggle"]');
        await page.click("[data-testid=field-add-save]");
        await saveEventType(page);
      });

      await test.step("Book a time slot with firstName and lastName provided separately", async () => {
        await doOnFreshPreview(page, context, async (page) => {
          await expectSystemFieldsToBeThereOnBookingPage({ page, isFirstAndLastNameVariant: true });
          await bookTimeSlot({
            page,
            name: { firstName: "John", lastName: "Doe" },
            email: "booker@example.com",
          });
          await expect(page.locator("[data-testid=success-page]")).toBeVisible();
          expect(await page.locator('[data-testid="attendee-name-John Doe"]').nth(0).textContent()).toBe(
            "John Doe"
          );
          await expectWebhookToBeCalled(webhookReceiver, {
            triggerEvent: WebhookTriggerEvents.BOOKING_CREATED,
            payload: {
              attendees: [
                {
                  // It would have full Name only
                  name: "John Doe",
                  email: "booker@example.com",
                },
              ],
              responses: {
                name: {
                  label: "your_name",
                  value: {
                    firstName: "John",
                    lastName: "Doe",
                  },
                },
                email: {
                  label: "email_address",
                  value: "booker@example.com",
                },
              },
            },
          });
        });
      });

      await test.step("Verify that we can prefill name and other fields correctly", async () => {
        await doOnFreshPreview(page, context, async (page) => {
          const url = page.url();
          const prefillUrl = new URL(url);
          prefillUrl.searchParams.append("name", "John Johny Janardan");
          prefillUrl.searchParams.append("email", "john@example.com");
          prefillUrl.searchParams.append("guests", "guest1@example.com");
          prefillUrl.searchParams.append("guests", "guest2@example.com");
          prefillUrl.searchParams.append("notes", "This is an additional note");
          await page.goto(prefillUrl.toString());
          await bookTimeSlot({ page, skipSubmission: true });
          await expectSystemFieldsToBeThereOnBookingPage({
            page,
            isFirstAndLastNameVariant: true,
            values: {
              name: {
                firstName: "John",
                lastName: "Johny Janardan",
              },
              email: "john@example.com",
              guests: ["guest1@example.com", "guest2@example.com"],
              notes: "This is an additional note",
            },
          });
        });
      });

      await test.step("Verify that we can prefill name field with no lastname", async () => {
        const searchParams = new URLSearchParams();
        searchParams.append("name", "FirstName");
        await doOnFreshPreviewWithSearchParams(searchParams, page, context, async (page) => {
          await selectFirstAvailableTimeSlotNextMonth(page);
          await expectSystemFieldsToBeThereOnBookingPage({
            page,
            isFirstAndLastNameVariant: true,
            values: {
              name: {
                firstName: "FirstName",
                lastName: "",
              },
            },
          });
        });
      });

      await test.step("Verify that we can prefill name field with firstName,lastName query params", async () => {
        const searchParams = new URLSearchParams();
        searchParams.append("firstName", "John");
        searchParams.append("lastName", "Doe");
        await doOnFreshPreviewWithSearchParams(searchParams, page, context, async (page) => {
          await selectFirstAvailableTimeSlotNextMonth(page);
          await expectSystemFieldsToBeThereOnBookingPage({
            page,
            isFirstAndLastNameVariant: true,
            values: {
              name: {
                firstName: "John",
                lastName: "Doe",
              },
            },
          });
        });
      });
    });
  });

  test.describe("For Team EventType", () => {
    test("Do a booking with a user added question and verify a few thing in b/w", async ({
      page,
      users,
      context,
    }, testInfo) => {
      // Considering there are many steps in it, it would need more than default test timeout
      test.setTimeout(testInfo.timeout * 3);
      const user = await createAndLoginUserWithEventTypes({ users, page });
      const team = await prisma.team.findFirst({
        where: {
          members: {
            some: {
              userId: user.id,
            },
          },
        },
        select: {
          id: true,
        },
      });

      const teamId = team?.id;
      const webhookReceiver = await addWebhook(undefined, teamId);

      await test.step("Go to First Team Event", async () => {
        const $eventTypes = page.locator("[data-testid=event-types]").nth(1).locator("li a");

        const firstEventTypeElement = $eventTypes.first();

        await firstEventTypeElement.click();
      });

      await runTestStepsCommonForTeamAndUserEventType(page, context, webhookReceiver);
    });
  });
});

async function runTestStepsCommonForTeamAndUserEventType(
  page: Page,
  context: PlaywrightTestArgs["context"],
  webhookReceiver: Awaited<ReturnType<typeof addWebhook>>
) {
  await page.click('[href$="tabName=advanced"]');

  await test.step("Check that all the system questions are shown in the list", async () => {
    await page.locator("[data-testid=field-name]").isVisible();
    await page.locator("[data-testid=field-email]").isVisible();
    await page.locator("[data-testid=field-notes]").isVisible();
    await page.locator("[data-testid=field-guests]").isVisible();
    await page.locator("[data-testid=field-rescheduleReason]").isVisible();
    // It is conditional
    // await page.locator("data-testid=field-location").isVisible();
  });

  await test.step("Add Question and see that it's shown on Booking Page at appropriate position", async () => {
    await addQuestionAndSave({
      page,
      question: {
        name: "how-are-you",
        type: "Address",
        label: "How are you?",
        placeholder: "I'm fine, thanks",
        required: true,
      },
    });

    await doOnFreshPreview(page, context, async (page) => {
      const allFieldsLocator = await expectSystemFieldsToBeThereOnBookingPage({ page });
      const userFieldLocator = allFieldsLocator.nth(5);

      await expect(userFieldLocator.locator('[name="how-are-you"]')).toBeVisible();
      // There are 2 labels right now. Will be one in future. The second one is hidden
      expect(await getLabelText(userFieldLocator)).toBe("How are you?");
      await expect(userFieldLocator.locator("input")).toBeVisible();
    });
  });

  await test.step("Hide Question and see that it's not shown on Booking Page", async () => {
    await toggleQuestionAndSave({
      name: "how-are-you",
      page,
    });
    await doOnFreshPreview(page, context, async (page) => {
      const formBuilderFieldLocator = page.locator('[data-fob-field-name="how-are-you"]');
      await expect(formBuilderFieldLocator).toBeHidden();
    });
  });

  await test.step("Show Question Again", async () => {
    await toggleQuestionAndSave({
      name: "how-are-you",
      page,
    });
  });

  await test.step('Try to book without providing "How are you?" response', async () => {
    await doOnFreshPreview(page, context, async (page) => {
      await bookTimeSlot({ page, name: "Booker", email: "booker@example.com" });
      await expectErrorToBeThereFor({ page, name: "how-are-you" });
    });
  });

  await test.step("Make rescheduleReason required - It won't be required for a fresh booking", async () => {
    await toggleQuestionRequireStatusAndSave({
      required: true,
      name: "rescheduleReason",
      page,
    });
  });

  const previewTabPage =
    await test.step("Do a booking and notice that we can book without giving a value for rescheduleReason", async () => {
      return await doOnFreshPreview(
        page,
        context,
        async (page) => {
          const formBuilderFieldLocator = page.locator('[data-fob-field-name="how-are-you"]');
          await expect(formBuilderFieldLocator).toBeVisible();
          expect(
            await formBuilderFieldLocator.locator('[name="how-are-you"]').getAttribute("placeholder")
          ).toBe("I'm fine, thanks");
          expect(await getLabelText(formBuilderFieldLocator)).toBe("How are you?");
          await formBuilderFieldLocator.locator('[name="how-are-you"]').fill("I am great!");
          await bookTimeSlot({ page, name: "Booker", email: "booker@example.com" });
          await expect(page.locator("[data-testid=success-page]")).toBeVisible();

          expect(
            await page.locator('[data-testid="field-response"][data-fob-field="how-are-you"]').innerText()
          ).toBe("I am great!");

          await webhookReceiver.waitForRequestCount(1);

          const [request] = webhookReceiver.requestList;

          // @ts-expect-error body is unknown
          const payload = request.body.payload;

          expect(payload.responses).toMatchObject({
            email: {
              label: "email_address",
              value: "booker@example.com",
            },
            "how-are-you": {
              label: "How are you?",
              value: "I am great!",
            },
            name: {
              label: "your_name",
              value: "Booker",
            },
          });

          expect(payload.attendees[0]).toMatchObject({
            name: "Booker",
            email: "booker@example.com",
          });

          expect(payload.userFieldsResponses).toMatchObject({
            "how-are-you": {
              label: "How are you?",
              value: "I am great!",
            },
          });
        },
        true
      );
    });

  await test.step("Do a reschedule and notice that we can't book without giving a value for rescheduleReason", async () => {
    const page = previewTabPage;
    await rescheduleFromTheLinkOnPage({ page });
    await expectErrorToBeThereFor({ page, name: "rescheduleReason" });
  });
}

async function expectSystemFieldsToBeThereOnBookingPage({
  page,
  isFirstAndLastNameVariant,
  values,
}: {
  page: Page;
  isFirstAndLastNameVariant?: boolean;
  values?: Partial<{
    name: {
      firstName?: string;
      lastName?: string;
      fullName?: string;
    };
    email: string;
    notes: string;
    guests: string[];
  }>;
}) {
  const allFieldsLocator = page.locator("[data-fob-field-name]:not(.hidden)");
  const nameLocator = allFieldsLocator.nth(0);
  const emailLocator = allFieldsLocator.nth(1);
  // Location isn't rendered unless explicitly set which isn't the case here
  // const locationLocator = allFieldsLocator.nth(2);
  const additionalNotes = allFieldsLocator.nth(3);
  const guestsLocator = allFieldsLocator.nth(4);

  if (isFirstAndLastNameVariant) {
    if (values?.name) {
      await expect(nameLocator.locator('[name="firstName"]')).toHaveValue(values?.name?.firstName || "");
      await expect(nameLocator.locator('[name="lastName"]')).toHaveValue(values?.name?.lastName || "");
      expect(await nameLocator.locator(".testid-firstName > label").innerText()).toContain("*");
    } else {
      await expect(nameLocator.locator('[name="firstName"]')).toBeVisible();
      await expect(nameLocator.locator('[name="lastName"]')).toBeVisible();
    }
  } else {
    if (values?.name) {
      await expect(nameLocator.locator('[name="name"]')).toHaveValue(values?.name?.fullName || "");
    }
    await expect(nameLocator.locator('[name="name"]')).toBeVisible();
    expect(await nameLocator.locator("label").innerText()).toContain("*");
  }

  if (values?.email) {
    await expect(emailLocator.locator('[name="email"]')).toHaveValue(values?.email || "");
  } else {
    await expect(emailLocator.locator('[name="email"]')).toBeVisible();
  }

  if (values?.notes) {
    await expect(additionalNotes.locator('[name="notes"]')).toHaveValue(values?.notes);
  } else {
    await expect(additionalNotes.locator('[name="notes"]')).toBeVisible();
  }

  if (values?.guests) {
    const allGuestsLocators = guestsLocator.locator('[type="email"]');

    for (let i = 0; i < values.guests.length; i++) {
      await expect(allGuestsLocators.nth(i)).toHaveValue(values.guests[i] || "");
    }
    await expect(guestsLocator.locator("[data-testid='add-another-guest']")).toBeVisible();
  } else {
    await expect(guestsLocator.locator("[data-testid='add-guests']")).toBeVisible();
  }
  return allFieldsLocator;
}

//TODO: Add one question for each type and see they are rendering labels and only once and are showing appropriate native component
// Verify webhook is sent with the correct data, DB is correct (including metadata)

//TODO: Verify that prefill works
async function bookTimeSlot({
  page,
  name,
  email,
  skipSubmission = false,
}: {
  page: Page;
  name?: string | { firstName: string; lastName?: string };
  email?: string;
  skipSubmission?: boolean;
}) {
  if (name) {
    if (typeof name === "string") {
      await page.fill('[name="name"]', name);
    } else {
      await page.fill('[name="firstName"]', name.firstName);
      if (name.lastName) {
        await page.fill('[name="lastName"]', name.lastName);
      }
    }
  }
  if (email) {
    await page.fill('[name="email"]', email);
  }
  if (!skipSubmission) {
    await page.press('[name="email"]', "Enter");
  }
}

/**
 * 'option' starts from 1
 */
async function selectOption({
  page,
  selector,
  optionText,
}: {
  page: Page;
  selector: { selector: string; nth: number };
  optionText: string;
}) {
  const locatorForSelect = page.locator(selector.selector).nth(selector.nth);
  await locatorForSelect.click();
  await locatorForSelect.locator(`text="${optionText}"`).click();
}

async function addQuestionAndSave({
  page,
  question,
}: {
  page: Page;
  question: {
    name?: string;
    type?: string;
    label?: string;
    placeholder?: string;
    required?: boolean;
  };
}) {
  await page.click('[data-testid="add-field"]');

  if (question.type !== undefined) {
    await selectOption({
      page,
      selector: {
        selector: "[id=test-field-type]",
        nth: 0,
      },
      optionText: question.type,
    });
  }

  if (question.name !== undefined) {
    await page.fill('[name="name"]', question.name);
  }

  if (question.label !== undefined) {
    await page.fill('[name="label"]', question.label);
  }

  if (question.placeholder !== undefined) {
    await page.fill('[name="placeholder"]', question.placeholder);
  }

  if (question.required !== undefined) {
    // await page.fill('[name="name"]', question.required);
  }

  await page.click('[data-testid="field-add-save"]');
  await saveEventType(page);
}

async function expectErrorToBeThereFor({ page, name }: { page: Page; name: string }) {
  await expect(page.locator(`[data-testid=error-message-${name}]`)).toHaveCount(1);
  // TODO: We should either verify the error message or error code in the test so we know that the correct error is shown
  // Checking for the error message isn't well maintainable as translation can change and we might want to verify in non english language as well.
}

/**
 * Opens a fresh preview window and runs the callback on it giving it the preview tab's `page`
 */
async function doOnFreshPreview(
  page: Page,
  context: PlaywrightTestArgs["context"],
  callback: (page: Page) => Promise<void>,
  persistTab = false
) {
  const previewTabPage = await openBookingFormInPreviewTab(context, page);
  await callback(previewTabPage);
  if (!persistTab) {
    await previewTabPage.close();
  }
  return previewTabPage;
}

async function doOnFreshPreviewWithSearchParams(
  searchParams: URLSearchParams,
  page: Page,
  context: PlaywrightTestArgs["context"],
  callback: (page: Page) => Promise<void>,
  persistTab = false
) {
  const previewUrl = (await page.locator('[data-testid="preview-button"]').getAttribute("href")) || "";
  const previewUrlObj = new URL(previewUrl);
  searchParams.forEach((value, key) => {
    previewUrlObj.searchParams.append(key, value);
  });
  const previewTabPage = await context.newPage();
  await previewTabPage.goto(previewUrlObj.toString());
  await callback(previewTabPage);
  if (!persistTab) {
    await previewTabPage.close();
  }
  return previewTabPage;
}

async function toggleQuestionAndSave({ name, page }: { name: string; page: Page }) {
  await page.locator(`[data-testid="field-${name}"]`).locator('[data-testid="toggle-field"]').click();
  await saveEventType(page);
}

async function toggleQuestionRequireStatusAndSave({
  required,
  name,
  page,
}: {
  required: boolean;
  name: string;
  page: Page;
}) {
  await page.locator(`[data-testid="field-${name}"]`).locator('[data-testid="edit-field-action"]').click();
  await page
    .locator('[data-testid="edit-field-dialog"]')
    .locator('[data-testid="field-required"] button')
    .locator(`text=${required ? "Yes" : "No"}`)
    .click();
  await page.locator('[data-testid="field-add-save"]').click();
  await saveEventType(page);
}

async function createAndLoginUserWithEventTypes({
  users,
  page,
}: {
  users: ReturnType<typeof createUsersFixture>;
  page: Page;
}) {
  const user = await users.create(null, {
    hasTeam: true,
  });
  await user.apiLogin();
  await page.goto("/event-types");
  // We wait until loading is finished
  await page.waitForSelector('[data-testid="event-types"]');
  return user;
}

async function rescheduleFromTheLinkOnPage({ page }: { page: Page }) {
  await page.locator('[data-testid="reschedule-link"]').click();
  await page.waitForLoadState();
  await selectFirstAvailableTimeSlotNextMonth(page);
  await page.click('[data-testid="confirm-reschedule-button"]');
}

async function openBookingFormInPreviewTab(context: PlaywrightTestArgs["context"], page: Page) {
  const previewTabPromise = context.waitForEvent("page");
  await page.locator('[data-testid="preview-button"]').click();
  const previewTabPage = await previewTabPromise;
  await previewTabPage.waitForLoadState();
  await selectFirstAvailableTimeSlotNextMonth(previewTabPage);
  return previewTabPage;
}

async function saveEventType(page: Page) {
  await page.locator("[data-testid=update-eventtype]").click();
}

async function addWebhook(
  user?: Awaited<ReturnType<typeof createAndLoginUserWithEventTypes>>,
  teamId?: number | null
) {
  const webhookReceiver = createHttpServer();

  const data: {
    id: string;
    subscriberUrl: string;
    eventTriggers: WebhookTriggerEvents[];
    userId?: number;
    teamId?: number;
  } = {
    id: uuid(),
    subscriberUrl: webhookReceiver.url,
    eventTriggers: [
      WebhookTriggerEvents.BOOKING_CREATED,
      WebhookTriggerEvents.BOOKING_CANCELLED,
      WebhookTriggerEvents.BOOKING_RESCHEDULED,
    ],
  };

  if (teamId) {
    data.teamId = teamId;
  } else if (user) {
    data.userId = user.id;
  }

  await prisma.webhook.create({ data });

  return webhookReceiver;
}

async function expectWebhookToBeCalled(
  webhookReceiver: Awaited<ReturnType<typeof addWebhook>>,
  expectedBody: {
    triggerEvent: WebhookTriggerEvents;
    payload: Omit<Partial<CalendarEvent>, "attendees"> & {
      attendees: Partial<CalendarEvent["attendees"][number]>[];
    };
  }
) {
  await webhookReceiver.waitForRequestCount(1);
  const [request] = webhookReceiver.requestList;

  const body = request.body;

  expect(body).toMatchObject(expectedBody);
}
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });
test.afterEach(({ users }) => users.deleteAll());

test.describe("Login with api request", () => {
  test("context request will share cookie storage with its browser context", async ({ page, users }) => {
    const pro = await users.create();
    await pro.apiLogin();

    const contextCookies = await page.context().cookies();

    const cookiesMap = new Map(contextCookies.map(({ name, value }) => [name, value]));

    // The browser context will already contain all the cookies from the API response.
    expect(cookiesMap.has("next-auth.csrf-token")).toBeTruthy();
    expect(cookiesMap.has("next-auth.callback-url")).toBeTruthy();
    expect(cookiesMap.has("next-auth.session-token")).toBeTruthy();
  });
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";
import { Linter } from "eslint";
import { parse } from "node-html-parser";

import { getOrgFullOrigin } from "@calcom/features/ee/organizations/lib/orgDomains";
import { EMBED_LIB_URL, WEBAPP_URL } from "@calcom/lib/constants";
import { MembershipRole } from "@calcom/prisma/client";

import { test } from "./lib/fixtures";

const linter = new Linter();

const eslintRules = {
  "no-undef": "error",
  "no-unused-vars": "off",
} as const;
test.describe.configure({ mode: "parallel" });

test.afterEach(({ users }) => users.deleteAll());

test.describe("Embed Code Generator Tests", () => {
  test.describe("Non-Organization", () => {
    test.beforeEach(async ({ users }) => {
      const pro = await users.create();
      await pro.apiLogin();
    });

    test.describe("Event Types Page", () => {
      test.beforeEach(async ({ page }) => {
        await page.goto("/event-types");
      });

      test("open Embed Dialog and choose Inline for First Event Type", async ({ page, users }) => {
        const [pro] = users.get();

        const embedUrl = await clickFirstEventTypeEmbedButton(page);
        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage: "/event-types",
        });

        chooseEmbedType(page, "inline");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          embedType: "inline",
          basePage: "/event-types",
        });

        await expectToContainValidCode(page, {
          language: "html",
          embedType: "inline",
          orgSlug: null,
        });

        await goToReactCodeTab(page);
        await expectToContainValidCode(page, {
          language: "react",
          embedType: "inline",
          orgSlug: null,
        });

        await goToPreviewTab(page);

        await expectToContainValidPreviewIframe(page, {
          embedType: "inline",
          calLink: `${pro.username}/30-min`,
        });
      });

      test("open Embed Dialog and choose floating-popup for First Event Type", async ({ page, users }) => {
        const [pro] = users.get();

        const embedUrl = await clickFirstEventTypeEmbedButton(page);

        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage: "/event-types",
        });

        chooseEmbedType(page, "floating-popup");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          embedType: "floating-popup",
          basePage: "/event-types",
        });
        await expectToContainValidCode(page, {
          language: "html",
          embedType: "floating-popup",
          orgSlug: null,
        });

        await goToReactCodeTab(page);
        await expectToContainValidCode(page, {
          language: "react",
          embedType: "floating-popup",
          orgSlug: null,
        });

        await goToPreviewTab(page);
        await expectToContainValidPreviewIframe(page, {
          embedType: "floating-popup",
          calLink: `${pro.username}/30-min`,
        });
      });

      test("open Embed Dialog and choose element-click for First Event Type", async ({ page, users }) => {
        const [pro] = users.get();

        const embedUrl = await clickFirstEventTypeEmbedButton(page);

        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage: "/event-types",
        });

        chooseEmbedType(page, "element-click");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          embedType: "element-click",
          basePage: "/event-types",
        });
        await expectToContainValidCode(page, {
          language: "html",
          embedType: "element-click",
          orgSlug: null,
        });

        await goToReactCodeTab(page);
        await expectToContainValidCode(page, {
          language: "react",
          embedType: "element-click",
          orgSlug: null,
        });

        await goToPreviewTab(page);
        await expectToContainValidPreviewIframe(page, {
          embedType: "element-click",
          calLink: `${pro.username}/30-min`,
        });
      });
    });
    test.describe("Event Type Edit Page", () => {
      test.beforeEach(async ({ page }) => {
        await page.goto(`/event-types`);
        await Promise.all([
          page.locator('a[href*="/event-types/"]').first().click(),
          page.waitForURL((url) => url.pathname.startsWith("/event-types/")),
        ]);
      });

      test("open Embed Dialog for the Event Type", async ({ page }) => {
        const basePage = new URL(page.url()).pathname;

        const embedUrl = await clickEmbedButton(page);
        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage,
        });

        chooseEmbedType(page, "inline");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          basePage,
          embedType: "inline",
        });

        await expectToContainValidCode(page, {
          language: "html",
          embedType: "inline",
          orgSlug: null,
        });

        await goToPreviewTab(page);

        await expectToContainValidPreviewIframe(page, {
          embedType: "inline",
          calLink: decodeURIComponent(embedUrl),
        });
      });
    });
  });

  test.describe("Organization", () => {
    test.beforeEach(async ({ users, orgs }) => {
      const org = await orgs.create({
        name: "TestOrg",
      });
      const user = await users.create({
        organizationId: org.id,
        roleInOrganization: MembershipRole.MEMBER,
      });
      await user.apiLogin();
    });
    test.describe("Event Types Page", () => {
      test.beforeEach(async ({ page }) => {
        await page.goto("/event-types");
      });

      test("open Embed Dialog and choose Inline for First Event Type", async ({ page, users }) => {
        const [user] = users.get();

        const { team: org } = await user.getOrgMembership();

        const embedUrl = await clickFirstEventTypeEmbedButton(page);
        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage: "/event-types",
        });

        chooseEmbedType(page, "inline");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          embedType: "inline",
          basePage: "/event-types",
        });

        // Default tab is HTML code tab
        await expectToContainValidCode(page, {
          language: "html",
          embedType: "inline",
          orgSlug: org.slug,
        });

        await goToReactCodeTab(page);
        await expectToContainValidCode(page, {
          language: "react",
          embedType: "inline",
          orgSlug: org.slug,
        });

        await goToPreviewTab(page);
        await expectToContainValidPreviewIframe(page, {
          embedType: "inline",
          calLink: `${user.username}/30-min`,
          bookerUrl: getOrgFullOrigin(org?.slug ?? ""),
        });
      });

      test("open Embed Dialog and choose floating-popup for First Event Type", async ({ page, users }) => {
        const [user] = users.get();

        const { team: org } = await user.getOrgMembership();

        const embedUrl = await clickFirstEventTypeEmbedButton(page);

        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage: "/event-types",
        });

        chooseEmbedType(page, "floating-popup");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          embedType: "floating-popup",
          basePage: "/event-types",
        });
        await expectToContainValidCode(page, {
          language: "html",
          embedType: "floating-popup",
          orgSlug: org.slug,
        });

        await goToReactCodeTab(page);
        await expectToContainValidCode(page, {
          language: "react",
          embedType: "floating-popup",
          orgSlug: org.slug,
        });

        await goToPreviewTab(page);
        await expectToContainValidPreviewIframe(page, {
          embedType: "floating-popup",
          calLink: `${user.username}/30-min`,
          bookerUrl: getOrgFullOrigin(org?.slug ?? ""),
        });
      });

      test("open Embed Dialog and choose element-click for First Event Type", async ({ page, users }) => {
        const [user] = users.get();

        const embedUrl = await clickFirstEventTypeEmbedButton(page);

        const { team: org } = await user.getOrgMembership();

        await expectToBeNavigatingToEmbedTypesDialog(page, {
          embedUrl,
          basePage: "/event-types",
        });

        chooseEmbedType(page, "element-click");

        await expectToBeNavigatingToEmbedCodeAndPreviewDialog(page, {
          embedUrl,
          embedType: "element-click",
          basePage: "/event-types",
        });
        await expectToContainValidCode(page, {
          language: "html",
          embedType: "element-click",
          orgSlug: org.slug,
        });

        await goToReactCodeTab(page);
        await expectToContainValidCode(page, {
          language: "react",
          embedType: "element-click",
          orgSlug: org.slug,
        });

        await goToPreviewTab(page);
        await expectToContainValidPreviewIframe(page, {
          embedType: "element-click",
          calLink: `${user.username}/30-min`,
          bookerUrl: getOrgFullOrigin(org?.slug ?? ""),
        });
      });
    });
  });
});

type EmbedType = "inline" | "floating-popup" | "element-click";
function chooseEmbedType(page: Page, embedType: EmbedType) {
  page.locator(`[data-testid=${embedType}]`).click();
}

async function goToPreviewTab(page: Page) {
  // To prevent early timeouts
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(1000);
  await page.locator("[data-testid=horizontal-tab-Preview]").click();
}

async function goToReactCodeTab(page: Page) {
  // To prevent early timeouts
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(1000);
  await page.locator("[data-testid=horizontal-tab-React]").click();
}

async function clickEmbedButton(page: Page) {
  const embedButton = page.locator("[data-testid=embed]");
  const embedUrl = await embedButton.getAttribute("data-test-embed-url");
  embedButton.click();
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  return embedUrl!;
}

async function clickFirstEventTypeEmbedButton(page: Page) {
  const menu = page.locator("[data-testid*=event-type-options]").first();
  await menu.click();
  const embedUrl = await clickEmbedButton(page);
  return embedUrl;
}

async function expectToBeNavigatingToEmbedTypesDialog(
  page: Page,
  { embedUrl, basePage }: { embedUrl: string | null; basePage: string }
) {
  if (!embedUrl) {
    throw new Error("Couldn't find embedUrl");
  }
  await page.waitForURL((url) => {
    return (
      url.pathname === basePage &&
      url.searchParams.get("dialog") === "embed" &&
      url.searchParams.get("embedUrl") === embedUrl
    );
  });
}

async function expectToBeNavigatingToEmbedCodeAndPreviewDialog(
  page: Page,
  {
    embedUrl,
    embedType,
    basePage,
  }: {
    embedUrl: string | null;
    embedType: EmbedType;
    basePage: string;
  }
) {
  if (!embedUrl) {
    throw new Error("Couldn't find embedUrl");
  }
  await page.waitForURL((url) => {
    return (
      url.pathname === basePage &&
      url.searchParams.get("dialog") === "embed" &&
      url.searchParams.get("embedUrl") === embedUrl &&
      url.searchParams.get("embedType") === embedType &&
      url.searchParams.get("embedTabName") === "embed-code"
    );
  });
}

async function expectToContainValidCode(
  page: Page,
  {
    embedType,
    language,
    orgSlug,
  }: { embedType: EmbedType; language: "html" | "react"; orgSlug: string | null }
) {
  if (language === "react") {
    return expectValidReactEmbedSnippet(page, { embedType, orgSlug });
  }
  if (language === "html") {
    return expectValidHtmlEmbedSnippet(page, { embedType, orgSlug });
  }
  throw new Error("Unknown language");
}

async function expectValidHtmlEmbedSnippet(
  page: Page,
  { embedType, orgSlug }: { embedType: EmbedType; orgSlug: string | null }
) {
  const embedCode = await page.locator("[data-testid=embed-code]").inputValue();
  expect(embedCode).toContain("function (C, A, L)");
  expect(embedCode).toContain(`Cal ${embedType} embed code begins`);
  if (orgSlug) {
    expect(embedCode).toContain(orgSlug);
  }

  const dom = parse(embedCode);
  const scripts = dom.getElementsByTagName("script");
  assertThatCodeIsValidVanillaJsCode(scripts[0].innerText);

  return {
    message: () => `passed`,
    pass: true,
  };
}

function assertThatCodeIsValidVanillaJsCode(code: string) {
  const lintResult = linter.verify(code, {
    env: {
      browser: true,
    },
    parserOptions: {
      ecmaVersion: 2021,
    },
    globals: {
      Cal: "readonly",
    },
    rules: eslintRules,
  });
  if (lintResult.length) {
    console.log(
      JSON.stringify({
        lintResult,
        code,
      })
    );
  }
  expect(lintResult.length).toBe(0);
}

function assertThatCodeIsValidReactCode(code: string) {
  const lintResult = linter.verify(code, {
    env: {
      browser: true,
    },
    parserOptions: {
      ecmaVersion: 2021,
      ecmaFeatures: {
        jsx: true,
      },
      sourceType: "module",
    },
    rules: eslintRules,
  });
  if (lintResult.length) {
    console.log(
      JSON.stringify({
        lintResult,
        code,
      })
    );
  }
  expect(lintResult.length).toBe(0);
}

async function expectValidReactEmbedSnippet(
  page: Page,
  { embedType, orgSlug }: { embedType: EmbedType; orgSlug: string | null }
) {
  const embedCode = await page.locator("[data-testid=embed-react]").inputValue();
  expect(embedCode).toContain("export default function MyApp(");
  expect(embedCode).toContain(
    embedType === "floating-popup" ? "floatingButton" : embedType === "inline" ? `<Cal` : "data-cal-link"
  );
  if (orgSlug) {
    expect(embedCode).toContain(orgSlug);
  }

  assertThatCodeIsValidReactCode(embedCode);

  return {
    message: () => `passed`,
    pass: true,
  };
}

/**
 * Let's just check if iframe is opened with preview.html. preview.html tests are responsibility of embed-core
 */
async function expectToContainValidPreviewIframe(
  page: Page,
  { embedType, calLink, bookerUrl }: { embedType: EmbedType; calLink: string; bookerUrl?: string }
) {
  bookerUrl = bookerUrl || `${WEBAPP_URL}`;
  expect(await page.locator("[data-testid=embed-preview]").getAttribute("src")).toContain(
    `/preview.html?embedType=${embedType}&calLink=${calLink}&embedLibUrl=${EMBED_LIB_URL}&bookerUrl=${bookerUrl}`
  );
}
import { expect } from "@playwright/test";

import { SchedulingType } from "@calcom/prisma/enums";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

const title = (name: string) => `${name} is unpublished`;

const description = (entity: string) =>
  `This ${entity} link is currently not available. Please contact the ${entity} owner or ask them to publish it.`;

const avatar = (slug: string, entity = "team") => `/${entity}/${slug}/avatar.png`;

test.afterAll(async ({ users }) => {
  await users.deleteAll();
});

test.describe("Unpublished", () => {
  test("Regular team profile", async ({ page, users }) => {
    const owner = await users.create(undefined, { hasTeam: true, isUnpublished: true });

    const { team } = await owner.getFirstTeamMembership();

    const { requestedSlug } = team.metadata as { requestedSlug: string };
    await page.goto(`/team/${requestedSlug}`);
    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(team.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("team")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug));
  });

  test("Regular team event type", async ({ page, users }) => {
    const owner = await users.create(undefined, {
      hasTeam: true,
      isUnpublished: true,
      schedulingType: SchedulingType.COLLECTIVE,
    });

    const { team } = await owner.getFirstTeamMembership();

    const { requestedSlug } = team.metadata as { requestedSlug: string };

    const { slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);
    await page.goto(`/team/${requestedSlug}/${teamEventSlug}`);
    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(team.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("team")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug));
  });

  test("Organization profile", async ({ users, page }) => {
    const owner = await users.create(undefined, { hasTeam: true, isUnpublished: true, isOrg: true });

    const { team: org } = await owner.getOrgMembership();

    const { requestedSlug } = org.metadata as { requestedSlug: string };
    await page.goto(`/org/${requestedSlug}`);
    await page.waitForLoadState("networkidle");
    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(org.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("organization")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug, "org"));
  });

  test("Organization sub-team", async ({ users, page }) => {
    const owner = await users.create(undefined, {
      hasTeam: true,
      isUnpublished: true,
      isOrg: true,
      hasSubteam: true,
    });

    const { team: org } = await owner.getOrgMembership();

    const { requestedSlug } = org.metadata as { requestedSlug: string };

    const [{ slug: subteamSlug }] = org.children as { slug: string }[];
    await page.goto(`/org/${requestedSlug}/team/${subteamSlug}`);
    await page.waitForLoadState("networkidle");
    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(org.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("organization")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug, "org"));
  });

  test("Organization sub-team event-type", async ({ users, page }) => {
    const owner = await users.create(undefined, {
      hasTeam: true,
      isUnpublished: true,
      isOrg: true,
      hasSubteam: true,
    });

    const { team: org } = await owner.getOrgMembership();

    const { requestedSlug } = org.metadata as { requestedSlug: string };

    const [{ slug: subteamSlug, id: subteamId }] = org.children as { slug: string; id: number }[];

    const { slug: subteamEventSlug } = await owner.getFirstTeamEvent(subteamId);
    await page.goto(`/org/${requestedSlug}/team/${subteamSlug}/${subteamEventSlug}`);
    await page.waitForLoadState("networkidle");

    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(org.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("organization")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug, "org"));
  });

  test("Organization user", async ({ users, page }) => {
    const owner = await users.create(undefined, { hasTeam: true, isUnpublished: true, isOrg: true });

    const { team: org } = await owner.getOrgMembership();

    const { requestedSlug } = org.metadata as { requestedSlug: string };
    await page.goto(`/org/${requestedSlug}/${owner.username}`);
    await page.waitForLoadState("networkidle");
    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(org.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("organization")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug, "org"));
  });

  test("Organization user event-type", async ({ users, page }) => {
    const owner = await users.create(undefined, { hasTeam: true, isUnpublished: true, isOrg: true });

    const { team: org } = await owner.getOrgMembership();

    const { requestedSlug } = org.metadata as { requestedSlug: string };

    const [{ slug: ownerEventType }] = owner.eventTypes;
    await page.goto(`/org/${requestedSlug}/${owner.username}/${ownerEventType}`);
    await page.waitForLoadState("networkidle");
    expect(await page.locator('[data-testid="empty-screen"]').count()).toBe(1);
    expect(await page.locator(`h2:has-text("${title(org.name)}")`).count()).toBe(1);
    expect(await page.locator(`div:text("${description("organization")}")`).count()).toBe(1);
    await expect(page.locator(`img`)).toHaveAttribute("src", avatar(requestedSlug, "org"));
  });
});
import { test } from "../lib/fixtures";

test.beforeEach(async ({ page, users, bookingPage }) => {
  const teamEventTitle = "Test Managed Event Type";
  const userFixture = await users.create(
    { name: "testuser" },
    { hasTeam: true, schedulingType: "MANAGED", teamEventTitle }
  );
  await userFixture.apiLogin();

  await page.goto("/event-types");
  await bookingPage.goToEventType(teamEventTitle);
  await bookingPage.goToTab("event_advanced_tab_title");
});

test.describe("Check advanced options in a managed team event type", () => {
  test("Check advanced options in a managed team event type without offer seats", async ({ bookingPage }) => {
    await bookingPage.checkRequiresConfirmation();
    await bookingPage.checkRequiresBookerEmailVerification();
    await bookingPage.checkHideNotes();
    await bookingPage.checkRedirectOnBooking();
    await bookingPage.checkEnablePrivateUrl();
    await bookingPage.checkLockTimezone();
    await bookingPage.updateEventType();
    await bookingPage.goToEventTypesPage();

    await bookingPage.checkEventType();
  });

  test("Check advanced options in a managed team event type with offer seats", async ({ bookingPage }) => {
    await bookingPage.checkRequiresConfirmation();
    await bookingPage.checkRequiresBookerEmailVerification();
    await bookingPage.checkHideNotes();
    await bookingPage.checkRedirectOnBooking();
    await bookingPage.checkEnablePrivateUrl();
    await bookingPage.toggleOfferSeats();
    await bookingPage.checkLockTimezone();
    await bookingPage.updateEventType();
    await bookingPage.goToEventTypesPage();

    await bookingPage.checkEventType();
  });
});
import { expect } from "@playwright/test";

import { WEBAPP_URL } from "@calcom/lib/constants";

import { test } from "../lib/fixtures";
import { localize, getInviteLink } from "../lib/testUtils";
import { expectInvitationEmailToBeReceived } from "./expects";

test.describe.configure({ mode: "parallel" });

test.afterEach(async ({ users }) => {
  await users.deleteAll();
});

test.describe("Team", () => {
  test("Invitation (non verified)", async ({ browser, page, users, emails }) => {
    const t = await localize("en");

    const teamOwner = await users.create(undefined, { hasTeam: true });

    const { team } = await teamOwner.getFirstTeamMembership();
    await teamOwner.apiLogin();
    await page.goto(`/settings/teams/${team.id}/members`);
    await page.waitForLoadState("networkidle");

    await test.step("To the team by email (external user)", async () => {
      const invitedUserEmail = users.trackEmail({
        username: "rick",
        domain: `domain-${Date.now()}.com`,
      });
      await page.locator(`button:text("${t("add")}")`).click();
      await page.locator('input[name="inviteUser"]').fill(invitedUserEmail);
      await page.locator(`button:text("${t("send_invite")}")`).click();
      await page.waitForLoadState("networkidle");
      const inviteLink = await expectInvitationEmailToBeReceived(
        page,
        emails,
        invitedUserEmail,
        `${team.name}'s admin invited you to join the team ${team.name} on Cal.com`,
        "signup?token"
      );

      //Check newly invited member exists and is pending
      await expect(
        page.locator(`[data-testid="email-${invitedUserEmail.replace("@", "")}-pending"]`)
      ).toHaveCount(1);

      // eslint-disable-next-line playwright/no-conditional-in-test
      if (!inviteLink) return null;

      // Follow invite link to new window
      const context = await browser.newContext();
      const newPage = await context.newPage();
      await newPage.goto(inviteLink);
      await newPage.waitForLoadState("networkidle");

      // Check required fields
      const button = newPage.locator("button[type=submit][disabled]");
      await expect(button).toBeVisible(); // email + 3 password hints

      // Check required fields
      await newPage.locator("input[name=password]").fill(`P4ssw0rd!`);
      await newPage.locator("button[type=submit]").click();
      await newPage.waitForURL("/getting-started?from=signup");
      await newPage.close();
      await context.close();

      // Check newly invited member is not pending anymore
      await page.bringToFront();
      await page.goto(`/settings/teams/${team.id}/members`);
      await page.waitForLoadState("networkidle");
      await expect(
        page.locator(`[data-testid="email-${invitedUserEmail.replace("@", "")}-pending"]`)
      ).toHaveCount(0);
    });

    await test.step("To the team by invite link", async () => {
      const user = await users.create({
        email: `user-invite-${Date.now()}@domain.com`,
        password: "P4ssw0rd!",
      });
      await page.locator(`button:text("${t("add")}")`).click();
      await page.locator(`[data-testid="copy-invite-link-button"]`).click();
      const inviteLink = await getInviteLink(page);

      const context = await browser.newContext();
      const inviteLinkPage = await context.newPage();
      await inviteLinkPage.goto(inviteLink);
      await inviteLinkPage.waitForLoadState("domcontentloaded");

      await inviteLinkPage.locator("button[type=submit]").click();
      await expect(inviteLinkPage.locator('[data-testid="field-error"]')).toHaveCount(2);

      await inviteLinkPage.locator("input[name=email]").fill(user.email);
      await inviteLinkPage.locator("input[name=password]").fill(user.username || "P4ssw0rd!");
      await inviteLinkPage.locator("button[type=submit]").click();

      await inviteLinkPage.waitForURL(`${WEBAPP_URL}/teams**`);
    });
  });

  test("Invitation (verified)", async ({ browser, page, users, emails }) => {
    const t = await localize("en");

    const teamOwner = await users.create({ name: `team-owner-${Date.now()}` }, { hasTeam: true });

    const { team } = await teamOwner.getFirstTeamMembership();
    await teamOwner.apiLogin();
    await page.goto(`/settings/teams/${team.id}/members`);
    await page.waitForLoadState("networkidle");

    await test.step("To the organization by email (internal user)", async () => {
      const invitedUserEmail = users.trackEmail({
        username: "rick",
        domain: `example.com`,
      });
      await page.locator(`button:text("${t("add")}")`).click();
      await page.locator('input[name="inviteUser"]').fill(invitedUserEmail);
      await page.locator(`button:text("${t("send_invite")}")`).click();
      await page.waitForLoadState("networkidle");
      await expectInvitationEmailToBeReceived(
        page,
        emails,
        invitedUserEmail,
        `${teamOwner.name} invited you to join the team ${team.name} on Cal.com`
      );

      await expect(
        page.locator(`[data-testid="email-${invitedUserEmail.replace("@", "")}-pending"]`)
      ).toHaveCount(1);
    });
  });
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";
import { JSDOM } from "jsdom";
import type { Messages } from "mailhog";
import type { createEmailsFixture } from "playwright/fixtures/emails";

import { getEmailsReceivedByUser } from "../lib/testUtils";

export async function expectInvitationEmailToBeReceived(
  page: Page,
  emails: ReturnType<typeof createEmailsFixture>,
  userEmail: string,
  subject: string,
  returnLink?: string
) {
  if (!emails) return null;

  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(2000);
  const receivedEmails = await getEmailsReceivedByUser({ emails, userEmail });
  expect(receivedEmails?.total).toBe(1);

  const [firstReceivedEmail] = (receivedEmails as Messages).items;

  expect(firstReceivedEmail.subject).toBe(subject);
  if (!returnLink) return;
  const dom = new JSDOM(firstReceivedEmail.html);
  const anchor = dom.window.document.querySelector(`a[href*="${returnLink}"]`);
  return anchor?.getAttribute("href");
}
/* eslint-disable playwright/no-skipped-test */
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "serial" });

test.afterEach(({ users }) => users.deleteAll());

test.describe("Onboarding", () => {
  test.describe("Onboarding v2", () => {
    test("Onboarding Flow", async ({ page, users }) => {
      const user = await users.create({ completedOnboarding: false, name: null });
      await user.apiLogin();
      await page.goto("/getting-started");
      // tests whether the user makes it to /getting-started
      // after login with completedOnboarding false
      await page.waitForURL("/getting-started");

      await test.step("step 1", async () => {
        // Check required fields
        await page.locator("button[type=submit]").click();
        await expect(page.locator("data-testid=required")).toBeVisible();

        // happy path
        await page.locator("input[name=username]").fill("new user onboarding");
        await page.locator("input[name=name]").fill("new user 2");
        await page.locator("input[role=combobox]").click();
        await page
          .locator("*")
          .filter({ hasText: /^Europe\/London/ })
          .first()
          .click();

        await page.locator("button[type=submit]").click();

        // should be on step 2 now.
        await expect(page).toHaveURL(/.*connected-calendar/);

        const userComplete = await user.self();
        expect(userComplete.name).toBe("new user 2");
      });

      await test.step("step 2", async () => {
        const isDisabled = await page.locator("button[data-testid=save-calendar-button]").isDisabled();
        await expect(isDisabled).toBe(true);
        // tests skip button, we don't want to test entire flow.
        await page.locator("button[data-testid=skip-step]").click();

        await expect(page).toHaveURL(/.*connected-video/);
      });

      await test.step("step 3", async () => {
        const isDisabled = await page.locator("button[data-testid=save-video-button]").isDisabled();
        await expect(isDisabled).toBe(true);
        // tests skip button, we don't want to test entire flow.
        await page.locator("button[data-testid=skip-step]").click();

        await expect(page).toHaveURL(/.*setup-availability/);
      });

      await test.step("step 4", async () => {
        const isDisabled = await page.locator("button[data-testid=save-availability]").isDisabled();
        await expect(isDisabled).toBe(false);
        // same here, skip this step.
        await page.locator("button[data-testid=save-availability]").click();

        await expect(page).toHaveURL(/.*user-profile/);
      });

      await test.step("step 5", async () => {
        await page.locator("button[type=submit]").click();

        // should redirect to /event-types after onboarding
        await page.waitForURL("/event-types");

        const userComplete = await user.self();

        expect(userComplete.bio?.replace("<p><br></p>", "").length).toBe(0);
      });
    });
  });
});
/**
 * These e2e tests only aim to cover standard cases
 * Edge cases are currently handled in integration tests only
 */
import { expect } from "@playwright/test";

import type { Dayjs } from "@calcom/dayjs";
import dayjs from "@calcom/dayjs";
import { intervalLimitKeyToUnit } from "@calcom/lib/intervalLimit";
import { entries } from "@calcom/prisma/zod-utils";
import type { IntervalLimit } from "@calcom/types/Calendar";

import { test } from "./lib/fixtures";
import { bookTimeSlot, createUserWithLimits } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });
test.afterEach(async ({ users }) => {
  await users.deleteAll();
});

// used as a multiplier for duration limits
const EVENT_LENGTH = 30;

// limits used when testing each limit seperately
const BOOKING_LIMITS_SINGLE = {
  PER_DAY: 2,
  PER_WEEK: 2,
  PER_MONTH: 2,
  PER_YEAR: 2,
};

// limits used when testing multiple limits together
const BOOKING_LIMITS_MULTIPLE = {
  PER_DAY: 1,
  PER_WEEK: 2,
  PER_MONTH: 3,
  PER_YEAR: 4,
};

// prevent tests from crossing year boundaries - if currently in Oct or later, start booking in Jan instead of Nov
// (we increment months twice when checking multiple limits)
const firstDayInBookingMonth =
  dayjs().month() >= 9 ? dayjs().add(1, "year").month(0).date(1) : dayjs().add(1, "month").date(1);

// avoid weekly edge cases
const firstMondayInBookingMonth = firstDayInBookingMonth.day(
  firstDayInBookingMonth.date() === firstDayInBookingMonth.startOf("week").date() ? 1 : 8
);

// ensure we land on the same weekday when incrementing month
const incrementDate = (date: Dayjs, unit: dayjs.ManipulateType) => {
  if (unit !== "month") return date.add(1, unit);
  return date.add(1, "month").day(date.day());
};

const getLastEventUrlWithMonth = (user: Awaited<ReturnType<typeof createUserWithLimits>>, date: Dayjs) => {
  return `/${user.username}/${user.eventTypes.at(-1)?.slug}?month=${date.format("YYYY-MM")}`;
};

test.describe("Booking limits", () => {
  entries(BOOKING_LIMITS_SINGLE).forEach(([limitKey, bookingLimit]) => {
    const limitUnit = intervalLimitKeyToUnit(limitKey);

    // test one limit at a time
    test(limitUnit, async ({ page, users }) => {
      const slug = `booking-limit-${limitUnit}`;
      const singleLimit = { [limitKey]: bookingLimit };

      const user = await createUserWithLimits({
        users,
        slug,
        length: EVENT_LENGTH,
        bookingLimits: singleLimit,
      });

      let slotUrl = "";

      const monthUrl = getLastEventUrlWithMonth(user, firstMondayInBookingMonth);
      await page.goto(monthUrl);

      const availableDays = page.locator('[data-testid="day"][data-disabled="false"]');
      const bookingDay = availableDays.getByText(firstMondayInBookingMonth.date().toString(), {
        exact: true,
      });

      // finish rendering days before counting
      await expect(bookingDay).toBeVisible({ timeout: 10_000 });
      const availableDaysBefore = await availableDays.count();

      await test.step("can book up to limit", async () => {
        for (let i = 0; i < bookingLimit; i++) {
          await bookingDay.click();

          await page.getByTestId("time").nth(0).click();
          await bookTimeSlot(page);

          slotUrl = page.url();

          await expect(page.getByTestId("success-page")).toBeVisible();

          await page.goto(monthUrl);
        }
      });

      const expectedAvailableDays = {
        day: -1,
        week: -5,
        month: 0,
        year: 0,
      };

      await test.step("but not over", async () => {
        // should already have navigated to monthUrl - just ensure days are rendered
        await expect(page.getByTestId("day").nth(0)).toBeVisible();

        // ensure the day we just booked is now blocked
        await expect(bookingDay).toBeHidden({ timeout: 10_000 });

        const availableDaysAfter = await availableDays.count();

        // equals 0 if no available days, otherwise signed difference
        expect(availableDaysAfter && availableDaysAfter - availableDaysBefore).toBe(
          expectedAvailableDays[limitUnit]
        );

        // try to book directly via form page
        await page.goto(slotUrl);
        await bookTimeSlot(page);

        await expect(page.getByTestId("booking-fail")).toBeVisible({ timeout: 1000 });
      });

      await test.step(`month after booking`, async () => {
        await page.goto(getLastEventUrlWithMonth(user, firstMondayInBookingMonth.add(1, "month")));

        // finish rendering days before counting
        await expect(page.getByTestId("day").nth(0)).toBeVisible({ timeout: 10_000 });

        // the month after we made bookings should have availability unless we hit a yearly limit
        await expect((await availableDays.count()) === 0).toBe(limitUnit === "year");
      });
    });
  });

  test("multiple", async ({ page, users }) => {
    const slug = "booking-limit-multiple";

    const user = await createUserWithLimits({
      users,
      slug,
      length: EVENT_LENGTH,
      bookingLimits: BOOKING_LIMITS_MULTIPLE,
    });

    let slotUrl = "";

    let bookingDate = firstMondayInBookingMonth;

    // keep track of total bookings across multiple limits
    let bookingCount = 0;

    for (const [limitKey, limitValue] of entries(BOOKING_LIMITS_MULTIPLE)) {
      const limitUnit = intervalLimitKeyToUnit(limitKey);

      const monthUrl = getLastEventUrlWithMonth(user, bookingDate);
      await page.goto(monthUrl);

      const availableDays = page.locator('[data-testid="day"][data-disabled="false"]');
      const bookingDay = availableDays.getByText(bookingDate.date().toString(), { exact: true });

      // finish rendering days before counting
      await expect(bookingDay).toBeVisible({ timeout: 10_000 });

      const availableDaysBefore = await availableDays.count();

      await test.step(`can book up ${limitUnit} to limit`, async () => {
        for (let i = 0; i + bookingCount < limitValue; i++) {
          await bookingDay.click();

          await page.getByTestId("time").nth(0).click();
          await bookTimeSlot(page);
          bookingCount++;

          slotUrl = page.url();

          await expect(page.getByTestId("success-page")).toBeVisible();

          await page.goto(monthUrl);
        }
      });

      const expectedAvailableDays = {
        day: -1,
        week: -4, // one day will already be blocked by daily limit
        month: 0,
        year: 0,
      };

      await test.step("but not over", async () => {
        // should already have navigated to monthUrl - just ensure days are rendered
        await expect(page.getByTestId("day").nth(0)).toBeVisible();

        // ensure the day we just booked is now blocked
        await expect(bookingDay).toBeHidden({ timeout: 10_000 });

        const availableDaysAfter = await availableDays.count();

        // equals 0 if no available days, otherwise signed difference
        expect(availableDaysAfter && availableDaysAfter - availableDaysBefore).toBe(
          expectedAvailableDays[limitUnit]
        );

        // try to book directly via form page
        await page.goto(slotUrl);
        await bookTimeSlot(page);

        await expect(page.getByTestId("booking-fail")).toBeVisible({ timeout: 5000 });
      });

      await test.step(`month after booking`, async () => {
        await page.goto(getLastEventUrlWithMonth(user, bookingDate.add(1, "month")));

        // finish rendering days before counting
        await expect(page.getByTestId("day").nth(0)).toBeVisible({ timeout: 10_000 });

        // the month after we made bookings should have availability unless we hit a yearly limit
        // TODO: Temporary fix for failing test. It passes locally but fails on CI.
        // See #13097
        // await expect((await availableDays.count()) === 0).toBe(limitUnit === "year");
      });

      // increment date by unit after hitting each limit
      bookingDate = incrementDate(bookingDate, limitUnit);
    }
  });
});

test.describe("Duration limits", () => {
  entries(BOOKING_LIMITS_SINGLE).forEach(([limitKey, bookingLimit]) => {
    const limitUnit = intervalLimitKeyToUnit(limitKey);

    // test one limit at a time
    test(limitUnit, async ({ page, users }) => {
      const slug = `duration-limit-${limitUnit}`;
      const singleLimit = { [limitKey]: bookingLimit * EVENT_LENGTH };

      const user = await createUserWithLimits({
        users,
        slug,
        length: EVENT_LENGTH,
        durationLimits: singleLimit,
      });

      let slotUrl = "";

      const monthUrl = getLastEventUrlWithMonth(user, firstMondayInBookingMonth);
      await page.goto(monthUrl);

      const availableDays = page.locator('[data-testid="day"][data-disabled="false"]');
      const bookingDay = availableDays.getByText(firstMondayInBookingMonth.date().toString(), {
        exact: true,
      });

      // finish rendering days before counting
      await expect(bookingDay).toBeVisible({ timeout: 10_000 });
      const availableDaysBefore = await availableDays.count();

      await test.step("can book up to limit", async () => {
        for (let i = 0; i < bookingLimit; i++) {
          await bookingDay.click();

          await page.getByTestId("time").nth(0).click();
          await bookTimeSlot(page);

          slotUrl = page.url();

          await expect(page.getByTestId("success-page")).toBeVisible();

          await page.goto(monthUrl);
        }
      });

      const expectedAvailableDays = {
        day: -1,
        week: -5,
        month: 0,
        year: 0,
      };

      await test.step("but not over", async () => {
        // should already have navigated to monthUrl - just ensure days are rendered
        await expect(page.getByTestId("day").nth(0)).toBeVisible();

        // ensure the day we just booked is now blocked
        await expect(bookingDay).toBeHidden({ timeout: 10_000 });

        const availableDaysAfter = await availableDays.count();

        // equals 0 if no available days, otherwise signed difference
        expect(availableDaysAfter && availableDaysAfter - availableDaysBefore).toBe(
          expectedAvailableDays[limitUnit]
        );

        // try to book directly via form page
        await page.goto(slotUrl);
        await bookTimeSlot(page);

        await expect(page.getByTestId("booking-fail")).toBeVisible({ timeout: 1000 });
      });

      await test.step(`month after booking`, async () => {
        await page.goto(getLastEventUrlWithMonth(user, firstMondayInBookingMonth.add(1, "month")));

        // finish rendering days before counting
        await expect(page.getByTestId("day").nth(0)).toBeVisible({ timeout: 10_000 });

        // the month after we made bookings should have availability unless we hit a yearly limit
        await expect((await availableDays.count()) === 0).toBe(limitUnit === "year");
      });
    });
  });

  test("multiple", async ({ page, users }) => {
    const slug = "duration-limit-multiple";

    // multiply all booking limits by EVENT_LENGTH
    const durationLimits = entries(BOOKING_LIMITS_MULTIPLE).reduce((limits, [limitKey, bookingLimit]) => {
      return {
        ...limits,
        [limitKey]: bookingLimit * EVENT_LENGTH,
      };
    }, {} as Record<keyof IntervalLimit, number>);

    const user = await createUserWithLimits({
      users,
      slug,
      length: EVENT_LENGTH,
      durationLimits,
    });

    let slotUrl = "";

    let bookingDate = firstMondayInBookingMonth;

    // keep track of total bookings across multiple limits
    let bookingCount = 0;

    for (const [limitKey, limitValue] of entries(BOOKING_LIMITS_MULTIPLE)) {
      const limitUnit = intervalLimitKeyToUnit(limitKey);

      const monthUrl = getLastEventUrlWithMonth(user, bookingDate);
      await page.goto(monthUrl);

      const availableDays = page.locator('[data-testid="day"][data-disabled="false"]');
      const bookingDay = availableDays.getByText(bookingDate.date().toString(), { exact: true });

      // finish rendering days before counting
      await expect(bookingDay).toBeVisible({ timeout: 10_000 });

      const availableDaysBefore = await availableDays.count();

      await test.step(`can book up ${limitUnit} to limit`, async () => {
        for (let i = 0; i + bookingCount < limitValue; i++) {
          await bookingDay.click();

          await page.getByTestId("time").nth(0).click();
          await bookTimeSlot(page);
          bookingCount++;

          slotUrl = page.url();

          await expect(page.getByTestId("success-page")).toBeVisible();

          await page.goto(monthUrl);
        }
      });

      const expectedAvailableDays = {
        day: -1,
        week: -4, // one day will already be blocked by daily limit
        month: 0,
        year: 0,
      };

      await test.step("but not over", async () => {
        // should already have navigated to monthUrl - just ensure days are rendered
        await expect(page.getByTestId("day").nth(0)).toBeVisible();

        // ensure the day we just booked is now blocked
        await expect(bookingDay).toBeHidden({ timeout: 10_000 });

        const availableDaysAfter = await availableDays.count();

        // equals 0 if no available days, otherwise signed difference
        expect(availableDaysAfter && availableDaysAfter - availableDaysBefore).toBe(
          expectedAvailableDays[limitUnit]
        );

        // try to book directly via form page
        await page.goto(slotUrl);
        await bookTimeSlot(page);

        await expect(page.getByTestId("booking-fail")).toBeVisible({ timeout: 1000 });
      });

      await test.step(`month after booking`, async () => {
        await page.goto(getLastEventUrlWithMonth(user, bookingDate.add(1, "month")));

        // finish rendering days before counting
        await expect(page.getByTestId("day").nth(0)).toBeVisible({ timeout: 10_000 });

        // the month after we made bookings should have availability unless we hit a yearly limit
        await expect((await availableDays.count()) === 0).toBe(limitUnit === "year");
      });

      // increment date by unit after hitting each limit
      bookingDate = incrementDate(bookingDate, limitUnit);
    }
  });
});
import { expect } from "@playwright/test";
import { randomBytes } from "crypto";

import { WEBAPP_URL } from "@calcom/lib/constants";
import { prisma } from "@calcom/prisma";
import { generateSecret } from "@calcom/trpc/server/routers/viewer/oAuth/addClient.handler";

import { test } from "./lib/fixtures";

test.afterEach(async ({ users }) => {
  await users.deleteAll();
});

let client: {
  clientId: string;
  redirectUri: string;
  orginalSecret: string;
  name: string;
  clientSecret: string;
  logo: string | null;
};

test.describe("OAuth Provider", () => {
  test.beforeAll(async () => {
    client = await createTestCLient();
  });
  test("should create valid access toke & refresh token for user", async ({ page, users }) => {
    const user = await users.create({ username: "test user", name: "test user" });
    await user.apiLogin();

    await page.goto(
      `auth/oauth2/authorize?client_id=${client.clientId}&redirect_uri=${client.redirectUri}&response_type=code&scope=READ_PROFILE&state=1234`
    );

    await page.waitForLoadState("networkidle");
    await page.getByTestId("allow-button").click();

    await page.waitForFunction(() => {
      return window.location.href.startsWith("https://example.com");
    });

    const url = new URL(page.url());

    // authorization code that is returned to client with redirect uri
    const code = url.searchParams.get("code");

    // request token with authorization code
    const tokenResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/token`, {
      body: JSON.stringify({
        code,
        client_id: client.clientId,
        client_secret: client.orginalSecret,
        grant_type: "authorization_code",
        redirect_uri: client.redirectUri,
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    });

    const tokenData = await tokenResponse.json();

    // test if token is valid
    const meResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/me`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${tokenData.access_token}`,
      },
    });

    const meData = await meResponse.json();

    // check if user access token is valid
    expect(meData.username.startsWith("test user")).toBe(true);

    // request new token with refresh token
    const refreshTokenResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/refreshToken`, {
      body: JSON.stringify({
        refresh_token: tokenData.refresh_token,
        client_id: client.clientId,
        client_secret: client.orginalSecret,
        grant_type: "refresh_token",
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    });

    const refreshTokenData = await refreshTokenResponse.json();

    expect(refreshTokenData.access_token).not.toBe(tokenData.access_token);

    const validTokenResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/me`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${tokenData.access_token}`,
      },
    });

    expect(meData.username.startsWith("test user")).toBe(true);
  });

  test("should create valid access token & refresh token for team", async ({ page, users }) => {
    const user = await users.create({ username: "test user", name: "test user" }, { hasTeam: true });
    await user.apiLogin();

    await page.goto(
      `auth/oauth2/authorize?client_id=${client.clientId}&redirect_uri=${client.redirectUri}&response_type=code&scope=READ_PROFILE&state=1234`
    );

    await page.waitForLoadState("networkidle");

    await page.locator("#account-select").click();

    await page.locator("#react-select-2-option-1").click();

    await page.getByTestId("allow-button").click();

    await page.waitForFunction(() => {
      return window.location.href.startsWith("https://example.com");
    });

    const url = new URL(page.url());

    // authorization code that is returned to client with redirect uri
    const code = url.searchParams.get("code");

    // request token with authorization code
    const tokenResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/token`, {
      body: JSON.stringify({
        code,
        client_id: client.clientId,
        client_secret: client.orginalSecret,
        grant_type: "authorization_code",
        redirect_uri: client.redirectUri,
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    });

    const tokenData = await tokenResponse.json();

    // test if token is valid
    const meResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/me`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${tokenData.access_token}`,
      },
    });

    const meData = await meResponse.json();

    // Check if team access token is valid
    expect(meData.username).toEqual(`user-id-${user.id}'s Team`);

    // request new token with refresh token
    const refreshTokenResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/refreshToken`, {
      body: JSON.stringify({
        refresh_token: tokenData.refresh_token,
        client_id: client.clientId,
        client_secret: client.orginalSecret,
        grant_type: "refresh_token",
      }),
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
    });

    const refreshTokenData = await refreshTokenResponse.json();

    expect(refreshTokenData.access_token).not.toBe(tokenData.access_token);

    const validTokenResponse = await fetch(`${WEBAPP_URL}/api/auth/oauth/me`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${tokenData.access_token}`,
      },
    });

    expect(meData.username).toEqual(`user-id-${user.id}'s Team`);
  });

  test("redirect not logged-in users to login page and after forward to authorization page", async ({
    page,
    users,
  }) => {
    const user = await users.create({ username: "test-user", name: "test user" });

    await page.goto(
      `auth/oauth2/authorize?client_id=${client.clientId}&redirect_uri=${client.redirectUri}&response_type=code&scope=READ_PROFILE&state=1234`
    );

    // check if user is redirected to login page
    await expect(page.getByRole("heading", { name: "Welcome back" })).toBeVisible();
    await page.locator("#email").fill(user.email);
    await page.locator("#password").fill(user.username || "");
    await page.locator('[type="submit"]').click();

    await page.waitForSelector("#account-select");

    await expect(page.getByText("test user")).toBeVisible();
  });
});

const createTestCLient = async () => {
  const [hashedSecret, secret] = generateSecret();
  const clientId = randomBytes(32).toString("hex");

  const client = await prisma.oAuthClient.create({
    data: {
      name: "Test Client",
      clientId,
      clientSecret: hashedSecret,
      redirectUri: "https://example.com",
    },
  });

  return { ...client, orginalSecret: secret };
};
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { test } from "./lib/fixtures";

const SAML_DATABASE_URL = process.env.SAML_DATABASE_URL!;

const SAML_ADMINS = process.env.SAML_ADMINS!;

const SAML_ADMIN_EMAIL = process.env.E2E_TEST_SAML_ADMIN_EMAIL!;

const SAML_ADMIN_PASSWORD = process.env.E2E_TEST_SAML_ADMIN_PASSWORD!;

const OIDC_CLIENT_ID = process.env.E2E_TEST_OIDC_CLIENT_ID!;

const OIDC_CLIENT_SECRET = process.env.E2E_TEST_OIDC_CLIENT_SECRET!;

const OIDC_PROVIDER_DOMAIN = process.env.E2E_TEST_OIDC_PROVIDER_DOMAIN!;

const OIDC_USER_EMAIL = process.env.E2E_TEST_OIDC_USER_EMAIL!;

const OIDC_USER_PASSWORD = process.env.E2E_TEST_OIDC_USER_PASSWORD!;

const SHOULD_SKIP_TESTS =
  !SAML_DATABASE_URL ||
  !SAML_ADMINS ||
  !SAML_ADMIN_EMAIL ||
  !SAML_ADMIN_PASSWORD ||
  !OIDC_CLIENT_ID ||
  !OIDC_CLIENT_SECRET ||
  !OIDC_PROVIDER_DOMAIN ||
  !OIDC_USER_EMAIL ||
  !OIDC_USER_PASSWORD;

test.afterEach(({ users }) => users.deleteAll());
// TODO: Cleanup the OIDC connection after the tests with fixtures
test.describe("OIDC", () => {
  // eslint-disable-next-line playwright/no-skipped-test
  test.skip(SHOULD_SKIP_TESTS, "Skipping due to missing the testing variables");
  test("Setup with SAML admin and login", async ({ page, users }) => {
    // Add the admin user provided in the environment variables to the db
    const samlAdminUser = await users.create({ email: SAML_ADMIN_EMAIL, password: SAML_ADMIN_PASSWORD });
    await samlAdminUser.apiLogin();
    await test.step("Connect with OIDC Provider", async () => {
      await page.goto("/settings/security/sso");
      await page.click('[data-testid="sso-oidc-configure"]');
      await page.fill('[data-testid="sso-oidc-client-id"]', OIDC_CLIENT_ID);
      await page.fill('[data-testid="sso-oidc-client-secret"]', OIDC_CLIENT_SECRET);
      await page.fill(
        '[data-testid="sso-oidc-well-known-url"]',
        `https://${OIDC_PROVIDER_DOMAIN}/.well-known/openid-configuration`
      );
      await page.click('[data-testid="sso-oidc-save"]');
      await page.waitForSelector('[data-testid="toast-success"]');
    });
    // Logout the SAML Admin
    await samlAdminUser.logout();
    await test.step("Login using the OIDC provider", async () => {
      // Login a user using the OIDC provider.
      // The credentials are handled by the provider, so we don't need to create a user in the db.
      await page.goto("/auth/login");
      await page.click('[data-testid="saml"]');
      // Redirected outide of the app, the user would be redirected to the OIDC provider.
      await page.waitForURL(/https:\/\/[^/]+\/oauth2\/v1\/authorize\?.*/);
      await page.getByRole("textbox", { name: "Username" }).fill(OIDC_USER_EMAIL);
      await page.getByRole("textbox", { name: "Password" }).fill(OIDC_USER_PASSWORD);
      await page.getByRole("button", { name: "Sign in" }).click();
      // The user is redirected back to the app.
      await page.waitForURL("getting-started", { waitUntil: "load" });
    });
    // Logout the user.
    await page.goto("/auth/logout");
    await test.step("Disconnect OIDC Provider", async () => {
      samlAdminUser.apiLogin();
      await page.goto("/settings/security/sso", { waitUntil: "load" });
      await page.getByTestId("delete-oidc-sso-connection").click();
      await page.getByRole("button", { name: "Yes, delete OIDC configuration" }).click();
      await page.waitForSelector('[data-testid="toast-success"]');
    });
  });
});
import { expect } from "@playwright/test";

import prisma from "@calcom/prisma";

import { test } from "./lib/fixtures";
import { selectFirstAvailableTimeSlotNextMonth } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });
test.afterEach(({ users }) => users.deleteAll());

test.describe("Payment app", () => {
  test("Should be able to edit alby price, currency", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");
    expect(paymentEvent).not.toBeNull();
    await prisma.credential.create({
      data: {
        type: "alby_payment",
        userId: user.id,
        key: {
          account_id: "random",
          account_email: "random@example.com",
          webhook_endpoint_id: "ep_randomString",
          webhook_endpoint_secret: "whsec_randomString",
          account_lightning_address: "random@getalby.com",
        },
      },
    });

    await page.goto(`event-types/${paymentEvent?.id}?tabName=apps`);

    await page.locator("#event-type-form").getByRole("switch").click();
    await page.getByPlaceholder("Price").click();
    await page.getByPlaceholder("Price").fill("200");
    await page.getByText("SatoshissatsCurrencyBTCPayment optionCollect payment on booking").click();
    await page.getByTestId("update-eventtype").click();

    await page.goto(`${user.username}/${paymentEvent?.slug}`);

    // expect 200 sats to be displayed in page
    expect(await page.locator("text=200 sats").first()).toBeTruthy();

    await selectFirstAvailableTimeSlotNextMonth(page);
    expect(await page.locator("text=200 sats").first()).toBeTruthy();

    // go to /event-types and check if the price is 200 sats
    await page.goto(`event-types/`);
    expect(await page.locator("text=200 sats").first()).toBeTruthy();
  });

  test("Should be able to edit stripe price, currency", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");
    expect(paymentEvent).not.toBeNull();
    await prisma.credential.create({
      data: {
        type: "stripe_payment",
        userId: user.id,
        key: {
          scope: "read_write",
          livemode: false,
          token_type: "bearer",
          access_token: "sk_test_randomString",
          refresh_token: "rt_randomString",
          stripe_user_id: "acct_randomString",
          default_currency: "usd",
          stripe_publishable_key: "pk_test_randomString",
        },
      },
    });

    await page.goto(`event-types/${paymentEvent?.id}?tabName=apps`);
    await page.locator("#event-type-form").getByRole("switch").click();
    await page.getByTestId("stripe-currency-select").click();
    await page.getByTestId("select-option-usd").click();

    await page.getByTestId("stripe-price-input").click();
    await page.getByTestId("stripe-price-input").fill("350");
    await page.getByTestId("update-eventtype").click();

    await page.goto(`${user.username}/${paymentEvent?.slug}`);

    // expect 200 sats to be displayed in page
    expect(await page.locator("text=350").first()).toBeTruthy();

    await selectFirstAvailableTimeSlotNextMonth(page);
    expect(await page.locator("text=350").first()).toBeTruthy();

    // go to /event-types and check if the price is 200 sats
    await page.goto(`event-types/`);
    expect(await page.locator("text=350").first()).toBeTruthy();
  });

  test("Should be able to edit paypal price, currency", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");
    expect(paymentEvent).not.toBeNull();
    await prisma.credential.create({
      data: {
        type: "paypal_payment",
        userId: user.id,
        key: {
          client_id: "randomString",
          secret_key: "randomString",
          webhook_id: "randomString",
        },
      },
    });

    await page.goto(`event-types/${paymentEvent?.id}?tabName=apps`);

    await page.locator("#event-type-form").getByRole("switch").click();

    await page.getByPlaceholder("Price").click();
    await page.getByPlaceholder("Price").fill("150");

    await page.getByTestId("paypal-currency-select").click();
    await page.locator("#react-select-2-option-13").click();

    await page.getByTestId("paypal-payment-option-select").click();

    await page.getByText("$MXNCurrencyMexican pesoPayment option").click();
    await page.getByTestId("update-eventtype").click();

    await page.goto(`${user.username}/${paymentEvent?.slug}`);

    // expect 150 to be displayed in page
    expect(await page.locator("text=MX$150.00").first()).toBeTruthy();

    await selectFirstAvailableTimeSlotNextMonth(page);
    // expect 150 to be displayed in page
    expect(await page.locator("text=MX$150.00").first()).toBeTruthy();

    // go to /event-types and check if the price is 150
    await page.goto(`event-types/`);
    expect(await page.locator("text=MX$150.00").first()).toBeTruthy();
  });

  test("Should display App is not setup already for alby", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");
    expect(paymentEvent).not.toBeNull();
    await prisma.credential.create({
      data: {
        type: "alby_payment",
        userId: user.id,
        key: {},
      },
    });

    await page.goto(`event-types/${paymentEvent?.id}?tabName=apps`);

    await page.locator("#event-type-form").getByRole("switch").click();

    // expect text "This app has not been setup yet" to be displayed
    expect(await page.locator("text=This app has not been setup yet").first()).toBeTruthy();

    await page.getByRole("button", { name: "Setup" }).click();

    // Expect "Connect with Alby" to be displayed
    expect(await page.locator("text=Connect with Alby").first()).toBeTruthy();
  });

  test("Should display App is not setup already for paypal", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");
    expect(paymentEvent).not.toBeNull();
    await prisma.credential.create({
      data: {
        type: "paypal_payment",
        userId: user.id,
        key: {},
      },
    });

    await page.goto(`event-types/${paymentEvent?.id}?tabName=apps`);

    await page.locator("#event-type-form").getByRole("switch").click();

    // expect text "This app has not been setup yet" to be displayed
    expect(await page.locator("text=This app has not been setup yet").first()).toBeTruthy();

    await page.getByRole("button", { name: "Setup" }).click();

    // Expect "Getting started with Paypal APP" to be displayed
    expect(await page.locator("text=Getting started with Paypal APP").first()).toBeTruthy();
  });

  /**
   * For now almost all the payment apps show display "This app has not been setup yet"
   * this can change in the future
   */
  test("Should not display App is not setup already for non payment app", async ({ page, users }) => {
    // We will use google analytics app for this test
    const user = await users.create();
    await user.apiLogin();
    // Any event should work here
    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");
    expect(paymentEvent).not.toBeNull();

    await prisma.credential.create({
      data: {
        type: "ga4_analytics",
        userId: user.id,
        appId: "ga4",
        invalid: false,
        key: {},
      },
    });

    await page.goto(`event-types/${paymentEvent?.id}?tabName=apps`);

    await page.locator("#event-type-form").getByRole("switch").click();
    // make sure Tracking ID is displayed
    expect(await page.locator("text=Tracking ID").first()).toBeTruthy();
    await page.getByLabel("Tracking ID").click();
    await page.getByLabel("Tracking ID").fill("demo");
    await page.getByTestId("update-eventtype").click();
  });

  test("Should only be allowed to enable one payment app", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");

    if (!paymentEvent) {
      throw new Error("No payment event found");
    }
    await prisma.credential.createMany({
      data: [
        {
          type: "paypal_payment",
          userId: user.id,
          key: {
            client_id: "randomString",
            secret_key: "randomString",
            webhook_id: "randomString",
          },
        },
        {
          type: "stripe_payment",
          userId: user.id,
          key: {
            scope: "read_write",
            livemode: false,
            token_type: "bearer",
            access_token: "sk_test_randomString",
            refresh_token: "rt_randomString",
            stripe_user_id: "acct_randomString",
            default_currency: "usd",
            stripe_publishable_key: "pk_test_randomString",
          },
        },
      ],
    });

    await page.goto(`event-types/${paymentEvent.id}?tabName=apps`);

    await page.locator("[data-testid='paypal-app-switch']").click();
    await page.locator("[data-testid='stripe-app-switch']").isDisabled();
  });

  test("when more than one payment app is installed the price should be updated when changing settings", async ({
    page,
    users,
  }) => {
    const user = await users.create();
    await user.apiLogin();

    const paymentEvent = user.eventTypes.find((item) => item.slug === "paid");

    if (!paymentEvent) {
      throw new Error("No payment event found");
    }

    await prisma.credential.createMany({
      data: [
        {
          type: "paypal_payment",
          userId: user.id,
          key: {
            client_id: "randomString",
            secret_key: "randomString",
            webhook_id: "randomString",
          },
        },
        {
          type: "stripe_payment",
          userId: user.id,
          key: {
            scope: "read_write",
            livemode: false,
            token_type: "bearer",
            access_token: "sk_test_randomString",
            refresh_token: "rt_randomString",
            stripe_user_id: "acct_randomString",
            default_currency: "usd",
            stripe_publishable_key: "pk_test_randomString",
          },
        },
      ],
    });

    await page.goto(`event-types/${paymentEvent.id}?tabName=apps`);

    await page.locator("[data-testid='paypal-app-switch']").click();
    await page.locator("[data-testid='paypal-price-input']").fill("100");
    await page.locator("[data-testid='paypal-currency-select']").first().click();
    await page.locator("#react-select-2-option-13").click();
    // await page.locator(".mb-1 > .bg-default > div > div:nth-child(2)").first().click();
    // await page.getByText("$MXNCurrencyMexican pesoPayment option").click();
    await page.locator("[data-testid='update-eventtype']").click();

    // Need to wait for the DB to be updated
    await page.waitForResponse((res) => res.url().includes("update") && res.status() === 200);

    const paypalPrice = await prisma.eventType.findFirst({
      where: {
        id: paymentEvent.id,
      },
      select: {
        price: true,
      },
    });

    expect(paypalPrice?.price).toEqual(10000);

    await page.locator("[data-testid='paypal-app-switch']").click();
    await page.locator("[data-testid='stripe-app-switch']").click();
    await page.locator("[data-testid='stripe-price-input']").fill("200");
    await page.locator("[data-testid='update-eventtype']").click();

    // Need to wait for the DB to be updated
    await page.waitForResponse((res) => res.url().includes("update") && res.status() === 200);

    const stripePrice = await prisma.eventType.findFirst({
      where: {
        id: paymentEvent.id,
      },
      select: {
        price: true,
      },
    });

    expect(stripePrice?.price).toEqual(20000);
  });
});
import { test } from "@playwright/test";

import { todo } from "./lib/testUtils";

test.describe("Trial account tests", () => {
  todo("Add tests with a TRIAL account");
});
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";
import { v4 as uuidv4 } from "uuid";

import { WEBAPP_URL } from "@calcom/lib/constants";
import prisma from "@calcom/prisma";
import { BookingStatus } from "@calcom/prisma/client";

import { loginUser } from "./fixtures/regularBookings";
import { test } from "./lib/fixtures";
import {
  bookOptinEvent,
  createHttpServer,
  selectFirstAvailableTimeSlotNextMonth,
  gotoRoutingLink,
  createUserWithSeatedEventAndAttendees,
  bookEventOnThisPage,
} from "./lib/testUtils";

// remove dynamic properties that differs depending on where you run the tests
const dynamic = "[redacted/dynamic]";

test.afterEach(({ users }) => users.deleteAll());

async function createWebhookReceiver(page: Page) {
  const webhookReceiver = createHttpServer();

  await page.goto(`/settings/developer/webhooks`);

  // --- add webhook
  await page.click('[data-testid="new_webhook"]');

  await page.fill('[name="subscriberUrl"]', webhookReceiver.url);

  await page.fill('[name="secret"]', "secret");

  await Promise.all([
    page.click("[type=submit]"),
    page.waitForURL((url) => url.pathname.endsWith("/settings/developer/webhooks")),
  ]);

  // page contains the url
  expect(page.locator(`text='${webhookReceiver.url}'`)).toBeDefined();

  return webhookReceiver;
}

test.describe("Webhook tests", async () => {
  test.describe("BOOKING_CREATED", async () => {
    test("add webhook & test that creating an event triggers a webhook call", async ({
      page,
      users,
    }, _testInfo) => {
      const webhookReceiver = createHttpServer();
      const user = await users.create();
      const [eventType] = user.eventTypes;
      await user.apiLogin();
      await page.goto(`/settings/developer/webhooks`);

      // --- add webhook
      await page.click('[data-testid="new_webhook"]');

      await page.fill('[name="subscriberUrl"]', webhookReceiver.url);

      await page.fill('[name="secret"]', "secret");

      await Promise.all([
        page.click("[type=submit]"),
        page.waitForURL((url) => url.pathname.endsWith("/settings/developer/webhooks")),
      ]);

      // page contains the url
      expect(page.locator(`text='${webhookReceiver.url}'`)).toBeDefined();

      // --- Book the first available day next month in the pro user's "30min"-event
      await page.goto(`/${user.username}/${eventType.slug}`);
      await selectFirstAvailableTimeSlotNextMonth(page);

      // --- fill form
      await page.fill('[name="name"]', "Test Testson");
      await page.fill('[name="email"]', "test@example.com");
      await page.press('[name="email"]', "Enter");

      await webhookReceiver.waitForRequestCount(1);

      const [request] = webhookReceiver.requestList;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const body: any = request.body;

      body.createdAt = dynamic;
      body.payload.startTime = dynamic;
      body.payload.endTime = dynamic;
      body.payload.location = dynamic;
      for (const attendee of body.payload.attendees) {
        attendee.timeZone = dynamic;
        attendee.language = dynamic;
      }
      body.payload.organizer.id = dynamic;
      body.payload.organizer.email = dynamic;
      body.payload.organizer.timeZone = dynamic;
      body.payload.organizer.language = dynamic;
      body.payload.uid = dynamic;
      body.payload.bookingId = dynamic;
      body.payload.additionalInformation = dynamic;
      body.payload.requiresConfirmation = dynamic;
      body.payload.eventTypeId = dynamic;
      body.payload.videoCallData = dynamic;
      body.payload.appsStatus = dynamic;
      body.payload.metadata.videoCallUrl = dynamic;
      expect(body).toMatchObject({
        triggerEvent: "BOOKING_CREATED",
        createdAt: "[redacted/dynamic]",
        payload: {
          type: "30-min",
          title: "30 min between Nameless and Test Testson",
          description: "",
          additionalNotes: "",
          customInputs: {},
          startTime: "[redacted/dynamic]",
          endTime: "[redacted/dynamic]",
          organizer: {
            id: "[redacted/dynamic]",
            name: "Nameless",
            email: "[redacted/dynamic]",
            timeZone: "[redacted/dynamic]",
            language: "[redacted/dynamic]",
          },
          responses: {
            email: {
              value: "test@example.com",
              label: "email_address",
            },
            name: {
              value: "Test Testson",
              label: "your_name",
            },
          },
          userFieldsResponses: {},
          attendees: [
            {
              email: "test@example.com",
              name: "Test Testson",
              timeZone: "[redacted/dynamic]",
              language: "[redacted/dynamic]",
            },
          ],
          location: "[redacted/dynamic]",
          destinationCalendar: null,
          hideCalendarNotes: false,
          requiresConfirmation: "[redacted/dynamic]",
          eventTypeId: "[redacted/dynamic]",
          seatsShowAttendees: true,
          seatsPerTimeSlot: null,
          uid: "[redacted/dynamic]",
          eventTitle: "30 min",
          eventDescription: null,
          price: 0,
          currency: "usd",
          length: 30,
          bookingId: "[redacted/dynamic]",
          metadata: { videoCallUrl: "[redacted/dynamic]" },
          status: "ACCEPTED",
          additionalInformation: "[redacted/dynamic]",
        },
      });

      webhookReceiver.close();
    });
  });

  test.describe("BOOKING_REJECTED", async () => {
    test("can book an event that requires confirmation and then that booking can be rejected by organizer", async ({
      page,
      users,
    }) => {
      const webhookReceiver = createHttpServer();
      // --- create a user
      const user = await users.create();

      // --- visit user page
      await page.goto(`/${user.username}`);

      // --- book the user's event
      await bookOptinEvent(page);

      // --- login as that user
      await user.apiLogin();

      await page.goto(`/settings/developer/webhooks`);

      // --- add webhook
      await page.click('[data-testid="new_webhook"]');

      await page.fill('[name="subscriberUrl"]', webhookReceiver.url);

      await page.fill('[name="secret"]', "secret");

      await Promise.all([
        page.click("[type=submit]"),
        page.waitForURL((url) => url.pathname.endsWith("/settings/developer/webhooks")),
      ]);

      // page contains the url
      expect(page.locator(`text='${webhookReceiver.url}'`)).toBeDefined();

      await page.goto("/bookings/unconfirmed");
      await page.click('[data-testid="reject"]');
      await page.click('[data-testid="rejection-confirm"]');
      await page.waitForResponse((response) => response.url().includes("/api/trpc/bookings/confirm"));

      await webhookReceiver.waitForRequestCount(1);

      const [request] = webhookReceiver.requestList;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const body = request.body as any;

      body.createdAt = dynamic;
      body.payload.startTime = dynamic;
      body.payload.endTime = dynamic;
      body.payload.location = dynamic;
      for (const attendee of body.payload.attendees) {
        attendee.timeZone = dynamic;
        attendee.language = dynamic;
      }
      body.payload.organizer.id = dynamic;
      body.payload.organizer.email = dynamic;
      body.payload.organizer.timeZone = dynamic;
      body.payload.organizer.language = dynamic;
      body.payload.uid = dynamic;
      body.payload.bookingId = dynamic;
      body.payload.additionalInformation = dynamic;
      body.payload.requiresConfirmation = dynamic;
      body.payload.eventTypeId = dynamic;
      body.payload.videoCallData = dynamic;
      body.payload.appsStatus = dynamic;
      // body.payload.metadata.videoCallUrl = dynamic;

      expect(body).toMatchObject({
        triggerEvent: "BOOKING_REJECTED",
        createdAt: "[redacted/dynamic]",
        payload: {
          type: "opt-in",
          title: "Opt in between Nameless and Test Testson",
          customInputs: {},
          startTime: "[redacted/dynamic]",
          endTime: "[redacted/dynamic]",
          organizer: {
            id: "[redacted/dynamic]",
            name: "Unnamed",
            email: "[redacted/dynamic]",
            timeZone: "[redacted/dynamic]",
            language: "[redacted/dynamic]",
          },
          responses: {
            email: {
              value: "test@example.com",
              label: "email",
            },
            name: {
              value: "Test Testson",
              label: "name",
            },
          },
          userFieldsResponses: {},
          attendees: [
            {
              email: "test@example.com",
              name: "Test Testson",
              timeZone: "[redacted/dynamic]",
              language: "[redacted/dynamic]",
            },
          ],
          location: "[redacted/dynamic]",
          destinationCalendar: [],
          // hideCalendarNotes: false,
          requiresConfirmation: "[redacted/dynamic]",
          eventTypeId: "[redacted/dynamic]",
          uid: "[redacted/dynamic]",
          eventTitle: "Opt in",
          eventDescription: null,
          price: 0,
          currency: "usd",
          length: 30,
          bookingId: "[redacted/dynamic]",
          // metadata: { videoCallUrl: "[redacted/dynamic]" },
          status: "REJECTED",
          additionalInformation: "[redacted/dynamic]",
        },
      });

      webhookReceiver.close();
    });
  });

  test.describe("BOOKING_REQUESTED", async () => {
    test("can book an event that requires confirmation and get a booking requested event", async ({
      page,
      users,
    }) => {
      const webhookReceiver = createHttpServer();
      // --- create a user
      const user = await users.create();

      // --- login as that user
      await user.apiLogin();

      await page.goto(`/settings/developer/webhooks`);

      // --- add webhook
      await page.click('[data-testid="new_webhook"]');

      await page.fill('[name="subscriberUrl"]', webhookReceiver.url);

      await page.fill('[name="secret"]', "secret");

      await Promise.all([
        page.click("[type=submit]"),
        page.waitForURL((url) => url.pathname.endsWith("/settings/developer/webhooks")),
      ]);

      // page contains the url
      expect(page.locator(`text='${webhookReceiver.url}'`)).toBeDefined();

      // --- visit user page
      await page.goto(`/${user.username}`);

      // --- book the user's opt in
      await bookOptinEvent(page);

      // --- check that webhook was called

      await webhookReceiver.waitForRequestCount(1);

      const [request] = webhookReceiver.requestList;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const body = request.body as any;

      body.createdAt = dynamic;
      body.payload.startTime = dynamic;
      body.payload.endTime = dynamic;
      body.payload.location = dynamic;
      for (const attendee of body.payload.attendees) {
        attendee.timeZone = dynamic;
        attendee.language = dynamic;
      }
      body.payload.organizer.id = dynamic;
      body.payload.organizer.email = dynamic;
      body.payload.organizer.timeZone = dynamic;
      body.payload.organizer.language = dynamic;
      body.payload.uid = dynamic;
      body.payload.bookingId = dynamic;
      body.payload.additionalInformation = dynamic;
      body.payload.requiresConfirmation = dynamic;
      body.payload.eventTypeId = dynamic;
      body.payload.videoCallData = dynamic;
      body.payload.appsStatus = dynamic;
      body.payload.metadata.videoCallUrl = dynamic;

      expect(body).toMatchObject({
        triggerEvent: "BOOKING_REQUESTED",
        createdAt: "[redacted/dynamic]",
        payload: {
          type: "opt-in",
          title: "Opt in between Nameless and Test Testson",
          customInputs: {},
          startTime: "[redacted/dynamic]",
          endTime: "[redacted/dynamic]",
          organizer: {
            id: "[redacted/dynamic]",
            name: "Nameless",
            email: "[redacted/dynamic]",
            timeZone: "[redacted/dynamic]",
            language: "[redacted/dynamic]",
          },
          responses: {
            email: {
              value: "test@example.com",
              label: "email_address",
            },
            name: {
              value: "Test Testson",
              label: "your_name",
            },
          },
          userFieldsResponses: {},
          attendees: [
            {
              email: "test@example.com",
              name: "Test Testson",
              timeZone: "[redacted/dynamic]",
              language: "[redacted/dynamic]",
            },
          ],
          location: "[redacted/dynamic]",
          destinationCalendar: null,
          requiresConfirmation: "[redacted/dynamic]",
          eventTypeId: "[redacted/dynamic]",
          uid: "[redacted/dynamic]",
          eventTitle: "Opt in",
          eventDescription: null,
          price: 0,
          currency: "usd",
          length: 30,
          bookingId: "[redacted/dynamic]",
          status: "PENDING",
          additionalInformation: "[redacted/dynamic]",
          metadata: { videoCallUrl: "[redacted/dynamic]" },
        },
      });

      webhookReceiver.close();
    });
  });

  test.describe("BOOKING_RESCHEDULED", async () => {
    test("can reschedule a booking and get a booking rescheduled event", async ({
      page,
      users,
      bookings,
    }) => {
      const user = await users.create();
      const [eventType] = user.eventTypes;

      await user.apiLogin();

      const webhookReceiver = await createWebhookReceiver(page);

      const booking = await bookings.create(user.id, user.username, eventType.id, {
        status: BookingStatus.ACCEPTED,
      });

      await page.goto(`/${user.username}/${eventType.slug}?rescheduleUid=${booking.uid}`);

      await selectFirstAvailableTimeSlotNextMonth(page);

      await page.locator('[data-testid="confirm-reschedule-button"]').click();

      await expect(page).toHaveURL(/.*booking/);

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const newBooking = await prisma.booking.findFirst({ where: { fromReschedule: booking?.uid } })!;
      expect(newBooking).not.toBeNull();

      // --- check that webhook was called
      await webhookReceiver.waitForRequestCount(1);

      const [request] = webhookReceiver.requestList;

      expect(request.body).toMatchObject({
        triggerEvent: "BOOKING_RESCHEDULED",
        payload: {
          uid: newBooking?.uid,
        },
      });
    });

    test("when rescheduling to a booking that already exists, should send a booking rescheduled event with the existant booking uid", async ({
      page,
      users,
      bookings,
    }) => {
      const { user, eventType, booking } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
        { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
        { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
      ]);

      await prisma.eventType.update({
        where: { id: eventType.id },
        data: { requiresConfirmation: false },
      });

      await user.apiLogin();

      const webhookReceiver = await createWebhookReceiver(page);

      const bookingAttendees = await prisma.attendee.findMany({
        where: { bookingId: booking.id },
        select: {
          id: true,
          email: true,
          name: true,
        },
      });

      const bookingSeats = bookingAttendees.map((attendee) => ({
        bookingId: booking.id,
        attendeeId: attendee.id,
        referenceUid: uuidv4(),
        data: {
          responses: {
            name: attendee.name,
            email: attendee.email,
          },
        },
      }));

      await prisma.bookingSeat.createMany({
        data: bookingSeats,
      });

      const references = await prisma.bookingSeat.findMany({
        where: { bookingId: booking.id },
        include: { attendee: true },
      });

      await page.goto(`/reschedule/${references[0].referenceUid}`);

      await selectFirstAvailableTimeSlotNextMonth(page);

      await page.locator('[data-testid="confirm-reschedule-button"]').click();

      await expect(page).toHaveURL(/.*booking/);

      const newBooking = await prisma.booking.findFirst({
        where: {
          attendees: {
            some: {
              email: bookingAttendees[0].email,
            },
          },
        },
      });

      // --- ensuring that new booking was created
      expect(newBooking).not.toBeNull();

      // --- check that webhook was called
      await webhookReceiver.waitForRequestCount(1);

      const [firstRequest] = webhookReceiver.requestList;

      expect(firstRequest?.body).toMatchObject({
        triggerEvent: "BOOKING_RESCHEDULED",
        payload: {
          uid: newBooking?.uid,
        },
      });

      await page.goto(`/reschedule/${references[1].referenceUid}`);

      await selectFirstAvailableTimeSlotNextMonth(page);

      await page.locator('[data-testid="confirm-reschedule-button"]').click();

      await expect(page).toHaveURL(/.*booking/);

      await webhookReceiver.waitForRequestCount(2);

      const [_, secondRequest] = webhookReceiver.requestList;

      expect(secondRequest?.body).toMatchObject({
        triggerEvent: "BOOKING_RESCHEDULED",
        payload: {
          // in the current implementation, it is the same as the first booking
          uid: newBooking?.uid,
        },
      });
    });
  });

  test.describe("FORM_SUBMITTED", async () => {
    test("on submitting user form, triggers user webhook", async ({ page, users, routingForms }) => {
      const webhookReceiver = createHttpServer();
      const user = await users.create(null, {
        hasTeam: true,
      });

      await user.apiLogin();

      await page.goto(`/settings/developer/webhooks/new`);

      // Add webhook
      await page.fill('[name="subscriberUrl"]', webhookReceiver.url);
      await page.fill('[name="secret"]', "secret");
      await page.click("[type=submit]");

      // Page contains the url
      expect(page.locator(`text='${webhookReceiver.url}'`)).toBeDefined();

      await page.waitForLoadState("networkidle");

      const form = await routingForms.create({
        name: "Test Form",
        userId: user.id,
        teamId: null,
        fields: [
          {
            type: "text",
            label: "Name",
            identifier: "name",
            required: true,
          },
        ],
      });

      await gotoRoutingLink({ page, formId: form.id });
      const fieldName = "name";
      await page.fill(`[data-testid="form-field-${fieldName}"]`, "John Doe");
      page.click('button[type="submit"]');

      await webhookReceiver.waitForRequestCount(1);

      const [request] = webhookReceiver.requestList;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const body = request.body as any;
      body.createdAt = dynamic;
      expect(body).toEqual({
        triggerEvent: "FORM_SUBMITTED",
        createdAt: dynamic,
        payload: {
          formId: form.id,
          formName: form.name,
          teamId: null,
          responses: {
            name: {
              value: "John Doe",
            },
          },
        },
        name: "John Doe",
      });

      webhookReceiver.close();
    });

    test("on submitting team form, triggers team webhook", async ({ page, users, routingForms }) => {
      const webhookReceiver = createHttpServer();
      const user = await users.create(null, {
        hasTeam: true,
      });
      await user.apiLogin();

      await page.goto(`/settings/developer/webhooks`);
      const teamId = await clickFirstTeamWebhookCta(page);

      // Add webhook
      await page.fill('[name="subscriberUrl"]', webhookReceiver.url);
      await page.fill('[name="secret"]', "secret");
      await page.click("[type=submit]");

      const form = await routingForms.create({
        name: "Test Form",
        userId: user.id,
        teamId: teamId,
        fields: [
          {
            type: "text",
            label: "Name",
            identifier: "name",
            required: true,
          },
        ],
      });

      await gotoRoutingLink({ page, formId: form.id });
      const fieldName = "name";
      await page.fill(`[data-testid="form-field-${fieldName}"]`, "John Doe");
      page.click('button[type="submit"]');

      await webhookReceiver.waitForRequestCount(1);

      const [request] = webhookReceiver.requestList;
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const body = request.body as any;
      body.createdAt = dynamic;
      expect(body).toEqual({
        triggerEvent: "FORM_SUBMITTED",
        createdAt: dynamic,
        payload: {
          formId: form.id,
          formName: form.name,
          teamId,
          responses: {
            name: {
              value: "John Doe",
            },
          },
        },
        name: "John Doe",
      });

      webhookReceiver.close();
    });
  });

  test.describe("Add webhook on event type config", async () => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const updateBody = (body: any) => {
      body.createdAt = dynamic;
      body.payload.bookingId = dynamic;
      body.payload.eventTypeId = dynamic;
      body.payload.startTime = dynamic;
      body.payload.endTime = dynamic;
      body.payload.organizer.id = dynamic;
      body.payload.organizer.email = dynamic;
      body.payload.organizer.username = dynamic;
      body.payload.organizer.timeZone = dynamic;
      body.payload.organizer.timeFormat = dynamic;
      body.payload.organizer.language.locale = dynamic;
      body.payload.responses.email.label = dynamic;
      body.payload.responses.email.value = dynamic;
      body.payload.uid = dynamic;
      body.payload.attendees = [
        {
          email: dynamic,
          firstName: "",
          language: {
            locale: dynamic,
          },
          lastName: "",
          name: "testuser",
          timeZone: dynamic,
        },
      ];
      return body;
    };

    const bodyProps = {
      createdAt: "[redacted/dynamic]",
      payload: {
        title: "30 min between testuser and Test Testson",
        type: "30-min",
        customInputs: {},
        userFieldsResponses: {},
        responses: {
          name: { label: "your_name", value: "Test Testson" },
          email: { label: "[redacted/dynamic]", value: "[redacted/dynamic]" },
          guests: { label: "additional_guests", value: [] },
        },
        startTime: "[redacted/dynamic]",
        endTime: "[redacted/dynamic]",
        organizer: {
          email: "[redacted/dynamic]",
          name: "testuser",
          timeZone: "[redacted/dynamic]",
          timeFormat: "[redacted/dynamic]",
          language: { locale: "[redacted/dynamic]" },
          id: "[redacted/dynamic]",
          username: "[redacted/dynamic]",
        },
        attendees: [
          {
            email: "[redacted/dynamic]",
            firstName: "",
            language: { locale: "[redacted/dynamic]" },
            lastName: "",
            name: "testuser",
            timeZone: "[redacted/dynamic]",
          },
        ],
        uid: "[redacted/dynamic]",
        bookingId: "[redacted/dynamic]",
        location: "",
        destinationCalendar: null,
        seatsPerTimeSlot: null,
        seatsShowAttendees: true,
        eventTitle: "30 min",
        eventDescription: null,
        requiresConfirmation: false,
        price: 0,
        currency: "usd",
        length: 30,
        status: "ACCEPTED",
        eventTypeId: "[redacted/dynamic]",
      },
    };
    test.beforeEach(async ({ users }) => {
      users.deleteAll();
      await loginUser(users);
    });
    test("Create booking", async ({ bookingPage }) => {
      const webhookReceiver = createHttpServer();
      await bookingPage.createBookingWebhook(webhookReceiver, "30 min");
      const eventTypePage = await bookingPage.previewEventType();
      await bookEventOnThisPage(eventTypePage);
      await webhookReceiver.waitForRequestCount(2);

      const [_, bookingCreatedRequest] = webhookReceiver.requestList;
      const body = updateBody(bookingCreatedRequest.body);

      expect(body).toMatchObject({ ...bodyProps, triggerEvent: "BOOKING_CREATED" });
      webhookReceiver.close();
    });

    test("Booking rescheduled", async ({ bookingPage }) => {
      const webhookReceiver = createHttpServer();
      await bookingPage.createBookingWebhook(webhookReceiver, "30 min");
      const eventTypePage = await bookingPage.previewEventType();
      await bookEventOnThisPage(eventTypePage);
      await bookingPage.rescheduleBooking(eventTypePage);

      await webhookReceiver.waitForRequestCount(3);

      const [_, bookingCreatedRequest, bookingRescheduledRequest] = webhookReceiver.requestList;

      const body = updateBody(bookingRescheduledRequest.body);

      expect(body).toMatchObject({ ...bodyProps, triggerEvent: "BOOKING_RESCHEDULED" });
      webhookReceiver.close();
    });

    test("Booking cancelled", async ({ bookingPage }) => {
      const webhookReceiver = createHttpServer();
      await bookingPage.createBookingWebhook(webhookReceiver, "30 min");
      const eventTypePage = await bookingPage.previewEventType();
      await bookEventOnThisPage(eventTypePage);
      await bookingPage.cancelBooking(eventTypePage);

      await webhookReceiver.waitForRequestCount(3);

      const [_, _bookingCreatedRequest, bookingCancelledRequest] = webhookReceiver.requestList;

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const body = updateBody(bookingCancelledRequest.body);

      expect(body).toMatchObject({
        ...bodyProps,
        triggerEvent: "BOOKING_CANCELLED",
        payload: {
          ...bodyProps.payload,
          team: { name: "Nameless", members: [] },
          cancellationReason: "Test cancel",
          destinationCalendar: [],
          seatsShowAttendees: false,
          status: "CANCELLED",
          price: null,
          requiresConfirmation: null,
          responses: {
            ...bodyProps.payload.responses,
            name: { label: "name", value: "Test Testson" },
            guests: { label: "guests", value: [] },
          },
        },
      });
      webhookReceiver.close();
    });

    test("Booking rejected", async ({ page, users, bookingPage }) => {
      const webhookReceiver = createHttpServer();
      await bookingPage.createBookingWebhook(webhookReceiver, "Opt in");
      await page.goto(`/${users.get()[0].username}`);
      await bookOptinEvent(page);

      await bookingPage.rejectFirstBooking();
      await webhookReceiver.waitForRequestCount(3);
      const [_, _bookingCreatedRequest, bookingRejectedRequest] = webhookReceiver.requestList;

      const body = updateBody(bookingRejectedRequest.body);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const bodyPropsCopy: any = { ...bodyProps };

      delete bodyPropsCopy.payload.seatsPerTimeSlot;
      delete bodyPropsCopy.payload.seatsShowAttendees;

      expect(body).toMatchObject({
        ...bodyPropsCopy,
        triggerEvent: "BOOKING_REJECTED",
        payload: {
          ...bodyPropsCopy.payload,
          status: "REJECTED",
          requiresConfirmation: true,
          title: "Opt in between testuser and Test Testson",
          type: "opt-in",
          eventTitle: "Opt in",
          destinationCalendar: [],
          responses: {
            ...bodyProps.payload.responses,
            name: { label: "name", value: "Test Testson" },
            guests: { label: "guests", value: [] },
          },
        },
      });
      webhookReceiver.close();
    });

    test("Booking requested", async ({ page, users, bookingPage }) => {
      const webhookReceiver = createHttpServer();
      await bookingPage.createBookingWebhook(webhookReceiver, "Opt in");
      await page.goto(`/${users.get()[0].username}`);
      await bookOptinEvent(page);
      await webhookReceiver.waitForRequestCount(2);
      const [_, bookingRequestedRequest] = webhookReceiver.requestList;

      const body = updateBody(bookingRequestedRequest.body);

      expect(body).toMatchObject({
        ...bodyProps,
        triggerEvent: "BOOKING_REQUESTED",
        payload: {
          ...bodyProps.payload,
          title: "Opt in between testuser and Test Testson",
          bookerUrl: WEBAPP_URL,
          hideCalendarNotes: false,
          status: "PENDING",
          requiresConfirmation: true,
          type: "opt-in",
          eventTitle: "Opt in",
        },
      });
      webhookReceiver.close();
    });
  });
});

async function clickFirstTeamWebhookCta(page: Page) {
  await page.click('[data-testid="new_webhook"]');
  await page.click('[data-testid="option-team-1"]');
  await page.waitForURL((u) => u.pathname === "/settings/developer/webhooks/new");
  const url = page.url();
  const teamId = Number(new URL(url).searchParams.get("teamId")) as number;
  return teamId;
}
import { expect } from "@playwright/test";

import { IS_TEAM_BILLING_ENABLED } from "@calcom/lib/constants";
import { prisma } from "@calcom/prisma";
import { MembershipRole, SchedulingType } from "@calcom/prisma/enums";

import { test } from "./lib/fixtures";
import { testBothFutureAndLegacyRoutes } from "./lib/future-legacy-routes";
import {
  bookTimeSlot,
  doOnOrgDomain,
  fillStripeTestCheckout,
  NotFoundPageTextAppDir,
  selectFirstAvailableTimeSlotNextMonth,
  testName,
  todo,
} from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });

testBothFutureAndLegacyRoutes.describe("Teams A/B tests", (routeVariant) => {
  test("should render the /teams page", async ({ page, users, context }) => {
    // TODO: Revert until OOM issue is resolved
    test.skip(routeVariant === "future", "Future route not ready yet");

    const user = await users.create();

    await user.apiLogin();

    await page.goto("/teams");

    await page.waitForLoadState();

    const locator = page.getByRole("heading", { name: "Teams", exact: true });

    await expect(locator).toBeVisible();
  });
});

testBothFutureAndLegacyRoutes.describe("Teams - NonOrg", (routeVariant) => {
  test.afterEach(({ users }) => users.deleteAll());

  test("Team Onboarding Invite Members", async ({ page, users }) => {
    const user = await users.create(undefined, { hasTeam: true });

    const { team } = await user.getFirstTeamMembership();

    const inviteeEmail = `${user.username}+invitee@example.com`;

    await user.apiLogin();

    page.goto(`/settings/teams/${team.id}/onboard-members`);

    await test.step("Can add members", async () => {
      // Click [data-testid="new-member-button"]
      await page.locator('[data-testid="new-member-button"]').click();
      // Fill [placeholder="email\@example\.com"]
      await page.locator('[placeholder="email\\@example\\.com"]').fill(inviteeEmail);
      // Click [data-testid="invite-new-member-button"]
      await page.locator('[data-testid="invite-new-member-button"]').click();
      await expect(page.locator(`li:has-text("${inviteeEmail}")`)).toBeVisible();
      expect(await page.locator('[data-testid="pending-member-item"]').count()).toBe(2);
    });

    await test.step("Can remove members", async () => {
      const removeMemberButton = page.locator('[data-testid="remove-member-button"]');
      await removeMemberButton.click();
      await removeMemberButton.waitFor({ state: "hidden" });
      expect(await page.locator('[data-testid="pending-member-item"]').count()).toBe(1);
      // Cleanup here since this user is created without our fixtures.
      await prisma.user.delete({ where: { email: inviteeEmail } });
    });

    await test.step("Finishing brings you to team profile page", async () => {
      await page.locator("[data-testid=publish-button]").click();
      await expect(page).toHaveURL(/\/settings\/teams\/(\d+)\/profile$/i);
    });

    await test.step("Can disband team", async () => {
      await page.locator("text=Disband Team").click();
      await page.locator("text=Yes, disband team").click();
      await page.waitForURL("/teams");
      await expect(await page.locator(`text=${user.username}'s Team`).count()).toEqual(0);
      // FLAKY: If other tests are running async this may mean there are >0 teams, empty screen will not be shown.
      // await expect(page.locator('[data-testid="empty-screen"]')).toBeVisible();
    });
  });

  test("Can create a booking for Collective EventType", async ({ page, users }) => {
    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(
      { username: "pro-user", name: "pro-user" },
      {
        hasTeam: true,
        teammates: teamMatesObj,
        schedulingType: SchedulingType.COLLECTIVE,
      }
    );

    const { team } = await owner.getFirstTeamMembership();

    const { title: teamEventTitle, slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);

    await page.goto(`/team/${team.slug}/${teamEventSlug}`);
    await selectFirstAvailableTimeSlotNextMonth(page);
    await bookTimeSlot(page);
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    // The title of the booking
    const BookingTitle = `${teamEventTitle} between ${team.name} and ${testName}`;
    await expect(page.locator("[data-testid=booking-title]")).toHaveText(BookingTitle);
    // The booker should be in the attendee list
    await expect(page.locator(`[data-testid="attendee-name-${testName}"]`)).toHaveText(testName);

    // All the teammates should be in the booking
    for (const teammate of teamMatesObj) {
      await expect(page.getByText(teammate.name, { exact: true })).toBeVisible();
    }

    // TODO: Assert whether the user received an email
  });

  test("Can create a booking for Round Robin EventType", async ({ page, users }) => {
    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(
      { username: "pro-user", name: "pro-user" },
      {
        hasTeam: true,
        teammates: teamMatesObj,
        schedulingType: SchedulingType.ROUND_ROBIN,
      }
    );

    const { team } = await owner.getFirstTeamMembership();

    const { title: teamEventTitle, slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);

    await page.goto(`/team/${team.slug}/${teamEventSlug}`);
    await selectFirstAvailableTimeSlotNextMonth(page);
    await bookTimeSlot(page);
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    // The person who booked the meeting should be in the attendee list
    await expect(page.locator(`[data-testid="attendee-name-${testName}"]`)).toHaveText(testName);

    // The title of the booking
    const BookingTitle = `${teamEventTitle} between ${team.name} and ${testName}`;
    await expect(page.locator("[data-testid=booking-title]")).toHaveText(BookingTitle);

    // Since all the users have the same leastRecentlyBooked value
    // Anyone of the teammates could be the Host of the booking.
    const chosenUser = await page.getByTestId("booking-host-name").textContent();
    expect(chosenUser).not.toBeNull();
    expect(teamMatesObj.concat([{ name: owner.name! }]).some(({ name }) => name === chosenUser)).toBe(true);
    // TODO: Assert whether the user received an email
  });

  test("Non admin team members cannot create team in org", async ({ page, users }) => {
    test.skip(routeVariant === "future", "Future route not ready yet");

    const teamMateName = "teammate-1";

    const owner = await users.create(undefined, {
      hasTeam: true,
      isOrg: true,
      teammates: [{ name: teamMateName }],
    });

    const allUsers = await users.get();

    const memberUser = allUsers.find((user) => user.name === teamMateName);

    // eslint-disable-next-line playwright/no-conditional-in-test
    if (memberUser) {
      await memberUser.apiLogin();

      await page.goto("/teams");
      await expect(page.locator("[data-testid=new-team-btn]")).toBeHidden();
      await expect(page.locator("[data-testid=create-team-btn]")).toHaveAttribute("disabled", "");

      const uniqueName = "test-unique-team-name";

      // Go directly to the create team page
      await page.goto("/settings/teams/new");
      // Fill input[name="name"]
      await page.locator('input[name="name"]').fill(uniqueName);
      await page.click("[type=submit]");

      // cleanup
      const org = await owner.getOrgMembership();
      await prisma.team.delete({ where: { id: org.teamId } });
    }
  });

  test("Can create team with same name as user", async ({ page, users }) => {
    test.skip(routeVariant === "future", "Future route not ready yet");

    const user = await users.create();
    // Name to be used for both user and team
    const uniqueName = user.username!;
    await user.apiLogin();
    await page.goto("/teams");

    await test.step("Can create team with same name", async () => {
      // Click text=Create Team
      await page.locator("text=Create Team").click();
      await page.waitForURL("/settings/teams/new");
      // Fill input[name="name"]
      await page.locator('input[name="name"]').fill(uniqueName);
      // Click text=Continue
      await page.click("[type=submit]");
      // TODO: Figure out a way to make this more reliable
      // eslint-disable-next-line playwright/no-conditional-in-test
      if (IS_TEAM_BILLING_ENABLED) await fillStripeTestCheckout(page);
      await page.waitForURL(/\/settings\/teams\/(\d+)\/onboard-members.*$/i);
      // Click text=Continue
      await page.locator("[data-testid=publish-button]").click();
      await expect(page).toHaveURL(/\/settings\/teams\/(\d+)\/profile$/i);
    });

    await test.step("Can access user and team with same slug", async () => {
      // Go to team page and confirm name
      const teamUrl = `/team/${uniqueName}`;
      await page.goto(teamUrl);
      await page.waitForURL(teamUrl);
      await expect(page.locator("[data-testid=team-name]")).toHaveText(uniqueName);

      // Go to user page and confirm name
      const userUrl = `/${uniqueName}`;
      await page.goto(userUrl);
      await page.waitForURL(userUrl);
      await expect(page.locator("[data-testid=name-title]")).toHaveText(uniqueName);

      // cleanup team
      await prisma.team.deleteMany({ where: { slug: uniqueName } });
    });
  });

  test("Can create a private team", async ({ page, users }) => {
    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(
      { username: "pro-user", name: "pro-user" },
      {
        hasTeam: true,
        teammates: teamMatesObj,
        schedulingType: SchedulingType.COLLECTIVE,
      }
    );

    await owner.apiLogin();

    const { team } = await owner.getFirstTeamMembership();

    // Mark team as private
    await page.goto(`/settings/teams/${team.id}/members`);
    await Promise.all([
      page.click("[data-testid=make-team-private-check]"),
      expect(page.locator(`[data-testid=make-team-private-check][data-state="checked"]`)).toBeVisible(),
      // according to switch implementation, checked state can be set before mutation is resolved
      // so we need to await for req to resolve
      page.waitForResponse((res) => res.url().includes("/api/trpc/teams/update")),
    ]);

    // Go to Team's page
    await page.goto(`/team/${team.slug}`);
    await expect(page.locator('[data-testid="book-a-team-member-btn"]')).toBeHidden();

    // Go to members page
    await page.goto(`/team/${team.slug}?members=1`);
    await expect(page.locator('[data-testid="you-cannot-see-team-members"]')).toBeVisible();
    await expect(page.locator('[data-testid="team-members-container"]')).toBeHidden();
  });

  todo("Create a Round Robin with different leastRecentlyBooked hosts");
  todo("Reschedule a Collective EventType booking");
  todo("Reschedule a Round Robin EventType booking");
});

test.describe("Teams - Org", () => {
  test.afterEach(({ orgs, users }) => {
    orgs.deleteAll();
    users.deleteAll();
  });

  test("Can create teams via Wizard", async ({ page, users, orgs }) => {
    const org = await orgs.create({
      name: "TestOrg",
    });

    const user = await users.create({
      organizationId: org.id,
      roleInOrganization: MembershipRole.ADMIN,
    });

    const inviteeEmail = `${user.username}+invitee@example.com`;
    await user.apiLogin();
    await page.goto("/teams");

    await test.step("Can create team", async () => {
      // Click text=Create Team
      await page.locator("text=Create a new Team").click();
      await page.waitForURL((url) => url.pathname === "/settings/teams/new");
      // Fill input[name="name"]
      await page.locator('input[name="name"]').fill(`${user.username}'s Team`);
      // Click text=Continue
      await page.click("[type=submit]");
      // TODO: Figure out a way to make this more reliable
      // eslint-disable-next-line playwright/no-conditional-in-test
      if (IS_TEAM_BILLING_ENABLED) await fillStripeTestCheckout(page);
      await expect(page).toHaveURL(/\/settings\/teams\/(\d+)\/onboard-members.*$/i);
      await page.waitForSelector('[data-testid="pending-member-list"]');
      expect(await page.getByTestId("pending-member-item").count()).toBe(1);
    });

    await test.step("Can add members", async () => {
      await page.getByTestId("new-member-button").click();
      await page.locator('[placeholder="email\\@example\\.com"]').fill(inviteeEmail);
      await page.getByTestId("invite-new-member-button").click();
      await expect(page.locator(`li:has-text("${inviteeEmail}")`)).toBeVisible();

      // locator.count() does not await for the expected number of elements
      // https://github.com/microsoft/playwright/issues/14278
      // using toHaveCount() is more reliable
      await expect(page.getByTestId("pending-member-item")).toHaveCount(2);
    });

    await test.step("Can remove members", async () => {
      await expect(page.getByTestId("pending-member-item")).toHaveCount(2);
      const lastRemoveMemberButton = page.getByTestId("remove-member-button").last();
      await lastRemoveMemberButton.click();
      await page.waitForLoadState("networkidle");
      await expect(page.getByTestId("pending-member-item")).toHaveCount(1);

      // Cleanup here since this user is created without our fixtures.
      await prisma.user.delete({ where: { email: inviteeEmail } });
    });

    await test.step("Can finish team creation", async () => {
      await page.getByTestId("publish-button").click();
      await expect(page).toHaveURL(/\/settings\/teams\/(\d+)\/profile$/i);
    });

    await test.step("Can disband team", async () => {
      await page.waitForURL(/\/settings\/teams\/(\d+)\/profile$/i);
      await page.getByTestId("disband-team-button").click();
      await page.getByTestId("dialog-confirmation").click();
      await page.waitForURL("/teams");
      expect(await page.locator(`text=${user.username}'s Team`).count()).toEqual(0);
    });
  });

  test("Can create a booking for Collective EventType", async ({ page, users, orgs }) => {
    const org = await orgs.create({
      name: "TestOrg",
    });

    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(
      {
        username: "pro-user",
        name: "pro-user",
        organizationId: org.id,
        roleInOrganization: MembershipRole.MEMBER,
      },
      {
        hasTeam: true,
        teammates: teamMatesObj,
        schedulingType: SchedulingType.COLLECTIVE,
      }
    );

    const { team } = await owner.getFirstTeamMembership();

    const { title: teamEventTitle, slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);

    await page.goto(`/team/${team.slug}/${teamEventSlug}`);

    await expect(page.locator(`text=${NotFoundPageTextAppDir}`)).toBeVisible();
    await doOnOrgDomain(
      {
        orgSlug: org.slug,
        page,
      },
      async () => {
        await page.goto(`/team/${team.slug}/${teamEventSlug}`);
        await selectFirstAvailableTimeSlotNextMonth(page);
        await bookTimeSlot(page);
        await expect(page.getByTestId("success-page")).toBeVisible();

        // The title of the booking
        const BookingTitle = `${teamEventTitle} between ${team.name} and ${testName}`;
        await expect(page.getByTestId("booking-title")).toHaveText(BookingTitle);
        // The booker should be in the attendee list
        await expect(page.getByTestId(`attendee-name-${testName}`)).toHaveText(testName);

        // All the teammates should be in the booking
        for (const teammate of teamMatesObj.concat([{ name: owner.name || "" }])) {
          await expect(page.getByText(teammate.name, { exact: true })).toBeVisible();
        }
      }
    );

    // TODO: Assert whether the user received an email
  });

  test("Can create a booking for Round Robin EventType", async ({ page, users }) => {
    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(
      { username: "pro-user", name: "pro-user" },
      {
        hasTeam: true,
        teammates: teamMatesObj,
        schedulingType: SchedulingType.ROUND_ROBIN,
      }
    );

    const { team } = await owner.getFirstTeamMembership();

    const { title: teamEventTitle, slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);

    await page.goto(`/team/${team.slug}/${teamEventSlug}`);
    await selectFirstAvailableTimeSlotNextMonth(page);
    await bookTimeSlot(page);
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    // The person who booked the meeting should be in the attendee list
    await expect(page.getByTestId(`attendee-name-${testName}`)).toHaveText(testName);

    // The title of the booking
    const BookingTitle = `${teamEventTitle} between ${team.name} and ${testName}`;
    await expect(page.getByTestId("booking-title")).toHaveText(BookingTitle);

    // Since all the users have the same leastRecentlyBooked value
    // Anyone of the teammates could be the Host of the booking.
    const chosenUser = await page.getByTestId("booking-host-name").textContent();
    expect(chosenUser).not.toBeNull();
    expect(teamMatesObj.concat([{ name: owner.name! }]).some(({ name }) => name === chosenUser)).toBe(true);
    // TODO: Assert whether the user received an email
  });

  test("Can access booking page with event slug and team page in lowercase/uppercase/mixedcase", async ({
    page,
    orgs,
    users,
  }) => {
    const org = await orgs.create({
      name: "TestOrg",
    });

    const teamMatesObj = [
      { name: "teammate-1" },
      { name: "teammate-2" },
      { name: "teammate-3" },
      { name: "teammate-4" },
    ];

    const owner = await users.create(
      {
        username: "pro-user",
        name: "pro-user",
        organizationId: org.id,
        roleInOrganization: MembershipRole.MEMBER,
      },
      {
        hasTeam: true,
        teammates: teamMatesObj,
        schedulingType: SchedulingType.COLLECTIVE,
      }
    );

    const { team } = await owner.getFirstTeamMembership();

    const { slug: teamEventSlug } = await owner.getFirstTeamEvent(team.id);

    const teamSlugUpperCase = team.slug?.toUpperCase();

    const teamEventSlugUpperCase = teamEventSlug.toUpperCase();

    // This is the most closest to the actual user flow as org1.cal.com maps to /org/orgSlug
    await page.goto(`/org/${org.slug}/${teamSlugUpperCase}/${teamEventSlugUpperCase}`);
    await page.waitForSelector("[data-testid=day]");
  });
});
import { expect } from "@playwright/test";
import { randomBytes } from "crypto";

import { APP_NAME, IS_PREMIUM_USERNAME_ENABLED, IS_MAILHOG_ENABLED } from "@calcom/lib/constants";
import prisma from "@calcom/prisma";

import { test } from "./lib/fixtures";
import { getEmailsReceivedByUser, localize } from "./lib/testUtils";
import { expectInvitationEmailToBeReceived } from "./team/expects";

test.describe.configure({ mode: "parallel" });

test.describe("Signup Flow Test", async () => {
  test.beforeEach(async ({ features }) => {
    features.reset(); // This resets to the inital state not an empt yarray
  });
  test.afterAll(async ({ users }) => {
    await users.deleteAll();
  });
  test("Username is taken", async ({ page, users }) => {
    // log in trail user
    await test.step("Sign up", async () => {
      await users.create({
        username: "pro",
      });

      await page.goto("/signup");

      const alertMessage = "Username or email is already taken";

      // Fill form
      await page.locator('input[name="username"]').fill("pro");
      await page.locator('input[name="email"]').fill("pro@example.com");
      await page.locator('input[name="password"]').fill("Password99!");

      // Submit form
      await page.click('button[type="submit"]');

      const alert = await page.waitForSelector('[data-testid="alert"]');
      const alertMessageInner = await alert.innerText();

      expect(alertMessage).toBeDefined();
      expect(alertMessageInner).toContain(alertMessageInner);
    });
  });
  test("Email is taken", async ({ page, users }) => {
    // log in trail user
    await test.step("Sign up", async () => {
      const user = await users.create({
        username: "pro",
      });

      await page.goto("/signup");

      const alertMessage = "Username or email is already taken";

      // Fill form
      await page.locator('input[name="username"]').fill("randomuserwhodoesntexist");
      await page.locator('input[name="email"]').fill(user.email);
      await page.locator('input[name="password"]').fill("Password99!");

      // Submit form

      await page.click('button[type="submit"]');
      const alert = await page.waitForSelector('[data-testid="alert"]');
      const alertMessageInner = await alert.innerText();

      expect(alertMessage).toBeDefined();
      expect(alertMessageInner).toContain(alertMessageInner);
    });
  });
  test("Premium Username Flow - creates stripe checkout", async ({ page, users, prisma }) => {
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(!IS_PREMIUM_USERNAME_ENABLED, "Only run on Cal.com");

    const userToCreate = users.buildForSignup({
      username: "rock",
      password: "Password99!",
    });
    // Ensure the premium username is available
    await prisma.user.deleteMany({ where: { username: "rock" } });

    // Signup with premium username name
    await page.goto("/signup");

    // Fill form
    await page.locator('input[name="username"]').fill("rock");
    await page.locator('input[name="email"]').fill(userToCreate.email);
    await page.locator('input[name="password"]').fill(userToCreate.password);

    await page.click('button[type="submit"]');

    // Check that stripe checkout is present
    const expectedUrl = "https://checkout.stripe.com";

    await page.waitForURL((url) => url.href.startsWith(expectedUrl));

    const url = page.url();

    // Check that the URL matches the expected URL
    expect(url).toContain(expectedUrl);
    // TODO: complete the stripe checkout flow
  });
  test("Signup with valid (non premium) username", async ({ page, users, features }) => {
    const userToCreate = users.buildForSignup({
      username: "rick-jones",
      password: "Password99!",
      // Email intentonally kept as different from username
      email: `rickjones${Math.random()}-${Date.now()}@example.com`,
    });

    await page.goto("/signup");

    // Fill form
    await page.locator('input[name="username"]').fill(userToCreate.username);
    await page.locator('input[name="email"]').fill(userToCreate.email);
    await page.locator('input[name="password"]').fill(userToCreate.password);

    await page.click('button[type="submit"]');
    await page.waitForLoadState("networkidle");
    // Find the newly created user and add it to the fixture store
    const newUser = await users.set(userToCreate.email);
    expect(newUser).not.toBeNull();

    // Check that the URL matches the expected URL
    expect(page.url()).toContain("/auth/verify-email");

    const dbUser = await prisma.user.findUnique({ where: { email: userToCreate.email } });
    // Verify that the username is the same as the one provided and isn't accidentally changed to email derived username - That happens only for organization member signup
    expect(dbUser?.username).toBe(userToCreate.username);
  });
  test("Signup fields prefilled with query params", async ({ page, users }) => {
    const signupUrlWithParams = "/signup?username=rick-jones&email=rick-jones%40example.com";
    await page.goto(signupUrlWithParams);

    // Fill form
    const usernameInput = page.locator('input[name="username"]');

    const emailInput = page.locator('input[name="email"]');

    expect(await usernameInput.inputValue()).toBe("rick-jones");
    expect(await emailInput.inputValue()).toBe("rick-jones@example.com");
  });
  test("Signup with token prefils correct fields", async ({ page, users, prisma }) => {
    //Create a user and create a token
    const token = randomBytes(32).toString("hex");

    const userToCreate = users.buildForSignup({
      username: "rick-team",
    });

    const createdtoken = await prisma.verificationToken.create({
      data: {
        identifier: userToCreate.email,
        token,
        expires: new Date(new Date().setHours(168)), // +1 week
        team: {
          create: {
            name: "Rick's Team",
            slug: `${userToCreate.username}-team`,
          },
        },
      },
    });

    // create a user with the same email as the token
    const rickTeamUser = await prisma.user.create({
      data: {
        email: userToCreate.email,
        username: userToCreate.username,
      },
    });

    // Create provitional membership
    await prisma.membership.create({
      data: {
        teamId: createdtoken.teamId ?? -1,
        userId: rickTeamUser.id,
        role: "ADMIN",
        accepted: false,
      },
    });

    const signupUrlWithToken = `/signup?token=${token}`;

    await page.goto(signupUrlWithToken);

    const usernameField = page.locator('input[name="username"]');

    const emailField = page.locator('input[name="email"]');

    expect(await usernameField.inputValue()).toBe(userToCreate.username);
    expect(await emailField.inputValue()).toBe(userToCreate.email);

    // Cleanup specific to this test
    // Clean up the user and token
    await prisma.user.deleteMany({ where: { email: userToCreate.email } });
    await prisma.verificationToken.deleteMany({ where: { identifier: createdtoken.identifier } });
    await prisma.team.deleteMany({ where: { id: createdtoken.teamId! } });
  });
  test("Email verification sent if enabled", async ({ page, prisma, emails, users, features }) => {
    const EmailVerifyFlag = features.get("email-verification")?.enabled;

    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(!EmailVerifyFlag || !IS_MAILHOG_ENABLED, "Skipping check - Email verify disabled");
    // Ensure email verification before testing (TODO: this could break other tests but we can fix that later)
    await prisma.feature.update({
      where: { slug: "email-verification" },
      data: { enabled: true },
    });

    const userToCreate = users.buildForSignup({
      email: users.trackEmail({ username: "email-verify", domain: "example.com" }),
      username: "email-verify",
      password: "Password99!",
    });

    await page.goto("/signup");

    // Fill form
    await page.locator('input[name="username"]').fill(userToCreate.username);
    await page.locator('input[name="email"]').fill(userToCreate.email);
    await page.locator('input[name="password"]').fill(userToCreate.password);

    await page.click('button[type="submit"]');

    await page.waitForURL((url) => url.pathname.includes("/auth/verify-email"));
    // Find the newly created user and add it to the fixture store
    const newUser = await users.set(userToCreate.email);
    expect(newUser).not.toBeNull();

    const receivedEmails = await getEmailsReceivedByUser({
      emails,
      userEmail: userToCreate.email,
    });

    // We need to wait for emails to be sent
    // eslint-disable-next-line playwright/no-wait-for-timeout
    await page.waitForTimeout(5000);

    expect(receivedEmails?.total).toBe(1);

    const verifyEmail = receivedEmails?.items[0];
    expect(verifyEmail?.subject).toBe(`${APP_NAME}: Verify your account`);
  });
  test("If signup is disabled allow team invites", async ({ browser, page, users, emails }) => {
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(process.env.NEXT_PUBLIC_DISABLE_SIGNUP !== "true", "Skipping due to signup being enabled");

    const t = await localize("en");

    const teamOwner = await users.create(undefined, { hasTeam: true });

    const { team } = await teamOwner.getFirstTeamMembership();
    await teamOwner.apiLogin();
    await page.goto(`/settings/teams/${team.id}/members`);
    await page.waitForLoadState("networkidle");

    await test.step("Invite User to team", async () => {
      // TODO: This invite logic should live in a fixture - its used in team and orgs invites (Duplicated from team/org invites)
      const invitedUserEmail = `rick_${Date.now()}@domain-${Date.now()}.com`;
      await page.locator(`button:text("${t("add")}")`).click();
      await page.locator('input[name="inviteUser"]').fill(invitedUserEmail);
      await page.locator(`button:text("${t("send_invite")}")`).click();
      await page.waitForLoadState("networkidle");
      const inviteLink = await expectInvitationEmailToBeReceived(
        page,
        emails,
        invitedUserEmail,
        `${team.name}'s admin invited you to join the team ${team.name} on Cal.com`,
        "signup?token"
      );

      //Check newly invited member exists and is pending
      await expect(
        page.locator(`[data-testid="email-${invitedUserEmail.replace("@", "")}-pending"]`)
      ).toHaveCount(1);

      // eslint-disable-next-line playwright/no-conditional-in-test
      if (!inviteLink) return;

      // Follow invite link to new window
      const context = await browser.newContext();
      const newPage = await context.newPage();
      await newPage.goto(inviteLink);
      await newPage.waitForLoadState("networkidle");

      const url = new URL(newPage.url());
      expect(url.pathname).toBe("/signup");

      // Check required fields
      await newPage.locator("input[name=password]").fill(`P4ssw0rd!`);
      await newPage.locator("button[type=submit]").click();
      await newPage.waitForURL("/getting-started?from=signup");
      await newPage.close();
      await context.close();
    });
  });
});
import type { Page, Route } from "@playwright/test";
import { expect } from "@playwright/test";
import type { DefaultBodyType } from "msw";
import { rest } from "msw";
import { setupServer } from "msw/node";
import { v4 as uuidv4 } from "uuid";

import { prisma } from "@calcom/prisma";

import { test } from "./lib/fixtures";
import { todo } from "./lib/testUtils";

declare let global: {
  E2E_EMAILS?: ({ text: string } | Record<string, unknown>)[];
};

const requestInterceptor = setupServer(
  rest.post("https://api.hubapi.com/oauth/v1/token", (req, res, ctx) => {
    console.log(req.body);

    return res(ctx.status(200));
  })
);

const addOauthBasedIntegration = async function ({
  page,
  slug,
  authorization,
  token,
}: {
  page: Page;
  slug: string;
  authorization: {
    url: string;
    verify: (config: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      requestHeaders: any;
      params: URLSearchParams;
      code: string;
    }) => Parameters<Route["fulfill"]>[0];
  };
  token: {
    url: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    verify: (config: { requestHeaders: any; params: URLSearchParams; code: string }) => {
      status: number;
      body: DefaultBodyType;
    };
  };
}) {
  const code = uuidv4();
  // Note the difference b/w MSW wildcard and Playwright wildards. Playwright requires query params to be explicitly specified.
  page.route(`${authorization.url}?**`, (route, request) => {
    const u = new URL(request.url());

    const result = authorization.verify({
      requestHeaders: request.allHeaders(),
      params: u.searchParams,
      code,
    });

    return route.fulfill(result);
  });
  requestInterceptor.use(
    rest.post(token.url, (req, res, ctx) => {
      const params = new URLSearchParams(req.body as string);
      const result = token.verify({ requestHeaders: req.headers, params, code });

      return res(ctx.status(result.status), ctx.json(result.body));
    })
  );

  await page.goto(`/apps/${slug}`);
  await page.click('[data-testid="install-app-button"]');
};

const addLocationIntegrationToFirstEvent = async function ({ user }: { user: { username: string | null } }) {
  const eventType = await prisma.eventType.findFirst({
    where: {
      users: {
        some: {
          username: user.username,
        },
      },
      price: 0,
    },
  });

  if (!eventType) {
    throw new Error("Event type not found");
  }
  await prisma.eventType.update({
    where: {
      id: eventType.id,
    },
    data: {
      locations: [{ type: "integrations:zoom" }],
    },
  });
  return eventType;
};

async function bookEvent(page: Page, calLink: string) {
  // Let current month dates fully render.
  // There is a bug where if we don't let current month fully render and quickly click go to next month, current month get's rendered
  // This doesn't seem to be replicable with the speed of a person, only during automation.
  // It would also allow correct snapshot to be taken for current month.
  // eslint-disable-next-line playwright/no-wait-for-timeout
  await page.waitForTimeout(1000);
  await page.goto(`/${calLink}`);

  await page.locator('[data-testid="day"][data-disabled="false"]').nth(0).click();
  page.locator('[data-testid="time"]').nth(0).click();
  await page.waitForNavigation({
    url(url) {
      return url.pathname.includes("/book");
    },
  });
  const meetingId = 123456789;

  requestInterceptor.use(
    rest.post("https://api.zoom.us/v2/users/me/meetings", (req, res, ctx) => {
      return res(
        ctx.status(200),
        ctx.json({
          id: meetingId,
          password: "TestPass",
          join_url: `https://zoom.us/j/${meetingId}`,
        })
      );
    })
  );
  // --- fill form
  await page.fill('[name="name"]', "Integration User");
  await page.fill('[name="email"]', "integration-user@example.com");
  await page.press('[name="email"]', "Enter");
  const response = await page.waitForResponse("**/api/book/event");
  const responseObj = await response.json();
  const bookingId = responseObj.uid;
  await page.waitForSelector("[data-testid=success-page]");
  // Make sure we're navigated to the success page
  await expect(page.locator("[data-testid=success-page]")).toBeVisible();
  expect(global.E2E_EMAILS?.length).toBe(2);
  expect(
    global.E2E_EMAILS?.every((email) => (email.text as string).includes(`https://zoom.us/j/${meetingId}`))
  ).toBe(true);
  return bookingId;
}

test.describe.configure({ mode: "parallel" });

// Enable API mocking before tests.
test.beforeAll(() =>
  requestInterceptor.listen({
    // Comment this to log which all requests are going that are unmocked
    onUnhandledRequest: "bypass",
  })
);

// Reset any runtime request handlers we may add during the tests.
test.afterEach(() => requestInterceptor.resetHandlers());

// Disable API mocking after the tests are done.
test.afterAll(() => requestInterceptor.close());
test.afterEach(({ users }) => users.deleteAll());

// TODO: Fix MSW mocking
test.fixme("Integrations", () => {
  test.beforeEach(() => {
    global.E2E_EMAILS = [];
  });
  const addZoomIntegration = async function ({ page }: { page: Page }) {
    await addOauthBasedIntegration({
      page,
      slug: "zoom",
      authorization: {
        url: "https://zoom.us/oauth/authorize",
        verify({ params, code }) {
          expect(params.get("redirect_uri")).toBeTruthy();
          return {
            status: 307,
            headers: {
              location: `${params.get("redirect_uri")}?code=${code}`,
            },
          };
        },
      },
      token: {
        url: "https://zoom.us/oauth/token",
        verify({ requestHeaders }) {
          const authorization = requestHeaders.get("authorization").replace("Basic ", "");
          const clientPair = Buffer.from(authorization, "base64").toString();
          const [clientId, clientSecret] = clientPair.split(":");
          // Ensure that zoom credentials are passed.
          // TODO: We should also ensure that these credentials are correct e.g. in this case should be READ from DB
          expect(clientId).toBeTruthy();
          expect(clientSecret).toBeTruthy();

          return {
            status: 200,
            body: {
              access_token:
                "eyJhbGciOiJIUzUxMiIsInYiOiIyLjAiLCJraWQiOiI8S0lEPiJ9.eyJ2ZXIiOiI2IiwiY2xpZW50SWQiOiI8Q2xpZW50X0lEPiIsImNvZGUiOiI8Q29kZT4iLCJpc3MiOiJ1cm46em9vbTpjb25uZWN0OmNsaWVudGlkOjxDbGllbnRfSUQ-IiwiYXV0aGVudGljYXRpb25JZCI6IjxBdXRoZW50aWNhdGlvbl9JRD4iLCJ1c2VySWQiOiI8VXNlcl9JRD4iLCJncm91cE51bWJlciI6MCwiYXVkIjoiaHR0cHM6Ly9vYXV0aC56b29tLnVzIiwiYWNjb3VudElkIjoiPEFjY291bnRfSUQ-IiwibmJmIjoxNTgwMTQ2OTkzLCJleHAiOjE1ODAxNTA1OTMsInRva2VuVHlwZSI6ImFjY2Vzc190b2tlbiIsImlhdCI6MTU4MDE0Njk5MywianRpIjoiPEpUST4iLCJ0b2xlcmFuY2VJZCI6MjV9.F9o_w7_lde4Jlmk_yspIlDc-6QGmVrCbe_6El-xrZehnMx7qyoZPUzyuNAKUKcHfbdZa6Q4QBSvpd6eIFXvjHw",
              token_type: "bearer",
              refresh_token:
                "eyJhbGciOiJIUzUxMiIsInYiOiIyLjAiLCJraWQiOiI8S0lEPiJ9.eyJ2ZXIiOiI2IiwiY2xpZW50SWQiOiI8Q2xpZW50X0lEPiIsImNvZGUiOiI8Q29kZT4iLCJpc3MiOiJ1cm46em9vbTpjb25uZWN0OmNsaWVudGlkOjxDbGllbnRfSUQ-IiwiYXV0aGVudGljYXRpb25JZCI6IjxBdXRoZW50aWNhdGlvbl9JRD4iLCJ1c2VySWQiOiI8VXNlcl9JRD4iLCJncm91cE51bWJlciI6MCwiYXVkIjoiaHR0cHM6Ly9vYXV0aC56b29tLnVzIiwiYWNjb3VudElkIjoiPEFjY291bnRfSUQ-IiwibmJmIjoxNTgwMTQ2OTkzLCJleHAiOjIwNTMxODY5OTMsInRva2VuVHlwZSI6InJlZnJlc2hfdG9rZW4iLCJpYXQiOjE1ODAxNDY5OTMsImp0aSI6IjxKVEk-IiwidG9sZXJhbmNlSWQiOjI1fQ.Xcn_1i_tE6n-wy6_-3JZArIEbiP4AS3paSD0hzb0OZwvYSf-iebQBr0Nucupe57HUDB5NfR9VuyvQ3b74qZAfA",
              expires_in: 3599,
              // Without this permission, meeting can't be created.
              scope: "meeting:write",
            },
          };
        },
      },
    });
  };
  test.describe("Zoom App", () => {
    test("Can add integration", async ({ page, users }) => {
      const user = await users.create();
      await user.apiLogin();
      await addZoomIntegration({ page });
      await page.waitForNavigation({
        url: (url) => {
          return url.pathname === "/apps/installed";
        },
      });
      //TODO: Check that disconnect button is now visible
    });

    test("can choose zoom as a location during booking", async ({ page, users }) => {
      const user = await users.create();
      await user.apiLogin();
      const eventType = await addLocationIntegrationToFirstEvent({ user });
      await addZoomIntegration({ page });
      await page.waitForNavigation({
        url: (url) => {
          return url.pathname === "/apps/installed";
        },
      });

      await bookEvent(page, `${user.username}/${eventType.slug}`);
      // Ensure that zoom was informed about the meeting
      // Verify that email had zoom link
      // POST https://api.zoom.us/v2/users/me/meetings
      // Verify       Header->  Authorization: "Bearer " + accessToken,
      /**
       * {
      topic: event.title,
      type: 2, // Means that this is a scheduled meeting
      start_time: event.startTime,
      duration: (new Date(event.endTime).getTime() - new Date(event.startTime).getTime()) / 60000,
      //schedule_for: "string",   TODO: Used when scheduling the meeting for someone else (needed?)
      timezone: event.attendees[0].timeZone,
      //password: "string",       TODO: Should we use a password? Maybe generate a random one?
      agenda: event.description,
      settings: {
        host_video: true,
        participant_video: true,
        cn_meeting: false, // TODO: true if host meeting in China
        in_meeting: false, // TODO: true if host meeting in India
        join_before_host: true,
        mute_upon_entry: false,
        watermark: false,
        use_pmi: false,
        approval_type: 2,
        audio: "both",
        auto_recording: "none",
        enforce_apiLogin: false,
        registrants_email_notification: true,
      },
    };
       */
    });
    test("Can disconnect from integration", async ({ page, users }) => {
      const user = await users.create();
      await user.apiLogin();
      await addZoomIntegration({ page });
      await page.waitForNavigation({
        url: (url) => {
          return url.pathname === "/apps/installed";
        },
      });

      // FIXME: First time reaching /apps/installed throws error in UI.
      // Temporary use this hack to fix it but remove this HACK before merge.
      /** HACK STARTS */
      await page.locator('[href="/apps"]').first().click();
      await page.waitForNavigation({
        url: (url) => {
          return url.pathname === "/apps";
        },
      });
      await page.locator('[href="/apps/installed"]').first().click();
      /** HACK ENDS */

      await page.locator('[data-testid="zoom_video-integration-disconnect-button"]').click();
      await page.locator('[data-testid="confirm-button"]').click();
      await expect(page.locator('[data-testid="confirm-integration-disconnect-button"]')).toHaveCount(0);
    });
  });

  test.describe("Hubspot App", () => {
    test("Can add integration", async ({ page, users }) => {
      const user = await users.create();
      await user.apiLogin();
      await addOauthBasedIntegration({
        page,
        slug: "hubspot",
        authorization: {
          url: "https://app.hubspot.com/oauth/authorize",
          verify({ params, code }) {
            expect(params.get("redirect_uri")).toBeTruthy();
            // TODO: We can check if client_id is correctly read from DB or not
            expect(params.get("client_id")).toBeTruthy();
            expect(params.get("scope")).toBe(
              ["crm.objects.contacts.read", "crm.objects.contacts.write"].join(" ")
            );

            return {
              // TODO: Should
              status: 307,
              headers: {
                location: `${params.get("redirect_uri")}?code=${code}`,
              },
            };
          },
        },
        token: {
          url: "https://api.hubapi.com/oauth/v1/token",
          verify({ params, code }) {
            expect(params.get("grant_type")).toBe("authorization_code");
            expect(params.get("code")).toBe(code);
            expect(params.get("client_id")).toBeTruthy();
            expect(params.get("client_secret")).toBeTruthy();

            return {
              status: 200,
              body: {
                expiresIn: "3600",
              },
            };
          },
        },
      });
      await page.waitForNavigation({
        url: (url) => {
          return url.pathname === "/apps/installed";
        },
      });
    });
  });

  todo("Can add Google Calendar");

  todo("Can add Office 365 Calendar");

  todo("Can add CalDav Calendar");

  todo("Can add Apple Calendar");
});
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";

test.describe("Change Theme Test", () => {
  test("change theme to dark", async ({ page, users }) => {
    const pro = await users.create();
    await pro.apiLogin();

    await page.goto("/settings/my-account/appearance");

    await page.waitForLoadState("networkidle");
    //Click the "Dark" theme label
    await page.click('[data-testid="theme-dark"]');
    //Click the update button
    await page.click('[data-testid="update-theme-btn"]');
    //Wait for the toast to appear
    const toast = await page.waitForSelector('[data-testid="toast-success"]');
    expect(toast).toBeTruthy();
    //Go to the profile page and check if the theme is dark
    await page.goto(`/${pro.username}`);

    const darkModeClass = await page.getAttribute("html", "class");
    expect(darkModeClass).toContain("dark");
  });

  test("change theme to light", async ({ page, users }) => {
    const pro = await users.create();
    await pro.apiLogin();

    await page.goto("/settings/my-account/appearance");

    await page.waitForLoadState("networkidle");
    //Click the "Light" theme label
    await page.click('[data-testid="theme-light"]');
    //Click the update theme button
    await page.click('[data-testid="update-theme-btn"]');
    //Wait for the toast to appear
    const toast = await page.waitForSelector('[data-testid="toast-success"]');
    expect(toast).toBeTruthy();
    //Go to the profile page and check if the theme is light
    await page.goto(`/${pro.username}`);

    const darkModeClass = await page.getAttribute("html", "class");
    expect(darkModeClass).toContain("light");
  });
});
import type { Page } from "@playwright/test";
import { test as base } from "@playwright/test";

import prisma from "@calcom/prisma";

import type { ExpectedUrlDetails } from "../../../../playwright.config";
import { createBookingsFixture } from "../fixtures/bookings";
import { createEmailsFixture } from "../fixtures/emails";
import { createEmbedsFixture } from "../fixtures/embeds";
import { createEventTypeFixture } from "../fixtures/eventTypes";
import { createFeatureFixture } from "../fixtures/features";
import { createOrgsFixture } from "../fixtures/orgs";
import { createPaymentsFixture } from "../fixtures/payments";
import { createBookingPageFixture } from "../fixtures/regularBookings";
import { createRoutingFormsFixture } from "../fixtures/routingForms";
import { createServersFixture } from "../fixtures/servers";
import { createUsersFixture } from "../fixtures/users";
import { createWorkflowPageFixture } from "../fixtures/workflows";

export interface Fixtures {
  page: Page;
  orgs: ReturnType<typeof createOrgsFixture>;
  users: ReturnType<typeof createUsersFixture>;
  bookings: ReturnType<typeof createBookingsFixture>;
  payments: ReturnType<typeof createPaymentsFixture>;
  embeds: ReturnType<typeof createEmbedsFixture>;
  servers: ReturnType<typeof createServersFixture>;
  prisma: typeof prisma;
  emails: ReturnType<typeof createEmailsFixture>;
  routingForms: ReturnType<typeof createRoutingFormsFixture>;
  bookingPage: ReturnType<typeof createBookingPageFixture>;
  workflowPage: ReturnType<typeof createWorkflowPageFixture>;
  features: ReturnType<typeof createFeatureFixture>;
  eventTypePage: ReturnType<typeof createEventTypeFixture>;
}

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace PlaywrightTest {
    //FIXME: how to restrict it to Frame only
    interface Matchers<R> {
      toBeEmbedCalLink(
        calNamespace: string,
        // eslint-disable-next-line
        getActionFiredDetails: (a: { calNamespace: string; actionType: string }) => Promise<any>,
        expectedUrlDetails?: ExpectedUrlDetails,
        isPrendered?: boolean
      ): Promise<R>;
    }
  }
}

/**
 *  @see https://playwright.dev/docs/test-fixtures
 */
export const test = base.extend<Fixtures>({
  orgs: async ({ page }, use) => {
    const orgsFixture = createOrgsFixture(page);
    await use(orgsFixture);
  },
  users: async ({ page, context, emails }, use, workerInfo) => {
    const usersFixture = createUsersFixture(page, emails, workerInfo);
    await use(usersFixture);
  },
  bookings: async ({ page }, use) => {
    const bookingsFixture = createBookingsFixture(page);
    await use(bookingsFixture);
  },
  payments: async ({ page }, use) => {
    const payemntsFixture = createPaymentsFixture(page);
    await use(payemntsFixture);
  },
  embeds: async ({ page }, use) => {
    const embedsFixture = createEmbedsFixture(page);
    await use(embedsFixture);
  },
  servers: async ({}, use) => {
    const servers = createServersFixture();
    await use(servers);
  },
  prisma: async ({}, use) => {
    await use(prisma);
  },
  routingForms: async ({}, use) => {
    await use(createRoutingFormsFixture());
  },
  emails: async ({}, use) => {
    await use(createEmailsFixture());
  },
  bookingPage: async ({ page }, use) => {
    const bookingPage = createBookingPageFixture(page);
    await use(bookingPage);
  },
  features: async ({ page }, use) => {
    const features = createFeatureFixture(page);
    await features.init();
    await use(features);
  },
  workflowPage: async ({ page }, use) => {
    const workflowPage = createWorkflowPageFixture(page);
    await use(workflowPage);
  },
  eventTypePage: async ({ page }, use) => {
    const eventTypePage = createEventTypeFixture(page);
    await use(eventTypePage);
  },
});
import { test } from "./fixtures";

export type RouteVariant = "future" | "legacy";

const routeVariants = ["future", "legacy"];

/**
 * Small wrapper around test.describe().
 * When using testbothFutureLegacyRoutes.describe() instead of test.describe(), this will run the specified
 * tests twice. One with the pages route, and one with the new app dir "future" route. It will also add the route variant
 * name to the test name for easier debugging.
 * Finally it also adds a parameter routeVariant to your testBothFutureAndLegacyRoutes.describe() callback, which
 * can be used to do any conditional rendering in the test for a specific route variant (should be as little
 * as possible).
 *
 * See apps/web/playwright/event-types.e2e.ts for an example.
 */
export const testBothFutureAndLegacyRoutes = {
  describe: (testName: string, testFn: (routeVariant: RouteVariant) => void) => {
    routeVariants.forEach((routeVariant) => {
      test.describe(`${testName} -- ${routeVariant}`, () => {
        if (routeVariant === "future") {
          test.beforeEach(({ context }) => {
            context.addCookies([
              { name: "x-calcom-future-routes-override", value: "1", url: "http://localhost:3000" },
            ]);
          });
        }
        testFn(routeVariant as RouteVariant);
      });
    });
  },
};
import detect from "detect-port";
import type { Server } from "http";
import { createServer } from "http";
import next from "next";
import { parse } from "url";

// eslint-disable-next-line @typescript-eslint/no-namespace
declare let process: {
  env: {
    E2E_DEV_SERVER: string;
    PLAYWRIGHT_TEST_BASE_URL: string;
    NEXT_PUBLIC_WEBAPP_URL: string;
    NEXT_PUBLIC_WEBSITE_URL: string;
  };
};

export const nextServer = async ({ port = 3000 } = { port: 3000 }) => {
  // eslint-disable-next-line turbo/no-undeclared-env-vars
  const dev = process.env.E2E_DEV_SERVER === "1" ? true : false;
  if (dev) {
    port = await detect(Math.round((1 + Math.random()) * 3000));
  }
  process.env.PLAYWRIGHT_TEST_BASE_URL =
    process.env.NEXT_PUBLIC_WEBAPP_URL =
    process.env.NEXT_PUBLIC_WEBSITE_URL =
      `http://localhost:${port}`;
  const app = next({
    dev: dev,
    port,
    hostname: "localhost",
  });
  console.log("Started Next Server", { dev, port });

  await app.prepare();
  const handle = app.getRequestHandler();
  // start next server on arbitrary port
  const server: Server = await new Promise((resolve) => {
    const server = createServer((req, res) => {
      if (!req.url) {
        throw new Error("URL not present");
      }
      const parsedUrl = parse(req.url, true);
      handle(req, res, parsedUrl);
    });
    server.listen({ port: port }, () => {
      resolve(server);
    });
    server.on("error", (error) => {
      if (error) throw new Error(`Could not start Next.js server - ${error.message}`);
    });
  });
  return server;
};
import type { Frame, Page } from "@playwright/test";
import { expect } from "@playwright/test";
import { createHash } from "crypto";
import EventEmitter from "events";
import type { IncomingMessage, ServerResponse } from "http";
import { createServer } from "http";
// eslint-disable-next-line no-restricted-imports
import { noop } from "lodash";
import type { Messages } from "mailhog";
import { totp } from "otplib";

import type { Prisma } from "@calcom/prisma/client";
import { BookingStatus } from "@calcom/prisma/enums";
import type { IntervalLimit } from "@calcom/types/Calendar";

import type { createEmailsFixture } from "../fixtures/emails";
import type { Fixtures } from "./fixtures";
import { test } from "./fixtures";

export function todo(title: string) {
  // eslint-disable-next-line playwright/no-skipped-test
  test.skip(title, noop);
}

type Request = IncomingMessage & { body?: unknown };
type RequestHandlerOptions = { req: Request; res: ServerResponse };
type RequestHandler = (opts: RequestHandlerOptions) => void;

export const testEmail = "test@example.com";

export const testName = "Test Testson";

export const teamEventTitle = "Team Event - 30min";

export const teamEventSlug = "team-event-30min";

export function createHttpServer(opts: { requestHandler?: RequestHandler } = {}) {
  const {
    requestHandler = ({ res }) => {
      res.writeHead(200, { "Content-Type": "application/json" });
      res.write(JSON.stringify({}));
      res.end();
    },
  } = opts;
  const eventEmitter = new EventEmitter();
  const requestList: Request[] = [];

  const waitForRequestCount = (count: number) =>
    new Promise<void>((resolve) => {
      if (requestList.length === count) {
        resolve();

        return;
      }

      const pushHandler = () => {
        if (requestList.length !== count) {
          return;
        }
        eventEmitter.off("push", pushHandler);
        resolve();
      };

      eventEmitter.on("push", pushHandler);
    });

  const server = createServer((req, res) => {
    const buffer: unknown[] = [];

    req.on("data", (data) => {
      buffer.push(data);
    });
    req.on("end", () => {
      const _req: Request = req;
      // assume all incoming request bodies are json
      const json = buffer.length ? JSON.parse(buffer.join("")) : undefined;

      _req.body = json;
      requestList.push(_req);
      eventEmitter.emit("push");
      requestHandler({ req: _req, res });
    });
  });

  // listen on random port
  server.listen(0);
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const port: number = (server.address() as any).port;
  const url = `http://localhost:${port}`;

  return {
    port,
    close: () => server.close(),
    requestList,
    url,
    waitForRequestCount,
  };
}

export async function selectFirstAvailableTimeSlotNextMonth(page: Page | Frame) {
  // Let current month dates fully render.
  await page.click('[data-testid="incrementMonth"]');

  // Waiting for full month increment
  await page.locator('[data-testid="day"][data-disabled="false"]').nth(0).click();

  await page.locator('[data-testid="time"]').nth(0).click();
}

export async function selectSecondAvailableTimeSlotNextMonth(page: Page) {
  // Let current month dates fully render.
  await page.click('[data-testid="incrementMonth"]');

  await page.locator('[data-testid="day"][data-disabled="false"]').nth(1).click();

  await page.locator('[data-testid="time"]').nth(0).click();
}

export async function bookEventOnThisPage(page: Page) {
  await selectFirstAvailableTimeSlotNextMonth(page);
  await bookTimeSlot(page);

  // Make sure we're navigated to the success page
  await page.waitForURL((url) => {
    return url.pathname.startsWith("/booking");
  });
  await expect(page.locator("[data-testid=success-page]")).toBeVisible();
}

export async function bookOptinEvent(page: Page) {
  await page.locator('[data-testid="event-type-link"]:has-text("Opt in")').click();
  await bookEventOnThisPage(page);
}

export async function bookFirstEvent(page: Page) {
  // Click first event type
  await page.click('[data-testid="event-type-link"]');
  await bookEventOnThisPage(page);
}

export const bookTimeSlot = async (page: Page, opts?: { name?: string; email?: string; title?: string }) => {
  // --- fill form
  await page.fill('[name="name"]', opts?.name ?? testName);
  await page.fill('[name="email"]', opts?.email ?? testEmail);
  if (opts?.title) {
    await page.fill('[name="title"]', opts.title);
  }
  await page.press('[name="email"]', "Enter");
};

// Provide an standalone localize utility not managed by next-i18n
export async function localize(locale: string) {
  const localeModule = `../../public/static/locales/${locale}/common.json`;
  const localeMap = await import(localeModule);
  return (message: string) => {
    if (message in localeMap) return localeMap[message];

    throw "No locale found for the given entry message";
  };
}

export const createNewEventType = async (page: Page, args: { eventTitle: string }) => {
  await page.click("[data-testid=new-event-type]");
  const eventTitle = args.eventTitle;
  await page.fill("[name=title]", eventTitle);
  await page.fill("[name=length]", "10");
  await page.click("[type=submit]");

  await page.waitForURL((url) => {
    return url.pathname !== "/event-types";
  });
};

export const createNewSeatedEventType = async (page: Page, args: { eventTitle: string }) => {
  const eventTitle = args.eventTitle;
  await createNewEventType(page, { eventTitle });
  await page.locator('[data-testid="vertical-tab-event_advanced_tab_title"]').click();
  await page.locator('[data-testid="offer-seats-toggle"]').click();
  await page.locator('[data-testid="update-eventtype"]').click();
};

export async function gotoRoutingLink({
  page,
  formId,
  queryString = "",
}: {
  page: Page;
  formId?: string;
  queryString?: string;
}) {
  let previewLink = null;
  if (!formId) {
    // Instead of clicking on the preview link, we are going to the preview link directly because the earlier opens a new tab which is a bit difficult to manage with Playwright
    const href = await page.locator('[data-testid="form-action-preview"]').getAttribute("href");

    if (!href) {
      throw new Error("Preview link not found");
    }
    previewLink = href;
  } else {
    previewLink = `/forms/${formId}`;
  }

  await page.goto(`${previewLink}${queryString ? `?${queryString}` : ""}`);

  // HACK: There seems to be some issue with the inputs to the form getting reset if we don't wait.
  await new Promise((resolve) => setTimeout(resolve, 1000));
}

export async function installAppleCalendar(page: Page) {
  await page.goto("/apps/categories/calendar");
  await page.click('[data-testid="app-store-app-card-apple-calendar"]');
  await page.waitForURL("/apps/apple-calendar");
  await page.click('[data-testid="install-app-button"]');
}

export async function getInviteLink(page: Page) {
  const response = await page.waitForResponse("**/api/trpc/teams/createInvite?batch=1");
  const json = await response.json();
  return json[0].result.data.json.inviteLink as string;
}

export async function getEmailsReceivedByUser({
  emails,
  userEmail,
}: {
  emails?: ReturnType<typeof createEmailsFixture>;
  userEmail: string;
}): Promise<Messages | null> {
  if (!emails) return null;
  const matchingEmails = await emails.search(userEmail, "to");
  if (!matchingEmails?.total) {
    console.log(`No emails received by ${userEmail}`);
  }
  return matchingEmails;
}

export async function expectEmailsToHaveSubject({
  emails,
  organizer,
  booker,
  eventTitle,
}: {
  emails?: ReturnType<typeof createEmailsFixture>;
  organizer: { name?: string | null; email: string };
  booker: { name: string; email: string };
  eventTitle: string;
}) {
  if (!emails) return null;
  const emailsOrganizerReceived = await getEmailsReceivedByUser({ emails, userEmail: organizer.email });
  const emailsBookerReceived = await getEmailsReceivedByUser({ emails, userEmail: booker.email });

  expect(emailsOrganizerReceived?.total).toBe(1);
  expect(emailsBookerReceived?.total).toBe(1);

  const [organizerFirstEmail] = (emailsOrganizerReceived as Messages).items;
  const [bookerFirstEmail] = (emailsBookerReceived as Messages).items;
  const emailSubject = `${eventTitle} between ${organizer.name ?? "Nameless"} and ${booker.name}`;

  expect(organizerFirstEmail.subject).toBe(emailSubject);
  expect(bookerFirstEmail.subject).toBe(emailSubject);
}

export const createUserWithLimits = ({
  users,
  slug,
  title,
  length,
  bookingLimits,
  durationLimits,
}: {
  users: Fixtures["users"];
  slug: string;
  title?: string;
  length?: number;
  bookingLimits?: IntervalLimit;
  durationLimits?: IntervalLimit;
}) => {
  if (!bookingLimits && !durationLimits) {
    throw new Error("Need to supply at least one of bookingLimits or durationLimits");
  }

  return users.create({
    eventTypes: [
      {
        slug,
        title: title ?? slug,
        length: length ?? 30,
        bookingLimits,
        durationLimits,
      },
    ],
  });
};

// this method is not used anywhere else
// but I'm keeping it here in case we need in the future
async function createUserWithSeatedEvent(users: Fixtures["users"]) {
  const slug = "seats";
  const user = await users.create({
    name: "Seated event user",
    eventTypes: [
      {
        title: "Seated event",
        slug,
        seatsPerTimeSlot: 10,
        requiresConfirmation: true,
        length: 30,
        disableGuests: true, // should always be true for seated events
      },
    ],
  });
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  const eventType = user.eventTypes.find((e) => e.slug === slug)!;
  return { user, eventType };
}

export async function createUserWithSeatedEventAndAttendees(
  fixtures: Pick<Fixtures, "users" | "bookings">,
  attendees: Prisma.AttendeeCreateManyBookingInput[]
) {
  const { user, eventType } = await createUserWithSeatedEvent(fixtures.users);

  const booking = await fixtures.bookings.create(user.id, user.username, eventType.id, {
    status: BookingStatus.ACCEPTED,
    // startTime with 1 day from now and endTime half hour after
    startTime: new Date(Date.now() + 24 * 60 * 60 * 1000),
    endTime: new Date(Date.now() + 24 * 60 * 60 * 1000 + 30 * 60 * 1000),
    attendees: {
      createMany: {
        data: attendees,
      },
    },
  });
  return { user, eventType, booking };
}

export function generateTotpCode(email: string) {
  const secret = createHash("md5")
    .update(email + process.env.CALENDSO_ENCRYPTION_KEY)
    .digest("hex");

  totp.options = { step: 90 };
  return totp.generate(secret);
}

export async function fillStripeTestCheckout(page: Page) {
  await page.fill("[name=cardNumber]", "4242424242424242");
  await page.fill("[name=cardExpiry]", "12/30");
  await page.fill("[name=cardCvc]", "111");
  await page.fill("[name=billingName]", "Stripe Stripeson");
  await page.click(".SubmitButton--complete-Shimmer");
}

export async function doOnOrgDomain(
  { orgSlug, page }: { orgSlug: string | null; page: Page },
  callback: ({ page }: { page: Page }) => Promise<void>
) {
  if (!orgSlug) {
    throw new Error("orgSlug is not available");
  }
  page.setExtraHTTPHeaders({
    "x-cal-force-slug": orgSlug,
  });
  await callback({ page });
}

// When App directory is there, this is the 404 page text. We should work on fixing the 404 page as it changed due to app directory.
export const NotFoundPageTextAppDir = "This page does not exist.";
// export const NotFoundPageText = "ERROR 404";
import type { Prisma } from "@prisma/client";

import prisma from "@calcom/prisma";

/**
 * @deprecated
 * DO NOT USE, since test run in parallel this will cause flaky tests. The reason
 * being that a set of test may end earlier than other trigger a delete of all bookings
 * than other tests may depend on them. The proper ettiquete should be that EACH test
 * should cleanup ONLY the booking that we're created in that specific test to se DB
 * remains "pristine" after each test
 */
export const deleteAllBookingsByEmail = async (
  email: string,
  whereConditional: Prisma.BookingWhereInput = {}
) =>
  prisma.booking.deleteMany({
    where: {
      user: {
        email,
      },
      ...whereConditional,
    },
  });

export const deleteEventTypeByTitle = async (title: string) => {
  const event = await prisma.eventType.findFirst({
    select: { id: true },
    where: { title: title },
  });
  await prisma.eventType.delete({ where: { id: event?.id } });
};

export const deleteAllWebhooksByEmail = async (email: string) => {
  await prisma.webhook.deleteMany({
    where: {
      user: {
        email,
      },
    },
  });
};

export const deleteAllPaymentsByEmail = async (email: string) => {
  await prisma.payment.deleteMany({
    where: {
      booking: {
        user: {
          email,
        },
      },
    },
  });
};

export const deleteAllPaymentCredentialsByEmail = async (email: string) => {
  await prisma.user.update({
    where: {
      email,
    },
    data: {
      credentials: {
        deleteMany: {
          type: {
            endsWith: "_payment",
          },
        },
      },
    },
  });
};
import { expect, type Page } from "@playwright/test";

import dayjs from "@calcom/dayjs";
import { WEBAPP_URL } from "@calcom/lib/constants";
import type { MembershipRole } from "@calcom/prisma/enums";

import { localize } from "../lib/testUtils";
import type { createUsersFixture } from "./users";

const reschedulePlaceholderText = "Let others know why you need to reschedule";

export const scheduleSuccessfullyText = "This meeting is scheduled";

const EMAIL = "test@test.com";

const EMAIL2 = "test2@test.com";

const PHONE = "+55 (32) 983289947";

type BookingOptions = {
  hasPlaceholder?: boolean;
  isReschedule?: boolean;
  isRequired?: boolean;
  isAllRequired?: boolean;
  isMultiSelect?: boolean;
};

interface QuestionActions {
  [key: string]: () => Promise<void>;
}

type teamBookingtypes = { isManagedType?: boolean; isRoundRobinType?: boolean; isCollectiveType?: boolean };

type customLocators = {
  shouldChangeSelectLocator: boolean;
  shouldUseLastRadioGroupLocator: boolean;
  shouldUseFirstRadioGroupLocator: boolean;
  shouldChangeMultiSelectLocator: boolean;
};

type fillAndConfirmBookingParams = {
  eventTypePage: Page;
  placeholderText: string;
  question: string;
  fillText: string;
  secondQuestion: string;
  options: BookingOptions;
};

type UserFixture = ReturnType<typeof createUsersFixture>;

function isLastDayOfMonth(): boolean {
  const today = dayjs();
  const endOfMonth = today.endOf("month");
  return today.isSame(endOfMonth, "day");
}

const fillQuestion = async (eventTypePage: Page, questionType: string, customLocators: customLocators) => {
  const questionActions: QuestionActions = {
    phone: async () => {
      await eventTypePage.locator('input[name="phone-test"]').clear();
      await eventTypePage.locator('input[name="phone-test"]').fill(PHONE);
    },
    multiemail: async () => {
      await eventTypePage.getByRole("button", { name: `${questionType} test` }).click();
      await eventTypePage.getByPlaceholder(`${questionType} test`).fill(EMAIL);
      await eventTypePage.getByTestId("add-another-guest").last().click();
      await eventTypePage.getByPlaceholder(`${questionType} test`).last().fill(EMAIL2);
    },
    checkbox: async () => {
      if (customLocators.shouldUseLastRadioGroupLocator || customLocators.shouldChangeMultiSelectLocator) {
        await eventTypePage.getByLabel("Option 1").last().click();
        await eventTypePage.getByLabel("Option 2").last().click();
      } else if (customLocators.shouldUseFirstRadioGroupLocator) {
        await eventTypePage.getByLabel("Option 1").first().click();
        await eventTypePage.getByLabel("Option 2").first().click();
      } else {
        await eventTypePage.getByLabel("Option 1").click();
        await eventTypePage.getByLabel("Option 2").click();
      }
    },
    multiselect: async () => {
      if (customLocators.shouldChangeMultiSelectLocator) {
        await eventTypePage.getByLabel("multi-select-dropdown").click();
        await eventTypePage.getByTestId("select-option-Option 1").click();
      } else {
        await eventTypePage.getByLabel("multi-select-dropdown").last().click();
        await eventTypePage.getByTestId("select-option-Option 1").click();
      }
    },
    boolean: async () => {
      await eventTypePage.getByLabel(`${questionType} test`).check();
    },
    radio: async () => {
      await eventTypePage.locator('[id="radio-test\\.option\\.0\\.radio"]').click();
    },
    select: async () => {
      if (customLocators.shouldChangeSelectLocator) {
        await eventTypePage.getByLabel("select-dropdown").first().click();
        await eventTypePage.getByTestId("select-option-Option 1").click();
      } else {
        await eventTypePage.getByLabel("select-dropdown").last().click();
        await eventTypePage.getByTestId("select-option-Option 1").click();
      }
    },
    number: async () => {
      await eventTypePage.getByPlaceholder(`${questionType} test`).click();
      await eventTypePage.getByPlaceholder(`${questionType} test`).fill("123");
    },
    address: async () => {
      await eventTypePage.getByPlaceholder(`${questionType} test`).click();
      await eventTypePage.getByPlaceholder(`${questionType} test`).fill("address test");
    },
    textarea: async () => {
      await eventTypePage.getByPlaceholder(`${questionType} test`).click();
      await eventTypePage.getByPlaceholder(`${questionType} test`).fill("textarea test");
    },
    text: async () => {
      await eventTypePage.getByPlaceholder(`${questionType} test`).click();
      await eventTypePage.getByPlaceholder(`${questionType} test`).fill("text test");
    },
  };
  if (questionActions[questionType]) {
    await questionActions[questionType]();
  }
};

const fillAllQuestions = async (eventTypePage: Page, questions: string[], options: BookingOptions) => {
  if (options.isAllRequired) {
    for (const question of questions) {
      switch (question) {
        case "email":
          await eventTypePage.getByPlaceholder("Email").click();
          await eventTypePage.getByPlaceholder("Email").fill(EMAIL);
          break;

        case "phone":
          await eventTypePage.getByPlaceholder("Phone test").click();
          await eventTypePage.getByPlaceholder("Phone test").fill(PHONE);
          break;

        case "address":
          await eventTypePage.getByPlaceholder("Address test").click();
          await eventTypePage.getByPlaceholder("Address test").fill("123 Main St, City, Country");
          break;

        case "textarea":
          await eventTypePage.getByPlaceholder("Textarea test").click();
          await eventTypePage.getByPlaceholder("Textarea test").fill("This is a sample text for textarea.");
          break;

        case "select":
          await eventTypePage.getByLabel("select-dropdown").last().click();
          await eventTypePage.getByTestId("select-option-Option 1").click();
          break;

        case "multiselect":
          // select-dropdown
          await eventTypePage.getByLabel("multi-select-dropdown").click();
          await eventTypePage.getByTestId("select-option-Option 1").click();
          break;

        case "number":
          await eventTypePage.getByLabel("number test").click();
          await eventTypePage.getByLabel("number test").fill("123");
          break;

        case "radio":
          await eventTypePage.getByRole("radiogroup").getByText("Option 1").check();
          break;

        case "text":
          await eventTypePage.getByPlaceholder("Text test").click();
          await eventTypePage.getByPlaceholder("Text test").fill("Sample text");
          break;

        case "checkbox":
          await eventTypePage.getByLabel("Option 1").first().check();
          await eventTypePage.getByLabel("Option 2").first().check();
          break;

        case "boolean":
          await eventTypePage.getByLabel(`${question} test`).check();
          break;

        case "multiemail":
          await eventTypePage.getByRole("button", { name: "multiemail test" }).click();
          await eventTypePage.getByPlaceholder("multiemail test").fill(EMAIL);
          break;
      }
    }
  }
};

export async function loginUser(users: UserFixture) {
  const pro = await users.create({ name: "testuser" });
  await pro.apiLogin();
}

export async function loginUserWithTeam(users: UserFixture, role: MembershipRole) {
  const pro = await users.create(
    { name: "testuser" },
    { hasTeam: true, teamRole: role, isOrg: true, hasSubteam: true }
  );
  await pro.apiLogin();
}

const goToNextMonthIfNoAvailabilities = async (eventTypePage: Page) => {
  try {
    if (isLastDayOfMonth()) {
      await eventTypePage.getByTestId("view_next_month").waitFor({ timeout: 6000 });
      await eventTypePage.getByTestId("view_next_month").click();
    }
  } catch (err) {
    console.info("No need to click on view next month button");
  }
};

export function createBookingPageFixture(page: Page) {
  return {
    goToEventType: async (eventType: string) => {
      await page.getByRole("link", { name: eventType }).click();
    },
    goToPage: async (pageName: string, page: Page) => {
      await page.getByRole("link", { name: pageName }).click();
    },
    backToBookings: async (page: Page) => {
      await page.getByTestId("back-to-bookings").click();
    },
    goToTab: async (tabName: string) => {
      await page.getByTestId(`vertical-tab-${tabName}`).click();
    },

    goToEventTypesPage: async () => {
      await page.goto("/event-types");
    },

    setResolution: async (width: number, height: number) => {
      await page.setViewportSize({ width: width, height: height });
    },
    addQuestion: async (
      questionType: string,
      identifier: string,
      label: string,
      isRequired: boolean,
      placeholder?: string
    ) => {
      await page.getByTestId("add-field").click();
      await page.getByTestId("test-field-type").click();
      await page.getByTestId(`select-option-${questionType}`).click();
      await page.getByLabel("Identifier").dblclick();
      await page.getByLabel("Identifier").fill(identifier);
      await page.getByLabel("Label").click();
      await page.getByLabel("Label").fill(label);
      if (placeholder) {
        await page.getByLabel("Placeholder").click();
        await page.getByLabel("Placeholder").fill(placeholder);
      }
      if (!isRequired) {
        await page.getByRole("radio", { name: "No" }).click();
      }
      await page.getByTestId("field-add-save").click();
    },
    updateRecurringTab: async (repeatWeek: string, maxEvents: string) => {
      const repeatText = (await localize("en"))("repeats_every");
      const maximumOf = (await localize("en"))("for_a_maximum_of");
      await page.getByTestId("recurring-event-check").click();
      await page
        .getByTestId("recurring-event-collapsible")
        .locator("div")
        .filter({ hasText: repeatText })
        .getByRole("spinbutton")
        .fill(repeatWeek);
      await page
        .getByTestId("recurring-event-collapsible")
        .locator("div")
        .filter({ hasText: maximumOf })
        .getByRole("spinbutton")
        .fill(maxEvents);
    },
    updateEventType: async () => {
      await page.getByTestId("update-eventtype").click();
      const toast = await page.waitForSelector('[data-testid="toast-success"]');
      expect(toast).toBeTruthy();
    },

    previewEventType: async () => {
      const eventtypePromise = page.waitForEvent("popup");
      await page.getByTestId("preview-button").click();
      return eventtypePromise;
    },

    selectTimeSlot: async (eventTypePage: Page) => {
      await goToNextMonthIfNoAvailabilities(eventTypePage);
      await eventTypePage.getByTestId("time").first().click();
    },

    clickReschedule: async () => {
      await page.getByText("Reschedule").click();
    },

    selectFirstAvailableTime: async () => {
      await page.getByTestId("time").first().click();
    },

    fillRescheduleReasonAndConfirm: async () => {
      await page.getByPlaceholder(reschedulePlaceholderText).click();
      await page.getByPlaceholder(reschedulePlaceholderText).fill("Test reschedule");
      await page.getByTestId("confirm-reschedule-button").click();
    },

    fillRecurringFieldAndConfirm: async (eventTypePage: Page) => {
      await eventTypePage.getByTestId("occurrence-input").click();
      await eventTypePage.getByTestId("occurrence-input").fill("2");
      await goToNextMonthIfNoAvailabilities(eventTypePage);
      await eventTypePage.getByTestId("time").first().click();
      await expect(eventTypePage.getByTestId("recurring-dates")).toBeVisible();
    },

    cancelBookingWithReason: async (page: Page) => {
      await page.getByTestId("cancel").click();
      await page.getByTestId("cancel_reason").fill("Test cancel");
      await page.getByTestId("confirm_cancel").click();
    },

    assertBookingCanceled: async (page: Page) => {
      await expect(page.getByTestId("cancelled-headline")).toBeVisible();
    },

    rescheduleBooking: async (eventTypePage: Page) => {
      await goToNextMonthIfNoAvailabilities(eventTypePage);
      await eventTypePage.getByText("Reschedule").click();
      while (await eventTypePage.getByRole("button", { name: "View next" }).isVisible()) {
        await eventTypePage.getByRole("button", { name: "View next" }).click();
      }
      await eventTypePage.getByTestId("time").first().click();
      await eventTypePage.getByPlaceholder(reschedulePlaceholderText).click();
      await eventTypePage.getByPlaceholder(reschedulePlaceholderText).fill("Test reschedule");
      await eventTypePage.getByTestId("confirm-reschedule-button").click();
      await eventTypePage.waitForTimeout(400);
      if (
        await eventTypePage.getByRole("heading", { name: "Could not reschedule the meeting." }).isVisible()
      ) {
        await eventTypePage.getByTestId("back").click();
        await eventTypePage.getByTestId("time").last().click();
        await eventTypePage.getByTestId("confirm-reschedule-button").click();
      }
    },

    assertBookingRescheduled: async (page: Page) => {
      await expect(page.getByText(scheduleSuccessfullyText)).toBeVisible();
    },

    assertRepeatEventType: async () => {
      await expect(page.getByTestId("repeat-eventtype")).toBeVisible();
    },

    cancelBooking: async (eventTypePage: Page) => {
      await eventTypePage.getByTestId("cancel").click();
      await eventTypePage.getByTestId("cancel_reason").fill("Test cancel");
      await eventTypePage.getByTestId("confirm_cancel").click();
      await expect(eventTypePage.getByTestId("cancelled-headline")).toBeVisible();
    },

    confirmBooking: async (eventTypePage: Page) => {
      await eventTypePage.getByTestId("confirm-book-button").click();
      await eventTypePage.waitForURL("booking/**");
      await expect(eventTypePage.getByText(scheduleSuccessfullyText)).toBeVisible();
    },

    fillAndConfirmBooking: async ({
      eventTypePage,
      placeholderText,
      question,
      fillText,
      secondQuestion,
      options,
    }: fillAndConfirmBookingParams) => {
      const confirmButton = options.isReschedule ? "confirm-reschedule-button" : "confirm-book-button";

      await expect(eventTypePage.getByText(`${secondQuestion} test`).first()).toBeVisible();
      await eventTypePage.getByPlaceholder(placeholderText).fill(fillText);

      // Change the selector for specifics cases related to select question
      const shouldChangeSelectLocator = (question: string, secondQuestion: string): boolean =>
        question === "select" && ["multiemail", "multiselect", "address"].includes(secondQuestion);

      const shouldUseLastRadioGroupLocator = (question: string, secondQuestion: string): boolean =>
        question === "radio" && secondQuestion === "checkbox";

      const shouldUseFirstRadioGroupLocator = (question: string, secondQuestion: string): boolean =>
        question === "checkbox" && secondQuestion === "radio";

      const shouldChangeMultiSelectLocator = (question: string, secondQuestion: string): boolean =>
        question === "multiselect" &&
        ["address", "checkbox", "multiemail", "select"].includes(secondQuestion);

      const customLocators = {
        shouldChangeSelectLocator: shouldChangeSelectLocator(question, secondQuestion),
        shouldUseLastRadioGroupLocator: shouldUseLastRadioGroupLocator(question, secondQuestion),
        shouldUseFirstRadioGroupLocator: shouldUseFirstRadioGroupLocator(question, secondQuestion),
        shouldChangeMultiSelectLocator: shouldChangeMultiSelectLocator(question, secondQuestion),
      };

      // Fill the first question
      await fillQuestion(eventTypePage, question, customLocators);

      // Fill the second question if is required
      options.isRequired && (await fillQuestion(eventTypePage, secondQuestion, customLocators));

      await eventTypePage.getByTestId(confirmButton).click();
      await eventTypePage.waitForTimeout(400);
      if (await eventTypePage.getByRole("heading", { name: "Could not book the meeting." }).isVisible()) {
        await eventTypePage.getByTestId("back").click();
        await eventTypePage.getByTestId("time").last().click();
        await fillQuestion(eventTypePage, question, customLocators);
        options.isRequired && (await fillQuestion(eventTypePage, secondQuestion, customLocators));
        await eventTypePage.getByTestId(confirmButton).click();
      }
      const scheduleSuccessfullyPage = eventTypePage.getByText(scheduleSuccessfullyText);
      await scheduleSuccessfullyPage.waitFor({ state: "visible" });
      await expect(scheduleSuccessfullyPage).toBeVisible();
    },

    fillAllQuestions: async (eventTypePage: Page, questions: string[], options: BookingOptions) => {
      const confirmButton = options.isReschedule ? "confirm-reschedule-button" : "confirm-book-button";
      await fillAllQuestions(eventTypePage, questions, options);
      await eventTypePage.getByTestId(confirmButton).click();
      const scheduleSuccessfullyPage = eventTypePage.getByText(scheduleSuccessfullyText);
      await scheduleSuccessfullyPage.waitFor({ state: "visible" });
      await expect(scheduleSuccessfullyPage).toBeVisible();
    },
    addGuests: async (eventTypePage: Page, options: { guests: string[] }) => {
      await eventTypePage.getByTestId("add-guests").click();
      for (const guest of options.guests) {
        await eventTypePage.getByPlaceholder("Email").fill(guest);
      }
    },
    createTeam: async (name: string) => {
      await page.getByTestId("teams-test").click();
      await page.getByTestId("new-team-btn").click();
      await page.getByPlaceholder("Acme Inc.").click();
      await page.getByPlaceholder("Acme Inc.").fill(name);
      await page.getByTestId("continue-button").click();
      await page.getByTestId("publish-button").click();

      await page.getByTestId("vertical-tab-Back").click();
    },

    createTeamEventType: async (name: string, options: teamBookingtypes) => {
      await page.getByTestId("new-event-type").click();
      await page.getByTestId("option-0").click();

      // We first simulate to create a default event type to check if managed option is not available

      const managedEventDescription = (await localize("en"))("managed_event_description");
      const roundRobinEventDescription = (await localize("en"))("round_robin_description");
      const collectiveEventDescription = (await localize("en"))("collective_description");
      const quickChatText = (await localize("en"))("quick_chat");
      await expect(page.locator("div").filter({ hasText: managedEventDescription })).toBeHidden();
      await page.getByTestId("dialog-rejection").click();

      await page.getByTestId("new-event-type").click();
      await page.getByTestId("option-team-1").click();
      await page.getByPlaceholder(quickChatText).fill(name);
      if (options.isCollectiveType) {
        await page
          .locator("div")
          .filter({ hasText: `Collective${collectiveEventDescription}` })
          .getByRole("radio")
          .first()
          .click();
      }

      if (options.isRoundRobinType) {
        await page
          .locator("div")
          .filter({ hasText: `Round Robin${roundRobinEventDescription}` })
          .getByRole("radio")
          .nth(1)
          .click();
      }

      if (options.isManagedType) {
        await page
          .locator("div")
          .filter({ hasText: `Managed Event${managedEventDescription}` })
          .getByRole("radio")
          .last()
          .click();

        const managedEventClarification = (await localize("en"))("managed_event_url_clarification");
        await expect(page.getByText(managedEventClarification)).toBeVisible();
      }

      const continueText = (await localize("en"))("continue");
      const toast = page.getByTestId("toast-success");

      await page.getByRole("button", { name: continueText }).click();
      expect(toast).toBeTruthy();
      await page.getByTestId("update-eventtype").click();
    },
    assertLabelWithCorrectTeamName: async (page: Page, teamName: string) => {
      await expect(page.getByRole("link", { name: teamName }).first()).toBeVisible();
    },
    assertBookingWithCorrectTitleAndDescription: async (
      page: Page,
      options: { profileName: string; bookingName: string; teamName: string; aditionalGuestEmail?: string }
    ) => {
      options.aditionalGuestEmail
        ? await expect(
            page.getByRole("link", {
              name: `${options.bookingName} between ${options.teamName} and ${options.profileName} You , ${options.profileName} and ${options.aditionalGuestEmail}`,
            })
          ).toBeVisible()
        : await expect(
            page.getByRole("link", {
              name: `${options.bookingName} between ${options.teamName} and ${options.profileName} You and ${options.profileName}`,
            })
          ).toBeVisible();
    },
    clickOnBooking: async (page: Page, teamName: string) => {
      await page.getByRole("link", { name: teamName }).first().click();
    },

    checkField: async (question: string, options?: { isOptional: boolean }) => {
      if (options?.isOptional) {
        await expect(page.getByTestId(`field-${question}-test`).getByTestId("optional")).toBeVisible();
      } else {
        await expect(page.getByTestId(`field-${question}-test`).getByTestId("required")).toBeVisible();
      }
      await expect(page.getByTestId(`field-${question}-test`)).toBeVisible();
    },

    checkRequiresConfirmation: async () => {
      // Check existence of the icon
      await expect(page.getByTestId("requires-confirmation-title").locator("svg")).toBeVisible();

      const confirmationSwitch = page.getByTestId("requires-confirmation");
      await expect(confirmationSwitch).toBeVisible();
      await confirmationSwitch.click();
    },

    checkRequiresBookerEmailVerification: async () => {
      await expect(page.getByTestId("requires-booker-email-verification-title").locator("svg")).toBeVisible();

      const emailSwitch = page.getByTestId("requires-booker-email-verification");

      await expect(emailSwitch).toBeVisible();
      await emailSwitch.click();
    },

    checkHideNotes: async () => {
      await expect(page.getByTestId("disable-notes-title").locator("svg")).toBeVisible();

      const hideNotesSwitch = page.getByTestId("disable-notes");

      await expect(hideNotesSwitch).toBeVisible();
      await hideNotesSwitch.click();
    },

    checkRedirectOnBooking: async () => {
      await expect(page.getByTestId("redirect-success-booking-title").locator("svg")).toBeVisible();

      const redirectSwitch = page.getByTestId("redirect-success-booking");
      await expect(redirectSwitch).toBeVisible();
      await redirectSwitch.click();
      await expect(page.getByTestId("external-redirect-url")).toBeVisible();
      await page.getByTestId("external-redirect-url").fill("https://cal.com");
      await expect(page.getByTestId("redirect-url-warning")).toBeVisible();
    },

    checkEnablePrivateUrl: async () => {
      await expect(page.getByTestId("hashedLinkCheck-title").locator("label div")).toBeVisible();

      await expect(page.getByTestId("hashedLinkCheck-info")).toBeVisible();
      await expect(page.getByTestId("hashedLinkCheck")).toBeVisible();
      await page.getByTestId("hashedLinkCheck").click();
      await expect(page.getByTestId("generated-hash-url")).toBeVisible();
    },

    toggleOfferSeats: async () => {
      await expect(page.getByTestId("offer-seats-toggle-title").locator("svg")).toBeVisible();

      await page.getByTestId("offer-seats-toggle").click();

      const seatSwitchField = page.getByTestId("seats-per-time-slot");
      await seatSwitchField.fill("3");
      await expect(seatSwitchField).toHaveValue("3");
      await expect(page.getByTestId("show-attendees")).toBeVisible();
    },

    checkLockTimezone: async () => {
      await expect(page.getByTestId("lock-timezone-toggle-title").locator("svg")).toBeVisible();

      const lockSwitch = page.getByTestId("lock-timezone-toggle");

      await expect(lockSwitch).toBeVisible();
      await lockSwitch.click();
    },

    checkEventType: async () => {
      await expect(page.getByTestId("requires-confirmation-badge").last()).toBeVisible();
    },

    assertBookingIsVisible: async (name: string) => {
      await expect(
        page.getByRole("link", {
          name,
        })
      ).toBeVisible();
    },
    checkBufferTime: async () => {
      const minutes = (await localize("en"))("minutes");
      const fieldPlaceholder = page.getByPlaceholder("0");

      await page
        .locator("div")
        .filter({ hasText: /^No buffer time$/ })
        .nth(1)
        .click();
      await page.getByTestId("select-option-15").click();
      await expect(page.getByText(`15 ${minutes}`, { exact: true })).toBeVisible();

      await page
        .locator("div")
        .filter({ hasText: /^No buffer time$/ })
        .nth(2)
        .click();
      await page.getByTestId("select-option-10").click();
      await expect(page.getByText(`10 ${minutes}`, { exact: true })).toBeVisible();

      await fieldPlaceholder.fill("10");
      await expect(fieldPlaceholder).toHaveValue("10");

      await page
        .locator("div")
        .filter({ hasText: /^Use event length \(default\)$/ })
        .first()
        .click();

      // select a large interval to check if the time slots for a day reduce on the preview page
      await page.getByTestId("select-option-60").click();
      await expect(page.getByText(`60 ${minutes}`, { exact: true })).toBeVisible();
    },

    checkLimitBookingFrequency: async () => {
      const fieldPlaceholder = page.getByPlaceholder("1").nth(1);
      const limitFrequency = (await localize("en"))("limit_booking_frequency");
      const addlimit = (await localize("en"))("add_limit");
      const limitFrequencySwitch = page
        .locator("fieldset")
        .filter({ hasText: limitFrequency })
        .getByRole("switch");

      await limitFrequencySwitch.click();
      await page.getByRole("button", { name: addlimit }).click();
      await fieldPlaceholder.fill("12");
      await expect(fieldPlaceholder).toHaveValue("12");
      await limitFrequencySwitch.click();
    },

    checkLimitBookingDuration: async () => {
      const limitDuration = (await localize("en"))("limit_total_booking_duration");
      const addlimit = (await localize("en"))("add_limit");
      const limitDurationSwitch = page
        .locator("fieldset")
        .filter({ hasText: limitDuration })
        .getByRole("switch");

      await limitDurationSwitch.click();
      await page.getByRole("button", { name: addlimit }).click();
      await expect(page.getByTestId("add-limit")).toHaveCount(2);
      await limitDurationSwitch.click();
    },

    checkLimitFutureBookings: async () => {
      const limitFutureBookings = (await localize("en"))("limit_future_bookings");
      const limitBookingsSwitch = page
        .locator("fieldset")
        .filter({ hasText: limitFutureBookings })
        .getByRole("switch");

      await limitBookingsSwitch.click();
      await page.locator("#RANGE").click();
      await expect(page.locator("#RANGE")).toBeChecked();
      await limitBookingsSwitch.click();
    },

    checkOffsetTimes: async () => {
      const offsetStart = (await localize("en"))("offset_start");
      const offsetStartTimes = (await localize("en"))("offset_toggle");
      const offsetLabel = page.getByLabel(offsetStart);

      await page.locator("fieldset").filter({ hasText: offsetStartTimes }).getByRole("switch").click();
      await offsetLabel.fill("10");
      await expect(offsetLabel).toHaveValue("10");
      await expect(
        page.getByText("e.g. this will show time slots to your bookers at 9:10 AM instead of 9:00 AM")
      ).toBeVisible();
    },

    checkTimeSlotsCount: async (eventTypePage: Page, count: number) => {
      await expect(eventTypePage.getByTestId("time")).toHaveCount(count);
    },
    createBookingWebhook: async (webhookReceiver: { url: string }, eventTitle: string) => {
      const events = [
        "Booking Canceled",
        "Booking Created",
        "Booking Rejected",
        "Booking Requested",
        "Booking Payment Initiated",
        "Booking Rescheduled",
        "Meeting Ended",
        "Booking Paid",
        "Recording Download Link Ready",
      ];
      await page.goto(`${WEBAPP_URL}/event-types`);
      await page.getByText(eventTitle).click();

      await page.getByTestId("vertical-tab-webhooks").click();

      await page.getByTestId("new_webhook").click();
      await page.getByLabel("Subscriber URL").fill(webhookReceiver.url);
      await page.getByRole("button", { name: "Ping test" }).click();
      page
        .getByTestId("dialog-creation")
        .locator("div")
        .filter({ hasText: '{ "ok": true, "status": 200, "message": "{}" }' })
        .nth(2);
      await page.getByRole("button", { name: "Create Webhook" }).click();

      page.getByText(webhookReceiver.url);
      events.forEach((event) => {
        page.getByText(event);
      });
    },
    rejectFirstBooking: async () => {
      await page.goto("/bookings/unconfirmed");
      await page.getByTestId("horizontal-tab-unconfirmed").click();
      await page.getByTestId("booking-item").first().getByText("Reject").click();
      await page.getByTestId("rejection-confirm").click();
    },
    fillEmailAndName: async (eventTypePage: Page) => {
      const emailLabel = (await localize("en"))("email_address");
      const nameLabel = (await localize("en"))("your_name");

      await eventTypePage.getByLabel(emailLabel).fill(EMAIL);
      await eventTypePage.getByLabel(nameLabel).fill("testuser");
    },
  };
}
import type { Page } from "@playwright/test";

export const createEmbedsFixture = (page: Page) => {
  return {
    /**
     * @deprecated Use gotoPlayground instead
     */
    async addEmbedListeners(calNamespace: string) {
      await page.addInitScript(
        ({ calNamespace }: { calNamespace: string }) => {
          console.log("PlaywrightTest:", "Adding listener for __iframeReady on namespace:", calNamespace);
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          //@ts-ignore
          window.eventsFiredStoreForPlaywright = window.eventsFiredStoreForPlaywright || {};
          document.addEventListener("DOMContentLoaded", function tryAddingListener() {
            if (parent !== window) {
              // Firefox seems to execute this snippet for iframe as well. Avoid that. It must be executed only for parent frame.

              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              //@ts-ignore
              window.initialBodyVisibility = document.body.style.visibility;

              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              //@ts-ignore
              window.initialBodyBackground = document.body.style.background;

              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              //@ts-ignore
              window.initialValuesSet = true;
              return;
            }

            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore
            let api = window.Cal;

            if (!api) {
              console.log("PlaywrightTest:", "window.Cal not available yet, trying again");
              setTimeout(tryAddingListener, 500);
              return;
            }
            if (calNamespace) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              //@ts-ignore
              api = window.Cal.ns[calNamespace];
            }
            console.log("PlaywrightTest:", `Adding listener for __iframeReady on namespace:${calNamespace}`);

            if (!api) {
              throw new Error(`namespace "${calNamespace}" not found`);
            }
            api("on", {
              action: "*",
              callback: (e) => {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                window.iframeReady = true; // Technically if there are multiple cal embeds, it can be set due to some other iframe. But it works for now. Improve it when it doesn't work

                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-ignore
                const store = window.eventsFiredStoreForPlaywright;

                const eventStore = (store[`${e.detail.type}-${e.detail.namespace}`] =
                  store[`${e.detail.type}-${e.detail.namespace}`] || []);
                eventStore.push(e.detail);
              },
            });
          });
        },
        { calNamespace }
      );
    },

    async getActionFiredDetails({ calNamespace, actionType }: { calNamespace: string; actionType: string }) {
      if (!page.isClosed()) {
        return await page.evaluate(
          ({ actionType, calNamespace }) => {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore
            return window.eventsFiredStoreForPlaywright[`${actionType}-${calNamespace}`];
          },
          { actionType, calNamespace }
        );
      }
    },

    async gotoPlayground({ calNamespace, url }: { calNamespace: string; url: string }) {
      await this.addEmbedListeners(calNamespace);
      await page.goto(url);
    },
  };
};
import type { Locator } from "@playwright/test";
import { expect, type Page } from "@playwright/test";

import prisma from "@calcom/prisma";
import { WorkflowTriggerEvents } from "@calcom/prisma/enums";

import { localize } from "../lib/testUtils";

type CreateWorkflowProps = {
  name?: string;
  isTeam?: true;
  trigger?: WorkflowTriggerEvents;
};

export function createWorkflowPageFixture(page: Page) {
  const createWorkflow = async (props: CreateWorkflowProps) => {
    const { name, isTeam, trigger } = props;

    if (isTeam) {
      await page.getByTestId("create-button-dropdown").click();
      await page.getByTestId("option-team-1").click();
    } else {
      await page.getByTestId("create-button").click();
    }
    if (name) {
      await fillNameInput(name);
    }
    if (trigger) {
      page.locator("div").filter({ hasText: WorkflowTriggerEvents.BEFORE_EVENT }).nth(1);
      page.getByText(trigger);
      await selectEventType("30 min");
    }
    await saveWorkflow();
  };

  const saveWorkflow = async () => {
    await page.getByTestId("save-workflow").click();
  };

  const assertListCount = async (count: number) => {
    const workflowListCount = await page.locator('[data-testid="workflow-list"] > li');
    await expect(workflowListCount).toHaveCount(count);
  };

  const fillNameInput = async (name: string) => {
    await page.getByTestId("workflow-name").fill(name);
  };

  const editSelectedWorkflow = async (name: string) => {
    const selectedWorkflow = page.getByTestId("workflow-list").getByTestId(nameToTestId(name));

    const editButton = selectedWorkflow.getByRole("button").nth(0);

    await editButton.click();
  };

  const hasWorkflowInList = async (name: string, negate?: true) => {
    const selectedWorkflow = page.getByTestId("workflow-list").getByTestId(nameToTestId(name));

    if (negate) {
      await expect(selectedWorkflow).toBeHidden();
    } else {
      await expect(selectedWorkflow).toBeVisible();
    }
  };

  const deleteAndConfirm = async (workflow: Locator) => {
    const deleteButton = workflow.getByTestId("delete-button");

    const confirmDeleteText = (await localize("en"))("confirm_delete_workflow");

    await deleteButton.click();
    await page.getByRole("button", { name: confirmDeleteText }).click();
  };

  const selectEventType = async (name: string) => {
    await page.getByText("Select...").click();
    await page.getByText(name, { exact: true }).click();
  };

  const hasReadonlyBadge = async () => {
    const readOnlyBadge = page.getByText((await localize("en"))("readonly"));
    await expect(readOnlyBadge).toBeVisible();
  };

  const selectedWorkflowPage = async (name: string) => {
    await page.getByTestId("workflow-list").getByTestId(nameToTestId(name)).click();
  };

  const workflowOptionsAreDisabled = async (workflow: string, negate?: boolean) => {
    const getWorkflowButton = async (buttonTestId: string) =>
      page.getByTestId(nameToTestId(workflow)).getByTestId(buttonTestId);

    const [editButton, deleteButton] = await Promise.all([
      getWorkflowButton("edit-button"),
      getWorkflowButton("delete-button"),
    ]);

    expect(editButton.isDisabled()).toBeTruthy();
    expect(deleteButton.isDisabled()).toBeTruthy();
  };

  const assertWorkflowReminders = async (eventTypeId: number, count: number) => {
    const booking = await prisma.booking.findFirst({
      where: {
        eventTypeId,
      },
    });

    const workflowReminders = await prisma.workflowReminder.findMany({
      where: {
        bookingUid: booking?.uid ?? "",
      },
    });
    expect(workflowReminders).toHaveLength(count);
  };

  function nameToTestId(name: string) {
    return `workflow-${name.split(" ").join("-").toLowerCase()}`;
  }

  return {
    createWorkflow,
    saveWorkflow,
    assertListCount,
    fillNameInput,
    editSelectedWorkflow,
    hasWorkflowInList,
    deleteAndConfirm,
    selectEventType,
    hasReadonlyBadge,
    selectedWorkflowPage,
    workflowOptionsAreDisabled,
    assertWorkflowReminders,
  };
}
import { expect, type Page } from "@playwright/test";

import { localize } from "../lib/testUtils";

export function createEventTypeFixture(page: Page) {
  return {
    goToEventType: async (eventType: string) => {
      await page.getByRole("link", { name: eventType }).click();
    },
    goToTab: async (tabName: string) => {
      await page.getByTestId(`vertical-tab-${tabName}`).click();
    },
    goToEventTypesPage: async () => {
      await page.goto("/event-types");
    },
    checkAvailabilityTab: async () => {
      const editAvailability = (await localize("en"))("edit_availability");

      // Verify if the icon is rendered
      await expect(page.locator("span").filter({ hasText: "Europe/London" }).locator("svg")).toBeVisible();
      await expect(page.getByText("Europe/London")).toBeVisible();
      await page.getByRole("link", { name: editAvailability }).click();
    },
    goToAvailabilityPage: async () => {
      const workingHours = (await localize("en"))("default_schedule_name");

      await page.goto("/availability");
      await page
        .getByTestId("schedules")
        .locator("div")
        .filter({
          hasText: workingHours,
        })
        .first()
        .click();
    },
    checkAvailabilityPage: async () => {
      const sunday = (await localize("en"))("sunday");
      const monday = (await localize("en"))("monday");
      const wednesday = (await localize("en"))("wednesday");
      const saturday = (await localize("en"))("saturday");
      const save = (await localize("en"))("save");
      const copyTimesTo = (await localize("en"))("copy_times_to");

      await page.getByTestId("availablity-title").click();
      // change availability name
      await page.getByTestId("availablity-title").fill("Working Hours test");
      await expect(page.getByTestId("subtitle")).toBeVisible();
      await page.getByTestId(sunday).getByRole("switch").click();
      await page.getByTestId(monday).first().click();
      await page.getByTestId(wednesday).getByRole("switch").click();
      await page.getByTestId(saturday).getByRole("switch").click();
      await page
        .locator("div")
        .filter({ hasText: "Sunday9:00am - 5:00pm" })
        .getByTestId("add-time-availability")
        .first()
        .click();
      await expect(page.locator("div").filter({ hasText: "6:00pm" }).nth(1)).toBeVisible();
      await page.getByRole("button", { name: save }).click();
      await expect(page.getByText("Sun - Tue, Thu - Sat, 9:00 AM - 5:00 PM")).toBeVisible();
      await expect(page.getByText("Sun, 5:00 PM - 6:00 PM")).toBeVisible();
      await page
        .locator("div")
        .filter({ hasText: "Sunday9:00am - 5:00pm" })
        .getByTestId("copy-button")
        .first()
        .click();
      await expect(page.getByText(copyTimesTo)).toBeVisible();
      await page.getByRole("checkbox", { name: monday }).check();
      await page.getByRole("button", { name: "Apply" }).click();
      await page.getByRole("button", { name: save }).click();
      await page
        .locator("#availability-form div")
        .filter({ hasText: "TimezoneEurope/London" })
        .locator("svg")
        .click();
      await page.locator("#react-select-3-input").fill("bras");
      await page.getByTestId("select-option-America/Sao_Paulo").click();
      await page.getByRole("button", { name: save }).click();
      await expect(page.getByTestId("toast-success").last()).toBeVisible();
      await page.getByTestId("add-override").click();
      await page.getByTestId("incrementMonth").click();
      await page.getByRole("button", { name: "20" }).click();
      await page.getByTestId("date-override-mark-unavailable").click();
      await page.getByTestId("add-override-submit-btn").click();
      await page.getByTestId("dialog-rejection").click();
      await page.getByTestId("date-overrides-list").getByRole("button").nth(1).click();
      await page.getByRole("button", { name: save }).click();
      await expect(page.getByTestId("toast-success").last()).toBeVisible();
    },
  };
}
import type { Server } from "http";

import { nextServer } from "../lib/next-server";

type ServerFixture = ReturnType<typeof createServerFixture>;

// creates a servers fixture instance and stores the collection
export const createServersFixture = () => {
  const store = { servers: [] } as { servers: ServerFixture[] };
  return {
    create: async () => {
      const server = await nextServer();
      const serverFixture = createServerFixture(server);
      store.servers.push(serverFixture);
      return serverFixture;
    },
    get: () => store.servers,
    deleteAll: async () => {
      store.servers.forEach((server) => server.delete());
      store.servers = [];
    },
  };
};

// creates the single server fixture
const createServerFixture = (server: Server) => {
  const store = { server };

  return {
    self: async () => store.server,
    delete: async () => store.server.close(),
  };
};

export enum TimeZoneEnum {
  USA = "America/Phoenix",
  UK = "Europe/London",
}
import type { Page } from "@playwright/test";
import type { Feature } from "@prisma/client";

import type { AppFlags } from "@calcom/features/flags/config";
import { prisma } from "@calcom/prisma";

type FeatureSlugs = keyof AppFlags;

export const createFeatureFixture = (page: Page) => {
  const store = { features: [], page } as { features: Feature[]; page: typeof page };
  let initalFeatures: Feature[] = [];

  // IIF to add all feautres to store on creation
  return {
    init: async () => {
      const features = await prisma.feature.findMany();
      store.features = features;
      initalFeatures = features;
      return features;
    },
    getAll: () => store.features,
    get: (slug: FeatureSlugs) => store.features.find((b) => b.slug === slug),
    deleteAll: async () => {
      await prisma.feature.deleteMany({
        where: { slug: { in: store.features.map((feature) => feature.slug) } },
      });
      store.features = [];
    },
    delete: async (slug: FeatureSlugs) => {
      await prisma.feature.delete({ where: { slug } });
      store.features = store.features.filter((b) => b.slug !== slug);
    },
    toggleFeature: async (slug: FeatureSlugs) => {
      const feature = store.features.find((b) => b.slug === slug);
      if (feature) {
        const enabled = !feature.enabled;
        await prisma.feature.update({ where: { slug }, data: { enabled } });
        store.features = store.features.map((b) => (b.slug === slug ? { ...b, enabled } : b));
      }
    },
    set: async (slug: FeatureSlugs, enabled: boolean) => {
      const feature = store.features.find((b) => b.slug === slug);
      if (feature) {
        store.features = store.features.map((b) => (b.slug === slug ? { ...b, enabled } : b));
        await prisma.feature.update({ where: { slug }, data: { enabled } });
      }
    },
    reset: () => (store.features = initalFeatures),
  };
};
import mailhog from "mailhog";

import { IS_MAILHOG_ENABLED } from "@calcom/lib/constants";

const unimplemented = () => {
  throw new Error("Mailhog is not enabled");
};

const hasUUID = (query: string) => {
  return /[a-zA-Z0-9]{22}/.test(query) || /[0-9a-f]{8}/.test(query);
};

export const createEmailsFixture = () => {
  if (IS_MAILHOG_ENABLED) {
    const mailhogAPI = mailhog();

    return {
      search: (query: string, kind?: string, start?: number, limit?: number) => {
        if (kind === "from" || kind === "to") {
          if (!hasUUID(query)) {
            throw new Error(
              `You should not use "from" or "to" queries without UUID in emails. Because mailhog maintains all the emails sent through tests, you should be able to uniquely identify the email among those. Found query: ${query}`
            );
          }
        }
        return mailhogAPI.search.bind(mailhogAPI)(query, kind, start, limit);
      },
      deleteMessage: mailhogAPI.deleteMessage.bind(mailhogAPI),
    };
  } else {
    return {
      search: unimplemented,
      deleteMessage: unimplemented,
    };
  }
};
import { v4 as uuidv4 } from "uuid";

import { prisma } from "@calcom/prisma";

type Route = {
  id: string;
  action: {
    type: string;
    value: string;
  };
  isFallback: boolean;
  queryValue: {
    id: string;
    type: string;
  };
};

export const createRoutingFormsFixture = () => {
  return {
    async create({
      userId,
      teamId,
      name,
      fields,
      routes = [],
    }: {
      name: string;
      userId: number;
      teamId: number | null;
      routes?: Route[];
      fields: {
        type: string;
        label: string;
        identifier?: string;
        required: boolean;
      }[];
    }) {
      return await prisma.app_RoutingForms_Form.create({
        data: {
          name,
          userId,
          teamId,
          routes: [
            ...routes,
            // Add a fallback route always, this is taken care of tRPC route normally but do it manually while running the query directly.
            {
              id: "898899aa-4567-489a-bcde-f1823f708646",
              action: { type: "customPageMessage", value: "Fallback Message" },
              isFallback: true,
              queryValue: { id: "898899aa-4567-489a-bcde-f1823f708646", type: "group" },
            },
          ],
          fields: fields.map((f) => ({
            id: uuidv4(),
            ...f,
          })),
        },
      });
    },
  };
};
import type { Page } from "@playwright/test";
import type { Team } from "@prisma/client";

import { prisma } from "@calcom/prisma";

const getRandomSlug = () => `org-${Math.random().toString(36).substring(7)}`;

// creates a user fixture instance and stores the collection
export const createOrgsFixture = (page: Page) => {
  const store = { orgs: [], page } as { orgs: Team[]; page: typeof page };
  return {
    create: async (opts: { name: string; slug?: string; requestedSlug?: string }) => {
      const org = await createOrgInDb({
        name: opts.name,
        slug: opts.slug || getRandomSlug(),
        requestedSlug: opts.requestedSlug,
      });
      store.orgs.push(org);
      return org;
    },
    get: () => store.orgs,
    deleteAll: async () => {
      await prisma.team.deleteMany({ where: { id: { in: store.orgs.map((org) => org.id) } } });
      store.orgs = [];
    },
    delete: async (id: number) => {
      await prisma.team.delete({ where: { id } });
      store.orgs = store.orgs.filter((b) => b.id !== id);
    },
  };
};

async function createOrgInDb({
  name,
  slug,
  requestedSlug,
}: {
  name: string;
  slug: string | null;
  requestedSlug?: string;
}) {
  return await prisma.team.create({
    data: {
      name: name,
      slug: slug,
      metadata: {
        isOrganization: true,
        ...(requestedSlug
          ? {
              requestedSlug,
            }
          : null),
      },
    },
  });
}
import type { Page } from "@playwright/test";
import type { Booking, Prisma } from "@prisma/client";
import short from "short-uuid";
import { v5 as uuidv5 } from "uuid";

import _dayjs from "@calcom/dayjs";
import { prisma } from "@calcom/prisma";

const translator = short();

type BookingFixture = ReturnType<typeof createBookingFixture>;

// We default all dayjs calls to use Europe/London timezone
const dayjs = (...args: Parameters<typeof _dayjs>) => _dayjs(...args).tz("Europe/London");

// creates a user fixture instance and stores the collection
export const createBookingsFixture = (page: Page) => {
  const store = { bookings: [], page } as { bookings: BookingFixture[]; page: typeof page };
  return {
    create: async (
      userId: number,
      username: string | null,
      eventTypeId = -1,
      {
        title = "",
        rescheduled = false,
        paid = false,
        status = "ACCEPTED",
        startTime,
        endTime,
        attendees = {
          create: {
            email: "attendee@example.com",
            name: "Attendee Example",
            timeZone: "Europe/London",
          },
        },
      }: Partial<Prisma.BookingCreateInput> = {},
      startDateParam?: Date,
      endDateParam?: Date
    ) => {
      const startDate = startDateParam || dayjs().add(1, "day").toDate();
      const seed = `${username}:${dayjs(startDate).utc().format()}:${new Date().getTime()}`;
      const uid = translator.fromUUID(uuidv5(seed, uuidv5.URL));
      const booking = await prisma.booking.create({
        data: {
          uid: uid,
          title: title || "30min",
          startTime: startTime || startDate,
          endTime: endTime || endDateParam || dayjs().add(1, "day").add(30, "minutes").toDate(),
          user: {
            connect: {
              id: userId,
            },
          },
          attendees,
          eventType: {
            connect: {
              id: eventTypeId,
            },
          },
          rescheduled,
          paid,
          status,
          iCalUID: `${uid}@cal.com`,
        },
      });
      const bookingFixture = createBookingFixture(booking, store.page);
      store.bookings.push(bookingFixture);
      return bookingFixture;
    },
    update: async (args: Prisma.BookingUpdateArgs) => await prisma.booking.update(args),
    get: () => store.bookings,
    delete: async (id: number) => {
      await prisma.booking.delete({
        where: { id },
      });
      store.bookings = store.bookings.filter((b) => b.id !== id);
    },
  };
};

// creates the single user fixture
const createBookingFixture = (booking: Booking, page: Page) => {
  const store = { booking, page };

  // self is a reflective method that return the Prisma object that references this fixture.
  return {
    id: store.booking.id,
    uid: store.booking.uid,
    self: async () =>
      await prisma.booking.findUnique({
        where: { id: store.booking.id },
        include: { attendees: true, seatsReferences: true },
      }),
    delete: async () => await prisma.booking.delete({ where: { id: store.booking.id } }),
  };
};
import type { Page, WorkerInfo } from "@playwright/test";
import type Prisma from "@prisma/client";
import type { Team } from "@prisma/client";
import { Prisma as PrismaType } from "@prisma/client";
import { hashSync as hash } from "bcryptjs";
import { uuid } from "short-uuid";

import stripe from "@calcom/features/ee/payments/server/stripe";
import { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from "@calcom/lib/availability";
import { WEBAPP_URL } from "@calcom/lib/constants";
import { prisma } from "@calcom/prisma";
import { MembershipRole, SchedulingType, TimeUnit, WorkflowTriggerEvents } from "@calcom/prisma/enums";
import { teamMetadataSchema } from "@calcom/prisma/zod-utils";
import type { Schedule } from "@calcom/types/schedule";

import { selectFirstAvailableTimeSlotNextMonth, teamEventSlug, teamEventTitle } from "../lib/testUtils";
import type { createEmailsFixture } from "./emails";
import { TimeZoneEnum } from "./types";

// Don't import hashPassword from app as that ends up importing next-auth and initializing it before NEXTAUTH_URL can be updated during tests.
export function hashPassword(password: string) {
  const hashedPassword = hash(password, 12);
  return hashedPassword;
}

type UserFixture = ReturnType<typeof createUserFixture>;

const userIncludes = PrismaType.validator<PrismaType.UserInclude>()({
  eventTypes: true,
  workflows: true,
  credentials: true,
  routingForms: true,
});

const userWithEventTypes = PrismaType.validator<PrismaType.UserArgs>()({
  include: userIncludes,
});

const seededForm = {
  id: "948ae412-d995-4865-875a-48302588de03",
  name: "Seeded Form - Pro",
};

type UserWithIncludes = PrismaType.UserGetPayload<typeof userWithEventTypes>;

const createTeamWorkflow = async (user: { id: number }, team: { id: number }) => {
  return await prisma.workflow.create({
    data: {
      name: "Team Workflow",
      trigger: WorkflowTriggerEvents.BEFORE_EVENT,
      time: 24,
      timeUnit: TimeUnit.HOUR,
      userId: user.id,
      teamId: team.id,
    },
  });
};

const createTeamEventType = async (
  user: { id: number },
  team: { id: number },
  scenario?: {
    schedulingType?: SchedulingType;
    teamEventTitle?: string;
    teamEventSlug?: string;
    teamEventLength?: number;
  }
) => {
  return await prisma.eventType.create({
    data: {
      team: {
        connect: {
          id: team.id,
        },
      },
      users: {
        connect: {
          id: user.id,
        },
      },
      owner: {
        connect: {
          id: user.id,
        },
      },
      hosts: {
        create: {
          userId: user.id,
          isFixed: scenario?.schedulingType === SchedulingType.COLLECTIVE ? true : false,
        },
      },
      schedulingType: scenario?.schedulingType ?? SchedulingType.COLLECTIVE,
      title: scenario?.teamEventTitle ?? `${teamEventTitle}-team-id-${team.id}`,
      slug: scenario?.teamEventSlug ?? `${teamEventSlug}-team-id-${team.id}`,
      length: scenario?.teamEventLength ?? 30,
    },
  });
};

const createTeamAndAddUser = async (
  {
    user,
    isUnpublished,
    isOrg,
    isOrgVerified,
    hasSubteam,
    organizationId,
  }: {
    user: { id: number; email: string; username: string | null; role?: MembershipRole };
    isUnpublished?: boolean;
    isOrg?: boolean;
    isOrgVerified?: boolean;
    hasSubteam?: true;
    organizationId?: number | null;
  },
  workerInfo: WorkerInfo
) => {
  const slug = `${isOrg ? "org" : "team"}-${workerInfo.workerIndex}-${Date.now()}`;
  const data: PrismaType.TeamCreateInput = {
    name: `user-id-${user.id}'s ${isOrg ? "Org" : "Team"}`,
  };
  data.metadata = {
    ...(isUnpublished ? { requestedSlug: slug } : {}),
    ...(isOrg
      ? {
          isOrganization: true,
          isOrganizationVerified: !!isOrgVerified,
          orgAutoAcceptEmail: user.email.split("@")[1],
          isOrganizationConfigured: false,
        }
      : {}),
  };
  data.slug = !isUnpublished ? slug : undefined;
  if (isOrg && hasSubteam) {
    const team = await createTeamAndAddUser({ user }, workerInfo);
    await createTeamEventType(user, team);
    await createTeamWorkflow(user, team);
    data.children = { connect: [{ id: team.id }] };
  }
  data.orgUsers = isOrg ? { connect: [{ id: user.id }] } : undefined;
  data.parent = organizationId ? { connect: { id: organizationId } } : undefined;
  const team = await prisma.team.create({
    data,
  });

  const { role = MembershipRole.OWNER, id: userId } = user;
  await prisma.membership.create({
    data: {
      teamId: team.id,
      userId,
      role: role,
      accepted: true,
    },
  });

  return team;
};

// creates a user fixture instance and stores the collection
export const createUsersFixture = (
  page: Page,
  emails: ReturnType<typeof createEmailsFixture>,
  workerInfo: WorkerInfo
) => {
  const store = { users: [], trackedEmails: [], page, teams: [] } as {
    users: UserFixture[];
    trackedEmails: { email: string }[];
    page: typeof page;
    teams: Team[];
  };
  return {
    buildForSignup: (opts?: Pick<CustomUserOpts, "email" | "username" | "useExactUsername" | "password">) => {
      const uname =
        opts?.useExactUsername && opts?.username
          ? opts.username
          : `${opts?.username || "user"}-${workerInfo.workerIndex}-${Date.now()}`;
      return {
        username: uname,
        email: opts?.email ?? `${uname}@example.com`,
        password: opts?.password ?? uname,
      };
    },
    create: async (
      opts?: CustomUserOpts | null,
      scenario: {
        seedRoutingForms?: boolean;
        hasTeam?: true;
        teamRole?: MembershipRole;
        teammates?: CustomUserOpts[];
        schedulingType?: SchedulingType;
        teamEventTitle?: string;
        teamEventSlug?: string;
        teamEventLength?: number;
        isOrg?: boolean;
        isOrgVerified?: boolean;
        hasSubteam?: true;
        isUnpublished?: true;
      } = {}
    ) => {
      const _user = await prisma.user.create({
        data: createUser(workerInfo, opts),
      });

      let defaultEventTypes: SupportedTestEventTypes[] = [
        { title: "30 min", slug: "30-min", length: 30 },
        { title: "Paid", slug: "paid", length: 30, price: 1000 },
        { title: "Opt in", slug: "opt-in", requiresConfirmation: true, length: 30 },
        { title: "Seated", slug: "seated", seatsPerTimeSlot: 2, length: 30 },
      ];

      if (opts?.eventTypes) defaultEventTypes = defaultEventTypes.concat(opts.eventTypes);
      for (const eventTypeData of defaultEventTypes) {
        eventTypeData.owner = { connect: { id: _user.id } };
        eventTypeData.users = { connect: { id: _user.id } };
        await prisma.eventType.create({
          data: eventTypeData,
        });
      }

      const workflows: SupportedTestWorkflows[] = [
        { name: "Default Workflow", trigger: "NEW_EVENT" },
        { name: "Test Workflow", trigger: "EVENT_CANCELLED" },
        ...(opts?.workflows || []),
      ];
      for (const workflowData of workflows) {
        workflowData.user = { connect: { id: _user.id } };
        await prisma.workflow.create({
          data: workflowData,
        });
      }

      if (scenario.seedRoutingForms) {
        await prisma.app_RoutingForms_Form.create({
          data: {
            routes: [
              {
                id: "8a898988-89ab-4cde-b012-31823f708642",
                action: { type: "eventTypeRedirectUrl", value: "pro/30min" },
                queryValue: {
                  id: "8a898988-89ab-4cde-b012-31823f708642",
                  type: "group",
                  children1: {
                    "8988bbb8-0123-4456-b89a-b1823f70c5ff": {
                      type: "rule",
                      properties: {
                        field: "c4296635-9f12-47b1-8153-c3a854649182",
                        value: ["event-routing"],
                        operator: "equal",
                        valueSrc: ["value"],
                        valueType: ["text"],
                      },
                    },
                  },
                },
              },
              {
                id: "aa8aaba9-cdef-4012-b456-71823f70f7ef",
                action: { type: "customPageMessage", value: "Custom Page Result" },
                queryValue: {
                  id: "aa8aaba9-cdef-4012-b456-71823f70f7ef",
                  type: "group",
                  children1: {
                    "b99b8a89-89ab-4cde-b012-31823f718ff5": {
                      type: "rule",
                      properties: {
                        field: "c4296635-9f12-47b1-8153-c3a854649182",
                        value: ["custom-page"],
                        operator: "equal",
                        valueSrc: ["value"],
                        valueType: ["text"],
                      },
                    },
                  },
                },
              },
              {
                id: "a8ba9aab-4567-489a-bcde-f1823f71b4ad",
                action: { type: "externalRedirectUrl", value: "https://google.com" },
                queryValue: {
                  id: "a8ba9aab-4567-489a-bcde-f1823f71b4ad",
                  type: "group",
                  children1: {
                    "998b9b9a-0123-4456-b89a-b1823f7232b9": {
                      type: "rule",
                      properties: {
                        field: "c4296635-9f12-47b1-8153-c3a854649182",
                        value: ["external-redirect"],
                        operator: "equal",
                        valueSrc: ["value"],
                        valueType: ["text"],
                      },
                    },
                  },
                },
              },
              {
                id: "aa8ba8b9-0123-4456-b89a-b182623406d8",
                action: { type: "customPageMessage", value: "Multiselect chosen" },
                queryValue: {
                  id: "aa8ba8b9-0123-4456-b89a-b182623406d8",
                  type: "group",
                  children1: {
                    "b98a8abb-cdef-4012-b456-718262343d27": {
                      type: "rule",
                      properties: {
                        field: "d4292635-9f12-17b1-9153-c3a854649182",
                        value: [["Option-2"]],
                        operator: "multiselect_equals",
                        valueSrc: ["value"],
                        valueType: ["multiselect"],
                      },
                    },
                  },
                },
              },
              {
                id: "898899aa-4567-489a-bcde-f1823f708646",
                action: { type: "customPageMessage", value: "Fallback Message" },
                isFallback: true,
                queryValue: { id: "898899aa-4567-489a-bcde-f1823f708646", type: "group" },
              },
            ],
            fields: [
              {
                id: "c4296635-9f12-47b1-8153-c3a854649182",
                type: "text",
                label: "Test field",
                required: true,
              },
              {
                id: "d4292635-9f12-17b1-9153-c3a854649182",
                type: "multiselect",
                label: "Multi Select",
                identifier: "multi",
                selectText: "Option-1\nOption-2",
                required: false,
              },
            ],
            user: {
              connect: {
                id: _user.id,
              },
            },
            name: seededForm.name,
          },
        });
      }
      const user = await prisma.user.findUniqueOrThrow({
        where: { id: _user.id },
        include: userIncludes,
      });
      if (scenario.hasTeam) {
        const team = await createTeamAndAddUser(
          {
            user: {
              id: user.id,
              email: user.email,
              username: user.username,
              role: scenario.teamRole || "OWNER",
            },
            isUnpublished: scenario.isUnpublished,
            isOrg: scenario.isOrg,
            isOrgVerified: scenario.isOrgVerified,
            hasSubteam: scenario.hasSubteam,
            organizationId: opts?.organizationId,
          },
          workerInfo
        );
        store.teams.push(team);

        const teamEvent = await createTeamEventType(user, team, scenario);

        if (scenario.teammates) {
          // Create Teammate users
          const teamMatesIds = [];
          for (const teammateObj of scenario.teammates) {
            const teamUser = await prisma.user.create({
              data: createUser(workerInfo, teammateObj),
            });

            // Add teammates to the team
            await prisma.membership.create({
              data: {
                teamId: team.id,
                userId: teamUser.id,
                role: MembershipRole.MEMBER,
                accepted: true,
              },
            });

            // Add teammate to the host list of team event
            await prisma.host.create({
              data: {
                userId: teamUser.id,
                eventTypeId: teamEvent.id,
                isFixed: scenario.schedulingType === SchedulingType.COLLECTIVE ? true : false,
              },
            });

            const teammateFixture = createUserFixture(
              await prisma.user.findUniqueOrThrow({
                where: { id: teamUser.id },
                include: userIncludes,
              }),
              store.page
            );
            teamMatesIds.push(teamUser.id);
            store.users.push(teammateFixture);
          }
          // Add Teammates to OrgUsers
          if (scenario.isOrg) {
            await prisma.team.update({
              where: {
                id: team.id,
              },
              data: {
                orgUsers: {
                  connect: teamMatesIds.map((userId) => ({ id: userId })).concat([{ id: user.id }]),
                },
              },
            });
          }
        }
      }
      const userFixture = createUserFixture(user, store.page);
      store.users.push(userFixture);
      return userFixture;
    },
    /**
     * Use this method to get an email that can be automatically cleaned up from all the places in DB
     */
    trackEmail: ({ username, domain }: { username: string; domain: string }) => {
      const email = `${username}-${uuid().substring(0, 8)}@${domain}`;
      store.trackedEmails.push({
        email,
      });
      return email;
    },
    get: () => store.users,
    logout: async () => {
      await page.goto("/auth/logout");
    },
    deleteAll: async () => {
      const ids = store.users.map((u) => u.id);
      if (emails) {
        const emailMessageIds: string[] = [];

        for (const user of store.trackedEmails.concat(store.users.map((u) => ({ email: u.email })))) {
          const emailMessages = await emails.search(user.email);
          if (emailMessages && emailMessages.count > 0) {
            emailMessages.items.forEach((item) => {
              emailMessageIds.push(item.ID);
            });
          }
        }
        for (const id of emailMessageIds) {
          await emails.deleteMessage(id);
        }
      }

      await prisma.user.deleteMany({ where: { id: { in: ids } } });
      // Delete all users that were tracked by email(if they were created)
      await prisma.user.deleteMany({ where: { email: { in: store.trackedEmails.map((e) => e.email) } } });
      await prisma.team.deleteMany({ where: { id: { in: store.teams.map((org) => org.id) } } });
      store.users = [];
      store.teams = [];
      store.trackedEmails = [];
    },
    delete: async (id: number) => {
      await prisma.user.delete({ where: { id } });
      store.users = store.users.filter((b) => b.id !== id);
    },
    deleteByEmail: async (email: string) => {
      // Use deleteMany instead of delete to avoid the findUniqueOrThrow error that happens before the delete
      await prisma.user.deleteMany({
        where: {
          email,
        },
      });
      store.users = store.users.filter((b) => b.email !== email);
    },
    set: async (email: string) => {
      const user = await prisma.user.findUniqueOrThrow({
        where: { email },
        include: userIncludes,
      });
      const userFixture = createUserFixture(user, store.page);
      store.users.push(userFixture);
      return userFixture;
    },
  };
};

type JSONValue = string | number | boolean | { [x: string]: JSONValue } | Array<JSONValue>;

// creates the single user fixture
const createUserFixture = (user: UserWithIncludes, page: Page) => {
  const store = { user, page };

  // self is a reflective method that return the Prisma object that references this fixture.
  const self = async () =>
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    (await prisma.user.findUnique({
      where: { id: store.user.id },
      include: { eventTypes: true },
    }))!;
  return {
    id: user.id,
    name: user.name,
    username: user.username,
    email: user.email,
    eventTypes: user.eventTypes,
    routingForms: user.routingForms,
    self,
    apiLogin: async (password?: string) =>
      apiLogin({ ...(await self()), password: password || user.username }, store.page),
    /**
     * @deprecated use apiLogin instead
     */
    login: async () => login({ ...(await self()), password: user.username }, store.page),
    logout: async () => {
      await page.goto("/auth/logout");
    },
    getFirstTeamMembership: async () => {
      const memberships = await prisma.membership.findMany({
        where: { userId: user.id },
        include: { team: true },
      });

      const membership = memberships
        .map((membership) => {
          return {
            ...membership,
            team: {
              ...membership.team,
              metadata: teamMetadataSchema.parse(membership.team.metadata),
            },
          };
        })
        .find((membership) => !membership.team?.metadata?.isOrganization);
      if (!membership) {
        throw new Error("No team found for user");
      }
      return membership;
    },
    getOrgMembership: async () => {
      return prisma.membership.findFirstOrThrow({
        where: {
          userId: user.id,
          team: {
            metadata: {
              path: ["isOrganization"],
              equals: true,
            },
          },
        },
        include: { team: { include: { children: true } } },
      });
    },
    getFirstEventAsOwner: async () =>
      prisma.eventType.findFirstOrThrow({
        where: {
          userId: user.id,
        },
      }),
    getFirstTeamEvent: async (teamId: number) => {
      return prisma.eventType.findFirstOrThrow({
        where: {
          teamId,
        },
      });
    },
    getPaymentCredential: async () => getPaymentCredential(store.page),
    setupEventWithPrice: async (eventType: Pick<Prisma.EventType, "id">, slug: string) =>
      setupEventWithPrice(eventType, slug, store.page),
    bookAndPayEvent: async (eventType: Pick<Prisma.EventType, "slug">) =>
      bookAndPayEvent(user, eventType, store.page),
    makePaymentUsingStripe: async () => makePaymentUsingStripe(store.page),
    // ths is for developemnt only aimed to inject debugging messages in the metadata field of the user
    debug: async (message: string | Record<string, JSONValue>) => {
      await prisma.user.update({
        where: { id: store.user.id },
        data: { metadata: { debug: message } },
      });
    },
    delete: async () => await prisma.user.delete({ where: { id: store.user.id } }),
    confirmPendingPayment: async () => confirmPendingPayment(store.page),
  };
};

type SupportedTestEventTypes = PrismaType.EventTypeCreateInput & {
  _bookings?: PrismaType.BookingCreateInput[];
};

type SupportedTestWorkflows = PrismaType.WorkflowCreateInput;

type CustomUserOptsKeys =
  | "username"
  | "password"
  | "completedOnboarding"
  | "locale"
  | "name"
  | "email"
  | "organizationId"
  | "twoFactorEnabled"
  | "disableImpersonation"
  | "role";
type CustomUserOpts = Partial<Pick<Prisma.User, CustomUserOptsKeys>> & {
  timeZone?: TimeZoneEnum;
  eventTypes?: SupportedTestEventTypes[];
  workflows?: SupportedTestWorkflows[];
  // ignores adding the worker-index after username
  useExactUsername?: boolean;
  roleInOrganization?: MembershipRole;
  schedule?: Schedule;
};

// creates the actual user in the db.
const createUser = (
  workerInfo: WorkerInfo,
  opts?: CustomUserOpts | null
): PrismaType.UserUncheckedCreateInput => {
  // build a unique name for our user
  const uname =
    opts?.useExactUsername && opts?.username
      ? opts.username
      : `${opts?.username || "user"}-${workerInfo.workerIndex}-${Date.now()}`;

  return {
    username: uname,
    name: opts?.name,
    email: opts?.email ?? `${uname}@example.com`,
    password: hashPassword(uname),
    emailVerified: new Date(),
    completedOnboarding: opts?.completedOnboarding ?? true,
    timeZone: opts?.timeZone ?? TimeZoneEnum.UK,
    locale: opts?.locale ?? "en",
    role: opts?.role ?? "USER",
    twoFactorEnabled: opts?.twoFactorEnabled ?? false,
    disableImpersonation: opts?.disableImpersonation ?? false,
    ...getOrganizationRelatedProps({ organizationId: opts?.organizationId, role: opts?.roleInOrganization }),
    schedules:
      opts?.completedOnboarding ?? true
        ? {
            create: {
              name: "Working Hours",
              timeZone: opts?.timeZone ?? TimeZoneEnum.UK,
              availability: {
                createMany: {
                  data: getAvailabilityFromSchedule(opts?.schedule ?? DEFAULT_SCHEDULE),
                },
              },
            },
          }
        : undefined,
  };

  function getOrganizationRelatedProps({
    organizationId,
    role,
  }: {
    organizationId: number | null | undefined;
    role: MembershipRole | undefined;
  }) {
    if (!organizationId) {
      return null;
    }
    if (!role) {
      throw new Error("Missing role for user in organization");
    }
    return {
      organizationId: organizationId || null,
      ...(organizationId
        ? {
            teams: {
              // Create membership
              create: [
                {
                  team: {
                    connect: {
                      id: organizationId,
                    },
                  },
                  accepted: true,
                  role: MembershipRole.ADMIN,
                },
              ],
            },
          }
        : null),
    };
  }
};

async function confirmPendingPayment(page: Page) {
  await page.waitForURL(new RegExp("/booking/*"));

  const url = page.url();

  const params = new URLSearchParams(url.split("?")[1]);

  const id = params.get("payment_intent");

  if (!id) throw new Error(`Payment intent not found in url ${url}`);

  const payload = JSON.stringify(
    { type: "payment_intent.succeeded", data: { object: { id } }, account: "e2e_test" },
    null,
    2
  );

  const signature = stripe.webhooks.generateTestHeaderString({
    payload,
    secret: process.env.STRIPE_WEBHOOK_SECRET as string,
  });

  const response = await page.request.post("/api/integrations/stripepayment/webhook", {
    data: payload,
    headers: { "stripe-signature": signature },
  });

  if (response.status() !== 200) throw new Error(`Failed to confirm payment. Response: ${response.text()}`);
}

// login using a replay of an E2E routine.
export async function login(
  user: Pick<Prisma.User, "username"> & Partial<Pick<Prisma.User, "password" | "email">>,
  page: Page
) {
  // get locators
  const loginLocator = page.locator("[data-testid=login-form]");
  const emailLocator = loginLocator.locator("#email");
  const passwordLocator = loginLocator.locator("#password");
  const signInLocator = loginLocator.locator('[type="submit"]');

  //login
  await page.goto("/");
  await emailLocator.fill(user.email ?? `${user.username}@example.com`);
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  await passwordLocator.fill(user.password ?? user.username!);
  await signInLocator.click();

  // waiting for specific login request to resolve
  await page.waitForResponse(/\/api\/auth\/callback\/credentials/);
}

export async function apiLogin(
  user: Pick<Prisma.User, "username"> & Partial<Pick<Prisma.User, "password" | "email">>,
  page: Page
) {
  const csrfToken = await page
    .context()
    .request.get("/api/auth/csrf")
    .then((response) => response.json())
    .then((json) => json.csrfToken);
  const data = {
    email: user.email ?? `${user.username}@example.com`,
    password: user.password ?? user.username,
    callbackURL: WEBAPP_URL,
    redirect: "false",
    json: "true",
    csrfToken,
  };
  return page.context().request.post("/api/auth/callback/credentials", {
    data,
  });
}

export async function setupEventWithPrice(eventType: Pick<Prisma.EventType, "id">, slug: string, page: Page) {
  await page.goto(`/event-types/${eventType?.id}?tabName=apps`);
  await page.locator(`[data-testid='${slug}-app-switch']`).first().click();
  await page.getByPlaceholder("Price").fill("100");
  await page.getByTestId("update-eventtype").click();
}

export async function bookAndPayEvent(
  user: Pick<Prisma.User, "username">,
  eventType: Pick<Prisma.EventType, "slug">,
  page: Page
) {
  // booking process with stripe integration
  await page.goto(`${user.username}/${eventType?.slug}`);
  await selectFirstAvailableTimeSlotNextMonth(page);
  // --- fill form
  await page.fill('[name="name"]', "Stripe Stripeson");
  await page.fill('[name="email"]', "test@example.com");

  await Promise.all([page.waitForURL("/payment/*"), page.press('[name="email"]', "Enter")]);

  await makePaymentUsingStripe(page);
}

export async function makePaymentUsingStripe(page: Page) {
  const stripeElement = await page.locator(".StripeElement").first();
  const stripeFrame = stripeElement.frameLocator("iframe").first();
  await stripeFrame.locator('[name="number"]').fill("4242 4242 4242 4242");
  const now = new Date();
  await stripeFrame.locator('[name="expiry"]').fill(`${now.getMonth() + 1} / ${now.getFullYear() + 1}`);
  await stripeFrame.locator('[name="cvc"]').fill("111");
  const postcalCodeIsVisible = await stripeFrame.locator('[name="postalCode"]').isVisible();
  if (postcalCodeIsVisible) {
    await stripeFrame.locator('[name="postalCode"]').fill("111111");
  }
  await page.click('button:has-text("Pay now")');
}

export async function getPaymentCredential(page: Page) {
  await page.goto("/apps/stripe");

  /** We start the Stripe flow */
  await Promise.all([
    page.waitForURL("https://connect.stripe.com/oauth/v2/authorize?*"),
    page.click('[data-testid="install-app-button"]'),
  ]);

  await Promise.all([
    page.waitForURL("/apps/installed/payment?hl=stripe"),
    /** We skip filling Stripe forms (testing mode only) */
    page.click('[id="skip-account-app"]'),
  ]);
}
import type { Page } from "@playwright/test";
import type { Payment } from "@prisma/client";
import { v4 as uuidv4 } from "uuid";

import { prisma } from "@calcom/prisma";

type PaymentFixture = ReturnType<typeof createPaymentFixture>;

// creates a user fixture instance and stores the collection
export const createPaymentsFixture = (page: Page) => {
  const store = { payments: [], page } as { payments: PaymentFixture[]; page: typeof page };
  return {
    create: async (
      bookingId: number,
      { success = false, refunded = false }: { success?: boolean; refunded?: boolean } = {}
    ) => {
      const payment = await prisma.payment.create({
        data: {
          uid: uuidv4(),
          amount: 20000,
          fee: 160,
          currency: "usd",
          success,
          refunded,
          app: {
            connect: {
              slug: "stripe",
            },
          },
          data: {},
          externalId: `DEMO_PAYMENT_FROM_DB_${Date.now()}`,
          booking: {
            connect: {
              id: bookingId,
            },
          },
        },
      });
      const paymentFixture = createPaymentFixture(payment, store.page);
      store.payments.push(paymentFixture);
      return paymentFixture;
    },
    get: () => store.payments,
    delete: async (id: number) => {
      await prisma.payment.delete({
        where: { id },
      });
      store.payments = store.payments.filter((b) => b.id !== id);
    },
  };
};

// creates the single user fixture
const createPaymentFixture = (payment: Payment, page: Page) => {
  const store = { payment, page };

  // self is a reflective method that return the Prisma object that references this fixture.
  return {
    id: store.payment.id,
    self: async () => await prisma.payment.findUnique({ where: { id: store.payment.id } }),
    delete: async () => await prisma.payment.delete({ where: { id: store.payment.id } }),
  };
};
/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";
import { installAppleCalendar } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });

test.afterEach(({ users }) => users.deleteAll());

const APPLE_CALENDAR_EMAIL = process.env.E2E_TEST_APPLE_CALENDAR_EMAIL!;

const APPLE_CALENDAR_PASSWORD = process.env.E2E_TEST_APPLE_CALENDAR_PASSWORD!;

const SHOULD_SKIP_TESTS = !APPLE_CALENDAR_EMAIL || !APPLE_CALENDAR_PASSWORD;

test.describe("Apple Calendar", () => {
  // eslint-disable-next-line playwright/no-skipped-test
  test.skip(SHOULD_SKIP_TESTS, "Skipping due to missing the testing credentials");

  test("Should be able to install and login on Apple Calendar", async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();

    await installAppleCalendar(page);

    await expect(page.locator('[data-testid="apple-calendar-form"]')).toBeVisible();

    await page.fill('[data-testid="apple-calendar-email"]', APPLE_CALENDAR_EMAIL);
    await page.fill('[data-testid="apple-calendar-password"]', APPLE_CALENDAR_PASSWORD);
    await page.click('[data-testid="apple-calendar-login-button"]');

    await expect(page.getByText("Apple Calendar")).toBeVisible();
    await expect(page.getByText(APPLE_CALENDAR_EMAIL)).toBeVisible();
  });
});
import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

test.afterEach(({ users }) => users.deleteAll());

test.describe("Teams", () => {
  test("Profile page is loaded for users in Organization", async ({ page, users }) => {
    const teamMatesObj = [{ name: "teammate-1" }, { name: "teammate-2" }];

    const owner = await users.create(undefined, {
      hasTeam: true,
      isOrg: true,
      hasSubteam: true,
      teammates: teamMatesObj,
    });
    await owner.apiLogin();
    await page.goto("/settings/my-account/profile");

    // check if user avatar is loaded
    await page.getByTestId("profile-upload-avatar").isVisible();
  });
});

export {};
//  TODO: @sean - I can't run E2E locally - causing me a lot of pain to try and debug.
//  Will tackle in follow up once i reset my system.
// test.describe("User can overlay their calendar", async () => {
//   test.afterAll(async ({ users }) => {
//     await users.deleteAll();
//   });
//   test("Continue with Cal.com flow", async ({ page, users }) => {
//     await users.create({
//       username: "overflow-user-test",
//     });
//     await test.step("toggles overlay without a session", async () => {
//       await page.goto("/overflow-user-test/30-min");
//       const switchLocator = page.locator(`[data-testid=overlay-calendar-switch]`);
//       await switchLocator.click();
//       const continueWithCalCom = page.locator(`[data-testid=overlay-calendar-continue-button]`);
//       await expect(continueWithCalCom).toBeVisible();
//       await continueWithCalCom.click();
//     });
//     // log in trail user
//     await test.step("Log in and return to booking page", async () => {
//       const user = await users.create();
//       await user.login();
//       // Expect page to be redirected to the test users booking page
//       await page.waitForURL("/overflow-user-test/30-min");
//     });
//     await test.step("Expect settings cog to be visible when session exists", async () => {
//       const settingsCog = page.locator(`[data-testid=overlay-calendar-settings-button]`);
//       await expect(settingsCog).toBeVisible();
//     });
//     await test.step("Settings should so no calendars connected", async () => {
//       const settingsCog = page.locator(`[data-testid=overlay-calendar-settings-button]`);
//       await settingsCog.click();
//       await page.waitForLoadState("networkidle");
//       const emptyScreenLocator = page.locator(`[data-testid=empty-screen]`);
//       await expect(emptyScreenLocator).toBeVisible();
//     });
//   });
// });
import { expect } from "@playwright/test";
import { v4 as uuidv4 } from "uuid";

import { randomString } from "@calcom/lib/random";
import prisma from "@calcom/prisma";
import { BookingStatus } from "@calcom/prisma/enums";

import { test } from "./lib/fixtures";
import {
  createNewSeatedEventType,
  selectFirstAvailableTimeSlotNextMonth,
  createUserWithSeatedEventAndAttendees,
} from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });
test.afterEach(({ users }) => users.deleteAll());

test.describe("Booking with Seats", () => {
  test("User can create a seated event (2 seats as example)", async ({ users, page }) => {
    const user = await users.create({ name: "Seated event" });
    await user.apiLogin();
    await page.goto("/event-types");
    // We wait until loading is finished
    await page.waitForSelector('[data-testid="event-types"]');

    const eventTitle = "My 2-seated event";
    await createNewSeatedEventType(page, { eventTitle });
    await expect(page.locator(`text=Event type updated successfully`)).toBeVisible();
  });

  test(`Prevent attendees from cancel when having invalid URL params`, async ({ page, users, bookings }) => {
    const { booking } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "John Third", email: "third+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);

    const bookingAttendees = await prisma.attendee.findMany({
      where: { bookingId: booking.id },
      select: {
        id: true,
        name: true,
        email: true,
      },
    });

    const bookingSeats = bookingAttendees.map((attendee) => ({
      bookingId: booking.id,
      attendeeId: attendee.id,
      referenceUid: uuidv4(),
      data: {
        responses: {
          name: attendee.name,
          email: attendee.email,
        },
      },
    }));

    await prisma.bookingSeat.createMany({
      data: bookingSeats,
    });

    await test.step("Attendee #2 shouldn't be able to cancel booking using only booking/uid", async () => {
      await page.goto(`/booking/${booking.uid}`);

      await expect(page.locator("[text=Cancel]")).toHaveCount(0);
    });

    await test.step("Attendee #2 shouldn't be able to cancel booking using randomString for seatReferenceUId", async () => {
      await page.goto(`/booking/${booking.uid}?seatReferenceUid=${randomString(10)}`);

      // expect cancel button to don't be in the page
      await expect(page.locator("[text=Cancel]")).toHaveCount(0);
    });
  });

  test("Owner shouldn't be able to cancel booking without login in", async ({ page, bookings, users }) => {
    const { booking, user } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "John Third", email: "third+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);
    await page.goto(`/booking/${booking.uid}?cancel=true`);
    await expect(page.locator("[text=Cancel]")).toHaveCount(0);

    // expect login text to be in the page, not data-testid
    await expect(page.locator("text=Login")).toHaveCount(1);

    // click on login button text
    await page.locator("text=Login").click();

    // expect to be redirected to login page with query parameter callbackUrl
    await expect(page).toHaveURL(/\/auth\/login\?callbackUrl=.*/);

    await user.apiLogin();

    // manual redirect to booking page
    await page.goto(`/booking/${booking.uid}?cancel=true`);

    // expect login button to don't be in the page
    await expect(page.locator("text=Login")).toHaveCount(0);

    // fill reason for cancellation
    await page.fill('[data-testid="cancel_reason"]', "Double booked!");

    // confirm cancellation
    await page.locator('[data-testid="confirm_cancel"]').click();
    await page.waitForLoadState("networkidle");

    const updatedBooking = await prisma.booking.findFirst({
      where: { id: booking.id },
    });

    expect(updatedBooking).not.toBeNull();
    expect(updatedBooking?.status).toBe(BookingStatus.CANCELLED);
  });
});

test.describe("Reschedule for booking with seats", () => {
  test("If rescheduled/cancelled booking with seats it should display the correct number of seats", async ({
    page,
    users,
    bookings,
  }) => {
    const { booking } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);

    const bookingAttendees = await prisma.attendee.findMany({
      where: { bookingId: booking.id },
      select: {
        id: true,
        name: true,
        email: true,
      },
    });

    const bookingSeats = bookingAttendees.map((attendee) => ({
      bookingId: booking.id,
      attendeeId: attendee.id,
      referenceUid: uuidv4(),
      data: {
        responses: {
          name: attendee.name,
          email: attendee.email,
        },
      },
    }));

    await prisma.bookingSeat.createMany({
      data: bookingSeats,
    });

    const references = await prisma.bookingSeat.findMany({
      where: { bookingId: booking.id },
    });

    await page.goto(
      `/booking/${references[0].referenceUid}?cancel=true&seatReferenceUid=${references[0].referenceUid}`
    );

    await page.locator('[data-testid="confirm_cancel"]').click();

    await page.waitForResponse((res) => res.url().includes("api/cancel") && res.status() === 200);

    const oldBooking = await prisma.booking.findFirst({
      where: { uid: booking.uid },
      select: {
        id: true,
        status: true,
      },
    });

    expect(oldBooking?.status).toBe(BookingStatus.ACCEPTED);

    await page.goto(`/reschedule/${references[1].referenceUid}`);

    await page.click('[data-testid="incrementMonth"]');

    await page.locator('[data-testid="day"][data-disabled="false"]').nth(1).click();

    // Validate that the number of seats its 10
    expect(await page.locator("text=9 / 10 Seats available").count()).toEqual(0);
  });

  test("Should cancel with seats but event should be still accessible and with one less attendee/seat", async ({
    page,
    users,
    bookings,
  }) => {
    const { user, booking } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);
    await user.apiLogin();

    const bookingAttendees = await prisma.attendee.findMany({
      where: { bookingId: booking.id },
      select: {
        id: true,
        name: true,
        email: true,
      },
    });

    const bookingSeats = bookingAttendees.map((attendee) => ({
      bookingId: booking.id,
      attendeeId: attendee.id,
      referenceUid: uuidv4(),
      data: {
        responses: {
          name: attendee.name,
          email: attendee.email,
        },
      },
    }));

    await prisma.bookingSeat.createMany({
      data: bookingSeats,
    });

    // Now we cancel the booking as the first attendee
    // booking/${bookingUid}?cancel=true&allRemainingBookings=false&seatReferenceUid={bookingSeat.referenceUid}
    await page.goto(
      `/booking/${booking.uid}?cancel=true&allRemainingBookings=false&seatReferenceUid=${bookingSeats[0].referenceUid}`
    );

    await page.locator('[data-testid="confirm_cancel"]').click();

    await page.waitForLoadState("networkidle");

    await expect(page).toHaveURL(/\/booking\/.*/);

    await page.goto(
      `/booking/${booking.uid}?cancel=true&allRemainingBookings=false&seatReferenceUid=${bookingSeats[1].referenceUid}`
    );

    // Page should not be 404
    await page.locator('[data-testid="confirm_cancel"]').click();

    await page.waitForLoadState("networkidle");

    await expect(page).toHaveURL(/\/booking\/.*/);
  });

  test("Should book with seats and hide attendees info from showAttendees true", async ({
    page,
    users,
    bookings,
  }) => {
    const { user, booking } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);
    await user.apiLogin();

    const bookingWithEventType = await prisma.booking.findFirst({
      where: { uid: booking.uid },
      select: {
        id: true,
        eventTypeId: true,
      },
    });

    await prisma.eventType.update({
      data: {
        seatsShowAttendees: false,
      },
      where: {
        id: bookingWithEventType?.eventTypeId || -1,
      },
    });

    const bookingAttendees = await prisma.attendee.findMany({
      where: { bookingId: booking.id },
      select: {
        id: true,
        name: true,
        email: true,
      },
    });

    const bookingSeats = bookingAttendees.map((attendee) => ({
      bookingId: booking.id,
      attendeeId: attendee.id,
      referenceUid: uuidv4(),
      data: {
        responses: {
          name: attendee.name,
          email: attendee.email,
        },
      },
    }));

    await prisma.bookingSeat.createMany({
      data: bookingSeats,
    });

    // Go to cancel page and see that attendees are listed and myself as I'm owner of the booking
    await page.goto(`/booking/${booking.uid}?cancel=true&allRemainingBookings=false`);

    const foundFirstAttendeeAsOwner = await page.locator(
      'p[data-testid="attendee-email-first+seats@cal.com"]'
    );
    await expect(foundFirstAttendeeAsOwner).toHaveCount(1);

    const foundSecondAttendeeAsOwner = await page.locator(
      'p[data-testid="attendee-email-second+seats@cal.com"]'
    );
    await expect(foundSecondAttendeeAsOwner).toHaveCount(1);

    await page.goto("auth/logout");

    // Now we cancel the booking as the first attendee
    // booking/${bookingUid}?cancel=true&allRemainingBookings=false&seatReferenceUid={bookingSeat.referenceUid}
    await page.goto(
      `/booking/${booking.uid}?cancel=true&allRemainingBookings=false&seatReferenceUid=${bookingSeats[0].referenceUid}`
    );

    // No attendees should be displayed only the one that it's cancelling
    const notFoundSecondAttendee = await page.locator('p[data-testid="attendee-email-second+seats@cal.com"]');

    await expect(notFoundSecondAttendee).toHaveCount(0);

    const foundFirstAttendee = await page.locator('p[data-testid="attendee-email-first+seats@cal.com"]');
    await expect(foundFirstAttendee).toHaveCount(1);

    await prisma.eventType.update({
      data: {
        seatsShowAttendees: true,
      },
      where: {
        id: bookingWithEventType?.eventTypeId || -1,
      },
    });

    await page.goto(
      `/booking/${booking.uid}?cancel=true&allRemainingBookings=false&seatReferenceUid=${bookingSeats[1].referenceUid}`
    );

    // Now attendees should be displayed
    const foundSecondAttendee = await page.locator('p[data-testid="attendee-email-second+seats@cal.com"]');

    await expect(foundSecondAttendee).toHaveCount(1);

    const foundFirstAttendeeAgain = await page
      .locator('p[data-testid="attendee-email-first+seats@cal.com"]')
      .first();
    await expect(foundFirstAttendeeAgain).toHaveCount(1);
  });

  test("Owner shouldn't be able to reschedule booking without login in", async ({
    page,
    bookings,
    users,
  }) => {
    const { booking, user } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "John Third", email: "third+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);

    const getBooking = await booking.self();

    await page.goto(`/booking/${booking.uid}`);
    await expect(page.locator('[data-testid="reschedule"]')).toHaveCount(0);

    // expect login text to be in the page, not data-testid
    await expect(page.locator("text=Login")).toHaveCount(1);

    // click on login button text
    await page.locator("text=Login").click();

    // expect to be redirected to login page with query parameter callbackUrl
    await expect(page).toHaveURL(/\/auth\/login\?callbackUrl=.*/);

    await user.apiLogin();

    // manual redirect to booking page
    await page.goto(`/booking/${booking.uid}`);

    // expect login button to don't be in the page
    await expect(page.locator("text=Login")).toHaveCount(0);

    // reschedule-link click
    await page.locator('[data-testid="reschedule-link"]').click();

    await selectFirstAvailableTimeSlotNextMonth(page);

    // data displayed in form should be user owner
    const nameElement = await page.locator("input[name=name]");

    const name = await nameElement.inputValue();
    expect(name).toBe(user.name);

    //same for email
    const emailElement = await page.locator("input[name=email]");

    const email = await emailElement.inputValue();
    expect(email).toBe(user.email);

    // reason to reschedule input should be visible textfield with name rescheduleReason
    const reasonElement = await page.locator("textarea[name=rescheduleReason]");
    await expect(reasonElement).toBeVisible();

    // expect to be redirected to reschedule page
    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    // should wait for URL but that path starts with booking/
    await page.waitForURL(/\/booking\/.*/);

    await expect(page).toHaveURL(/\/booking\/.*/);

    await page.waitForLoadState("networkidle");

    const updatedBooking = await prisma.booking.findFirst({
      where: { id: booking.id },
    });

    expect(updatedBooking).not.toBeNull();
    expect(getBooking?.startTime).not.toBe(updatedBooking?.startTime);
    expect(getBooking?.endTime).not.toBe(updatedBooking?.endTime);
    expect(updatedBooking?.status).toBe(BookingStatus.ACCEPTED);
  });

  test("Owner shouldn't be able to reschedule when going directly to booking/rescheduleUid", async ({
    page,
    bookings,
    users,
  }) => {
    const { booking, user } = await createUserWithSeatedEventAndAttendees({ users, bookings }, [
      { name: "John First", email: "first+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "Jane Second", email: "second+seats@cal.com", timeZone: "Europe/Berlin" },
      { name: "John Third", email: "third+seats@cal.com", timeZone: "Europe/Berlin" },
    ]);

    const getBooking = await booking.self();

    await page.goto(`/${user.username}/seats?rescheduleUid=${getBooking?.uid}&bookingUid=null`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    // expect textarea with name notes to be visible
    const notesElement = await page.locator("textarea[name=notes]");
    await expect(notesElement).toBeVisible();

    // expect button confirm instead of reschedule
    await expect(page.locator('[data-testid="confirm-book-button"]')).toHaveCount(1);

    // now login and try again
    await user.apiLogin();

    await page.goto(`/${user.username}/seats?rescheduleUid=${getBooking?.uid}&bookingUid=null`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await expect(page).toHaveTitle(/(?!.*reschedule).*/);

    // expect button reschedule
    await expect(page.locator('[data-testid="confirm-reschedule-button"]')).toHaveCount(1);
  });

  // @TODO: force 404 when rescheduleUid is not found
});
import { MembershipRole, WorkflowTriggerEvents } from "@calcom/prisma/enums";

import { loginUser, loginUserWithTeam } from "./fixtures/regularBookings";
import { test } from "./lib/fixtures";
import { bookEventOnThisPage } from "./lib/testUtils";

test.describe("Workflow Tab - Event Type", () => {
  test.describe("Check the functionalities of the Workflow Tab", () => {
    test.describe("User Workflows", () => {
      test.beforeEach(async ({ page, users }) => {
        await loginUser(users);
        await page.goto("/workflows");
      });

      test("Creating a new workflow", async ({ workflowPage }) => {
        const { createWorkflow, assertListCount } = workflowPage;

        await createWorkflow({ name: "" });
        await assertListCount(3);
      });

      test("Editing an existing workflow", async ({ workflowPage }) => {
        const { saveWorkflow, fillNameInput, editSelectedWorkflow, hasWorkflowInList } = workflowPage;

        await editSelectedWorkflow("Test Workflow");
        await fillNameInput("Edited Workflow");
        await saveWorkflow();
        await hasWorkflowInList("Edited Workflow");
      });

      test("Deleting an existing workflow", async ({ page, workflowPage }) => {
        const { hasWorkflowInList, deleteAndConfirm, assertListCount } = workflowPage;

        const firstWorkflow = page
          .getByTestId("workflow-list")
          .getByTestId(/workflow/)
          .first();

        await deleteAndConfirm(firstWorkflow);
        await hasWorkflowInList("Edited Workflow", true);
        await assertListCount(1);
      });

      test("Create an action and check if workflow is triggered", async ({ page, users, workflowPage }) => {
        const { createWorkflow, assertWorkflowReminders } = workflowPage;

        const [user] = users.get();

        const [eventType] = user.eventTypes;

        await createWorkflow({ name: "A New Workflow", trigger: WorkflowTriggerEvents.NEW_EVENT });
        await page.goto(`/${user.username}/${eventType.slug}`);
        await bookEventOnThisPage(page);
        await assertWorkflowReminders(eventType.id, 1);
      });
    });

    test.describe("Team Workflows", () => {
      test("Admin user", async ({ page, users, workflowPage }) => {
        const { createWorkflow, assertListCount } = workflowPage;

        await loginUserWithTeam(users, MembershipRole.ADMIN);
        await page.goto("/workflows");

        await createWorkflow({ name: "A New Workflow", isTeam: true });
        await assertListCount(4);
      });

      test("Member user", async ({ page, users, workflowPage }) => {
        const { hasReadonlyBadge, selectedWorkflowPage, workflowOptionsAreDisabled } = workflowPage;

        await loginUserWithTeam(users, MembershipRole.MEMBER);
        await page.goto("/workflows");

        await workflowOptionsAreDisabled("Team Workflow");
        await selectedWorkflowPage("Team Workflow");
        await hasReadonlyBadge();
      });
    });
  });
});
import { expect } from "@playwright/test";

import { test } from "./lib/fixtures";
import { bookTimeSlot, selectFirstAvailableTimeSlotNextMonth } from "./lib/testUtils";

test.describe.configure({ mode: "parallel" });

// TODO: This test is very flaky. Feels like tossing a coin and hope that it won't fail. Needs to be revisited.
test.fixme("hash my url", () => {
  test.beforeEach(async ({ users }) => {
    const user = await users.create();
    await user.apiLogin();
  });
  test.afterEach(async ({ users }) => {
    await users.deleteAll();
  });
  test("generate url hash", async ({ page }) => {
    await page.goto("/event-types");
    // We wait until loading is finished
    await page.waitForSelector('[data-testid="event-types"]');
    await page.locator("ul[data-testid=event-types] > li a").first().click();
    // We wait for the page to load
    await page.locator(".primary-navigation >> text=Advanced").click();
    // ignore if it is already checked, and click if unchecked
    const hashedLinkCheck = await page.locator('[data-testid="hashedLinkCheck"]');

    await hashedLinkCheck.click();

    // we wait for the hashedLink setting to load
    const $url = await page.locator('//*[@data-testid="generated-hash-url"]').inputValue();

    // click update
    await page.locator('[data-testid="update-eventtype"]').press("Enter");

    await page.waitForLoadState("networkidle");

    // book using generated url hash
    await page.goto($url);
    await selectFirstAvailableTimeSlotNextMonth(page);
    await bookTimeSlot(page);
    // Make sure we're navigated to the success page
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    // hash regenerates after successful booking
    await page.goto("/event-types");
    // We wait until loading is finished
    await page.waitForSelector('[data-testid="event-types"]');
    await page.locator("ul[data-testid=event-types] > li a").first().click();
    // We wait for the page to load
    await page.locator(".primary-navigation >> text=Advanced").click();
    // we wait for the hashedLink setting to load
    const $newUrl = await page.locator('//*[@data-testid="generated-hash-url"]').inputValue();
    expect($url !== $newUrl).toBeTruthy();
  });
});
import { expect } from "@playwright/test";

import _dayjs from "@calcom/dayjs";
import prisma from "@calcom/prisma";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

test.afterEach(({ users }) => users.deleteAll());

// We default all dayjs calls to use Europe/London timezone
const dayjs = (...args: Parameters<typeof _dayjs>) => _dayjs(...args).tz("Europe/London");

test.describe("Wipe my Cal App Test", () => {
  test("Browse upcoming bookings and validate button shows and triggering wipe my cal button", async ({
    page,
    users,
    bookings,
  }) => {
    const pro = await users.create();

    const [eventType] = pro.eventTypes;
    await prisma.credential.create({
      data: {
        key: {},
        type: "wipemycal_other",
        userId: pro.id,
        appId: "wipe-my-cal",
      },
    });
    await bookings.create(
      pro.id,
      pro.username,
      eventType.id,
      {},
      dayjs().endOf("day").subtract(29, "minutes").toDate(),
      dayjs().endOf("day").toDate()
    );
    await bookings.create(pro.id, pro.username, eventType.id, {});
    await bookings.create(pro.id, pro.username, eventType.id, {});
    await pro.apiLogin();
    await page.goto("/bookings/upcoming");
    await expect(page.locator("data-testid=wipe-today-button")).toBeVisible();

    const $openBookingCount = await page.locator('[data-testid="bookings"] > *').count();

    const $todayBookingCount = await page.locator('[data-testid="today-bookings"] > *').count();
    expect($openBookingCount + $todayBookingCount).toBe(3);

    await page.locator("data-testid=wipe-today-button").click();

    // Don't await send_request click, otherwise mutation can possibly occur before observer is attached
    page.locator("data-testid=send_request").click();
    // There will not be any today-bookings
    await expect(page.locator('[data-testid="today-bookings"]')).toBeHidden();
  });
});
import { expect } from "@playwright/test";

import { BookingStatus } from "@calcom/prisma/client";

import type { Fixtures } from "./lib/fixtures";
import { test } from "./lib/fixtures";

test.afterEach(({ users }) => users.deleteAll());

test.describe("Bookings", () => {
  test.describe("Upcoming bookings", () => {
    test("show attendee bookings and organizer bookings in asc order by startDate", async ({
      page,
      users,
      bookings,
    }) => {
      const firstUser = await users.create();
      const secondUser = await users.create();

      const bookingWhereFirstUserIsOrganizerFixture = await createBooking({
        title: "Booking as organizer",
        bookingsFixture: bookings,
        // Create a booking 3 days from today
        relativeDate: 3,
        organizer: firstUser,
        organizerEventType: firstUser.eventTypes[0],
        attendees: [
          { name: "First", email: "first@cal.com", timeZone: "Europe/Berlin" },
          { name: "Second", email: "second@cal.com", timeZone: "Europe/Berlin" },
          { name: "Third", email: "third@cal.com", timeZone: "Europe/Berlin" },
        ],
      });
      const bookingWhereFirstUserIsOrganizer = await bookingWhereFirstUserIsOrganizerFixture.self();

      const bookingWhereFirstUserIsAttendeeFixture = await createBooking({
        title: "Booking as attendee",
        bookingsFixture: bookings,
        organizer: secondUser,
        // Booking created 2 days from today
        relativeDate: 2,
        organizerEventType: secondUser.eventTypes[0],
        attendees: [
          { name: "OrganizerAsBooker", email: firstUser.email, timeZone: "Europe/Berlin" },
          { name: "Second", email: "second@cal.com", timeZone: "Europe/Berlin" },
          { name: "Third", email: "third@cal.com", timeZone: "Europe/Berlin" },
        ],
      });
      const bookingWhereFirstUserIsAttendee = await bookingWhereFirstUserIsAttendeeFixture.self();

      await firstUser.apiLogin();
      await page.goto(`/bookings/upcoming`);
      const upcomingBookings = page.locator('[data-testid="upcoming-bookings"]');
      const firstUpcomingBooking = upcomingBookings.locator('[data-testid="booking-item"]').nth(0);
      const secondUpcomingBooking = upcomingBookings.locator('[data-testid="booking-item"]').nth(1);
      await expect(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        firstUpcomingBooking.locator(`text=${bookingWhereFirstUserIsAttendee!.title}`)
      ).toBeVisible();
      await expect(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        secondUpcomingBooking.locator(`text=${bookingWhereFirstUserIsOrganizer!.title}`)
      ).toBeVisible();
    });
  });
});

async function createBooking({
  bookingsFixture,
  organizer,
  organizerEventType,
  attendees,
  /**
   * Relative date from today
   * 0 means today
   * 1 means tomorrow
   */
  relativeDate = 0,
  durationMins = 30,
  title,
}: {
  bookingsFixture: Fixtures["bookings"];
  organizer: {
    id: number;
    username: string | null;
  };
  organizerEventType: {
    id: number;
  };
  attendees: {
    name: string;
    email: string;
    timeZone: string;
  }[];
  relativeDate?: number;
  durationMins?: number;
  title: string;
}) {
  const DAY_MS = 24 * 60 * 60 * 1000;
  const bookingDurationMs = durationMins * 60 * 1000;
  const startTime = new Date(Date.now() + relativeDate * DAY_MS);
  const endTime = new Date(Date.now() + relativeDate * DAY_MS + bookingDurationMs);
  return await bookingsFixture.create(organizer.id, organizer.username, organizerEventType.id, {
    title,
    status: BookingStatus.ACCEPTED,
    startTime,
    endTime,
    attendees: {
      createMany: {
        data: [...attendees],
      },
    },
  });
}
import type { Page } from "@playwright/test";
import { expect } from "@playwright/test";
import { authenticator } from "otplib";

import { symmetricDecrypt } from "@calcom/lib/crypto";
import { totpAuthenticatorCheck } from "@calcom/lib/totp";
import { prisma } from "@calcom/prisma";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

// TODO: add more backup code tests, e.g. login + disabling 2fa with backup

// a test to logout requires both a succesfull login as logout, to prevent
// a doubling of tests failing on logout & logout, we can group them.
test.describe("2FA Tests", async () => {
  test.afterAll(async ({ users }) => {
    await users.deleteAll();
  });
  test("should allow a user to enable 2FA and login using 2FA", async ({ page, users }) => {
    // log in trail user
    const user = await test.step("Enable 2FA", async () => {
      const user = await users.create();
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const userPassword = user.username!;
      await user.apiLogin();

      // expects the home page for an authorized user
      await page.goto("/settings/security/two-factor-auth");
      await page.click(`[data-testid=two-factor-switch]`);
      await page.fill('input[name="password"]', userPassword);
      await page.press('input[name="password"]', "Enter");
      const secret = await page.locator(`[data-testid=two-factor-secret]`).textContent();
      expect(secret).toHaveLength(32);
      await page.click('[data-testid="goto-otp-screen"]');

      /**
       * Try a wrong code and test that wrong code is rejected.
       */
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      await fillOtp({ page, secret: "123456", noRetry: true });
      await expect(page.locator('[data-testid="error-submitting-code"]')).toBeVisible();

      await fillOtp({
        page,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        secret: secret!,
      });

      // FIXME: this passes even when switch is not checked, compare to test
      // below which checks for data-state="checked" and works as expected
      await page.waitForSelector(`[data-testid=two-factor-switch]`);
      await expect(page.locator(`[data-testid=two-factor-switch]`).isChecked()).toBeTruthy();

      return user;
    });

    await test.step("Logout", async () => {
      await page.goto("/auth/logout");
    });

    await test.step("Login with 2FA enabled", async () => {
      await user.login();
      const userWith2FaSecret = await prisma.user.findFirst({
        where: {
          id: user.id,
        },
      });

      const secret = symmetricDecrypt(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        userWith2FaSecret!.twoFactorSecret!,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        process.env.CALENDSO_ENCRYPTION_KEY!
      );
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      await fillOtp({ page, secret: secret! });
      await Promise.all([
        page.press('input[name="2fa6"]', "Enter"),
        page.waitForResponse("**/api/auth/callback/credentials**"),
      ]);
      const shellLocator = page.locator(`[data-testid=dashboard-shell]`);

      // expects the home page for an authorized user
      await page.goto("/");
      await expect(shellLocator).toBeVisible();
    });
  });

  test("should allow a user to disable 2FA", async ({ page, users }) => {
    // log in trail user
    const user = await test.step("Enable 2FA", async () => {
      const user = await users.create();
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const userPassword = user.username!;
      await user.apiLogin();

      // expects the home page for an authorized user
      await page.goto("/settings/security/two-factor-auth");
      await page.click(`[data-testid=two-factor-switch][data-state="unchecked"]`);
      await page.fill('input[name="password"]', userPassword);
      await page.press('input[name="password"]', "Enter");
      const secret = await page.locator(`[data-testid=two-factor-secret]`).textContent();
      expect(secret).toHaveLength(32);
      await page.click('[data-testid="goto-otp-screen"]');

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      await fillOtp({ page, secret: secret! });

      // backup codes are now showing, so run a few tests

      // click download button
      const promise = page.waitForEvent("download");
      await page.getByTestId("backup-codes-download").click();
      const download = await promise;
      expect(download.suggestedFilename()).toBe("cal-backup-codes.txt");
      // TODO: check file content

      // click copy button
      await page.getByTestId("backup-codes-copy").click();
      await page.getByTestId("toast-success").waitFor();
      // TODO: check clipboard content

      // close backup code dialog
      await page.getByTestId("backup-codes-close").click();

      await expect(page.locator(`[data-testid=two-factor-switch][data-state="checked"]`)).toBeVisible();

      return user;
    });

    await test.step("Disable 2FA", async () => {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const userPassword = user.username!;

      // expects the home page for an authorized user
      await page.goto("/settings/security/two-factor-auth");
      await page.click(`[data-testid=two-factor-switch][data-state="checked"]`);
      await page.fill('input[name="password"]', userPassword);

      const userWith2FaSecret = await prisma.user.findFirst({
        where: {
          id: user.id,
        },
      });

      const secret = symmetricDecrypt(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        userWith2FaSecret!.twoFactorSecret!,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        process.env.CALENDSO_ENCRYPTION_KEY!
      );

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      await fillOtp({ page, secret: secret! });
      await page.click('[data-testid="disable-2fa"]');
      await expect(page.locator(`[data-testid=two-factor-switch][data-state="unchecked"]`)).toBeVisible();

      return user;
    });
  });
});

async function fillOtp({ page, secret, noRetry }: { page: Page; secret: string; noRetry?: boolean }) {
  let token = authenticator.generate(secret);
  if (!noRetry && !totpAuthenticatorCheck(token, secret)) {
    console.log("Token expired, Renerating.");
    // Maybe token was just about to expire, try again just once more
    token = authenticator.generate(secret);
  }
  await page.fill('input[name="2fa1"]', token[0]);
  await page.fill('input[name="2fa2"]', token[1]);
  await page.fill('input[name="2fa3"]', token[2]);
  await page.fill('input[name="2fa4"]', token[3]);
  await page.fill('input[name="2fa5"]', token[4]);
  await page.fill('input[name="2fa6"]', token[5]);
}
import { loginUser } from "../fixtures/regularBookings";
import { test } from "../lib/fixtures";

test.describe("Limits Tab - Event Type", () => {
  test.beforeEach(async ({ page, users, bookingPage }) => {
    await loginUser(users);
    await page.goto("/event-types");
    await bookingPage.goToEventType("30 min");
    await bookingPage.goToTab("event_limit_tab_title");
  });

  test("Check the functionalities of the Limits Tab", async ({ bookingPage }) => {
    await bookingPage.checkLimitBookingFrequency();
    await bookingPage.checkLimitBookingDuration();
    await bookingPage.checkLimitFutureBookings();
    await bookingPage.checkOffsetTimes();
    await bookingPage.checkBufferTime();

    await bookingPage.updateEventType();

    const eventTypePage = await bookingPage.previewEventType();

    await eventTypePage.waitForTimeout(10000);

    const counter = await eventTypePage.getByTestId("time").count();
    await bookingPage.checkTimeSlotsCount(eventTypePage, counter);
  });
});
import { expect } from "@playwright/test";

import dayjs from "@calcom/dayjs";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

test.describe("Availablity tests", () => {
  test.beforeEach(async ({ page, users }) => {
    const user = await users.create();
    await user.apiLogin();
    await page.goto("/availability");
    // We wait until loading is finished
    await page.waitForSelector('[data-testid="schedules"]');
  });

  test.afterEach(async ({ users }) => {
    await users.deleteAll();
  });

  test("Date Overrides", async ({ page }) => {
    await test.step("Can add a date override", async () => {
      await page.locator('[data-testid="schedules"] > li a').click();
      await page.locator('[data-testid="add-override"]').click();
      await page.locator('[id="modal-title"]').waitFor();
      await page.locator('[data-testid="incrementMonth"]').click();
      await page.locator('[data-testid="day"][data-disabled="false"]').nth(0).click();
      await page.locator('[data-testid="date-override-mark-unavailable"]').click();
      await page.locator('[data-testid="add-override-submit-btn"]').click();
      await page.locator('[data-testid="dialog-rejection"]').click();
      await expect(page.locator('[data-testid="date-overrides-list"] > li')).toHaveCount(1);
      await page.locator('[form="availability-form"][type="submit"]').click();
    });

    await test.step("Date override is displayed in troubleshooter", async () => {
      const response = await page.waitForResponse("**/api/trpc/availability/schedule.update?batch=1");
      const json = await response.json();
      // @ts-expect-error trust me bro
      const date = json[0].result.data.json.schedule.availability.find((a) => !!a.date);
      const troubleshooterURL = `/availability/troubleshoot?date=${dayjs(date.date).format("YYYY-MM-DD")}`;
      await page.goto(troubleshooterURL);
      await page.waitForLoadState("networkidle");
      await expect(page.locator('[data-testid="troubleshooter-busy-time"]')).toHaveCount(1);
    });
  });

  test("Availability pages", async ({ page }) => {
    await test.step("Can add a new schedule", async () => {
      await page.locator('[data-testid="new-schedule"]').click();
      await page.locator('[id="name"]').fill("More working hours");
      page.locator('[type="submit"]').click();
      await expect(page.locator("[data-testid=availablity-title]")).toHaveValue("More working hours");
    });
    await test.step("Can delete a schedule", async () => {
      await page.getByRole("button", { name: /Go Back/i }).click();
      await page.locator('[data-testid="schedules"] > li').nth(1).getByTestId("schedule-more").click();
      await page.locator('[data-testid="delete-schedule"]').click();
      const toast = await page.waitForSelector('[data-testid="toast-success"]');
      expect(toast).toBeTruthy();

      await expect(page.locator('[data-testid="schedules"] > li').nth(1)).toHaveCount(0);
    });
    await test.step("Cannot delete a schedule if a single schedule is present", async () => {
      await page.locator('[data-testid="schedules"] > li').nth(0).getByTestId("schedule-more").click();
      await page.locator('[data-testid="delete-schedule"]').click();
      const toast = await page.waitForSelector('[data-testid="toast-error"]');
      expect(toast).toBeTruthy();

      await expect(page.locator('[data-testid="schedules"] > li').nth(0)).toHaveCount(1);
    });
  });
});
import { expect } from "@playwright/test";

import { randomString } from "@calcom/lib/random";
import prisma from "@calcom/prisma";

import { test } from "./lib/fixtures";

test.describe.configure({ mode: "parallel" });

const createTeamsAndMembership = async (userIdOne: number, userIdTwo: number) => {
  const teamOne = await prisma.team.create({
    data: {
      name: "test-insights",
      slug: `test-insights-${Date.now()}-${randomString(5)}}`,
    },
  });

  const teamTwo = await prisma.team.create({
    data: {
      name: "test-insights-2",
      slug: `test-insights-2-${Date.now()}-${randomString(5)}}`,
    },
  });
  if (!userIdOne || !userIdTwo || !teamOne || !teamTwo) {
    throw new Error("Failed to create test data");
  }

  // create memberships
  await prisma.membership.create({
    data: {
      userId: userIdOne,
      teamId: teamOne.id,
      accepted: true,
      role: "ADMIN",
    },
  });
  await prisma.membership.create({
    data: {
      teamId: teamTwo.id,
      userId: userIdOne,
      accepted: true,
      role: "ADMIN",
    },
  });
  await prisma.membership.create({
    data: {
      teamId: teamOne.id,
      userId: userIdTwo,
      accepted: true,
      role: "MEMBER",
    },
  });
  await prisma.membership.create({
    data: {
      teamId: teamTwo.id,
      userId: userIdTwo,
      accepted: true,
      role: "MEMBER",
    },
  });
  return { teamOne, teamTwo };
};

test.afterAll(async ({ users }) => {
  await users.deleteAll();
});

test.describe("Insights", async () => {
  test("should be able to go to insights as admins", async ({ page, users }) => {
    const user = await users.create();

    const userTwo = await users.create();
    await createTeamsAndMembership(user.id, userTwo.id);

    await user.apiLogin();

    // go to insights page
    await page.goto("/insights");
    await page.waitForLoadState("networkidle");

    // expect url to have isAll and TeamId in query params
    expect(page.url()).toContain("isAll=false");
    expect(page.url()).toContain("teamId=");
  });

  test("should be able to go to insights as members", async ({ page, users }) => {
    const user = await users.create();

    const userTwo = await users.create();

    await userTwo.apiLogin();

    await createTeamsAndMembership(user.id, userTwo.id);
    // go to insights page
    await page.goto("/insights");

    await page.waitForLoadState("networkidle");

    // expect url to have isAll and TeamId in query params

    expect(page.url()).toContain("isAll=false");
    expect(page.url()).not.toContain("teamId=");
  });

  test("team select filter should have 2 teams and your account option only as member", async ({
    page,
    users,
  }) => {
    const user = await users.create();

    const userTwo = await users.create();

    await user.apiLogin();

    await createTeamsAndMembership(user.id, userTwo.id);
    // go to insights page
    await page.goto("/insights");

    await page.waitForLoadState("networkidle");

    // get div from team select filter with this class flex flex-col gap-0.5 [&>*:first-child]:mt-1 [&>*:last-child]:mb-1
    await page.getByTestId("dashboard-shell").getByText("Team: test-insights").click();
    await page
      .locator('div[class="flex flex-col gap-0.5 [&>*:first-child]:mt-1 [&>*:last-child]:mb-1"]')
      .click();

    const teamSelectFilter = await page.locator(
      'div[class="hover:bg-muted flex items-center py-2 pl-3 pr-2.5 hover:cursor-pointer"]'
    );

    await expect(teamSelectFilter).toHaveCount(3);
  });

  test("Insights Organization should have isAll option true", async ({ users, page }) => {
    const owner = await users.create(undefined, {
      hasTeam: true,
      isUnpublished: true,
      isOrg: true,
      hasSubteam: true,
    });
    await owner.apiLogin();

    await page.goto("/insights");
    await page.waitForLoadState("networkidle");

    await page.getByTestId("dashboard-shell").getByText("All").nth(1).click();

    const teamSelectFilter = await page.locator(
      'div[class="hover:bg-muted flex items-center py-2 pl-3 pr-2.5 hover:cursor-pointer"]'
    );

    await expect(teamSelectFilter).toHaveCount(4);
  });

  test("should have all option in team-and-self filter as admin", async ({ page, users }) => {
    const owner = await users.create();

    const member = await users.create();

    await createTeamsAndMembership(owner.id, member.id);

    await owner.apiLogin();

    await page.goto("/insights");

    // get div from team select filter with this class flex flex-col gap-0.5 [&>*:first-child]:mt-1 [&>*:last-child]:mb-1
    await page.getByTestId("dashboard-shell").getByText("Team: test-insights").click();
    await page
      .locator('div[class="flex flex-col gap-0.5 [&>*:first-child]:mt-1 [&>*:last-child]:mb-1"]')
      .click();

    const teamSelectFilter = await page.locator(
      'div[class="hover:bg-muted flex items-center py-2 pl-3 pr-2.5 hover:cursor-pointer"]'
    );

    await expect(teamSelectFilter).toHaveCount(3);
  });

  test("should be able to switch between teams and self profile for insights", async ({ page, users }) => {
    const owner = await users.create();

    const member = await users.create();

    await createTeamsAndMembership(owner.id, member.id);

    await owner.apiLogin();

    await page.goto("/insights");

    // get div from team select filter with this class flex flex-col gap-0.5 [&>*:first-child]:mt-1 [&>*:last-child]:mb-1
    await page.getByTestId("dashboard-shell").getByText("Team: test-insights").click();
    await page
      .locator('div[class="flex flex-col gap-0.5 [&>*:first-child]:mt-1 [&>*:last-child]:mb-1"]')
      .click();

    const teamSelectFilter = await page.locator(
      'div[class="hover:bg-muted flex items-center py-2 pl-3 pr-2.5 hover:cursor-pointer"]'
    );

    await expect(teamSelectFilter).toHaveCount(3);

    // switch to self profile
    await page.getByTestId("dashboard-shell").getByText("Your Account").click();

    // switch to team 1
    await page.getByTestId("dashboard-shell").getByText("test-insights").nth(0).click();

    // switch to team 2
    await page.getByTestId("dashboard-shell").getByText("test-insights-2").click();
  });

  test("should be able to switch between memberUsers", async ({ page, users }) => {
    const owner = await users.create();

    const member = await users.create();

    await createTeamsAndMembership(owner.id, member.id);

    await owner.apiLogin();

    await page.goto("/insights");

    await page.getByText("Add filter").click();

    await page.getByRole("button", { name: "User" }).click();
    // <div class="flex select-none truncate font-medium" data-state="closed">People</div>
    await page.locator('div[class="flex select-none truncate font-medium"]').getByText("People").click();

    await page
      .locator('div[class="hover:bg-muted flex items-center py-2 pl-3 pr-2.5 hover:cursor-pointer"]')
      .nth(0)
      .click();
    await page.waitForLoadState("networkidle");

    await page
      .locator('div[class="hover:bg-muted flex items-center py-2 pl-3 pr-2.5 hover:cursor-pointer"]')
      .nth(1)
      .click();
    await page.waitForLoadState("networkidle");
    // press escape button to close the filter
    await page.keyboard.press("Escape");

    await page.getByRole("button", { name: "Clear" }).click();

    // expect for "Team: test-insight" text in page
    expect(await page.locator("text=Team: test-insights").isVisible()).toBeTruthy();
  });

  test("should test download button", async ({ page, users }) => {
    const owner = await users.create();

    const member = await users.create();

    await createTeamsAndMembership(owner.id, member.id);

    await owner.apiLogin();

    await page.goto("/insights");
    await page.waitForLoadState("networkidle");

    const downloadPromise = page.waitForEvent("download");

    // Expect download button to be visible
    expect(await page.locator("text=Download").isVisible()).toBeTruthy();

    // Click on Download button
    await page.getByText("Download").click();

    // Expect as csv option to be visible
    expect(await page.locator("text=as CSV").isVisible()).toBeTruthy();

    // Start waiting for download before clicking. Note no await.
    await page.getByText("as CSV").click();

    const download = await downloadPromise;

    // Wait for the download process to complete and save the downloaded file somewhere.
    await download.saveAs("./" + "test-insights.csv");
  });
});
import { expect } from "@playwright/test";

import dayjs from "@calcom/dayjs";
import prisma from "@calcom/prisma";
import { BookingStatus } from "@calcom/prisma/enums";
import { bookingMetadataSchema } from "@calcom/prisma/zod-utils";

import { test } from "./lib/fixtures";
import { selectFirstAvailableTimeSlotNextMonth, bookTimeSlot } from "./lib/testUtils";

const IS_STRIPE_ENABLED = !!(
  process.env.STRIPE_CLIENT_ID &&
  process.env.NEXT_PUBLIC_STRIPE_PUBLIC_KEY &&
  process.env.STRIPE_PRIVATE_KEY
);

test.describe.configure({ mode: "parallel" });

test.afterEach(({ users }) => users.deleteAll());

test.describe("Reschedule Tests", async () => {
  test("Should do a booking request reschedule from /bookings", async ({ page, users, bookings }) => {
    const user = await users.create();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const booking = await bookings.create(user.id, user.username, user.eventTypes[0].id!, {
      status: BookingStatus.ACCEPTED,
    });

    await user.apiLogin();
    await page.goto("/bookings/upcoming");

    await page.locator('[data-testid="edit_booking"]').nth(0).click();

    await page.locator('[data-testid="reschedule_request"]').click();

    await page.fill('[data-testid="reschedule_reason"]', "I can't longer have it");

    await page.locator('button[data-testid="send_request"]').click();
    await expect(page.locator('[id="modal-title"]')).toBeHidden();

    const updatedBooking = await booking.self();

    expect(updatedBooking?.rescheduled).toBe(true);
    expect(updatedBooking?.cancellationReason).toBe("I can't longer have it");
    expect(updatedBooking?.status).toBe(BookingStatus.CANCELLED);
    await booking.delete();
  });

  test("Should display former time when rescheduling availability", async ({ page, users, bookings }) => {
    const user = await users.create();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const booking = await bookings.create(user.id, user.username, user.eventTypes[0].id!, {
      status: BookingStatus.CANCELLED,
      rescheduled: true,
    });

    await page.goto(`/${user.username}/${user.eventTypes[0].slug}?rescheduleUid=${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    const formerTimeElement = page.locator('[data-testid="former_time_p"]');
    await expect(formerTimeElement).toBeVisible();
    await booking.delete();
  });

  test("Should display request reschedule send on bookings/cancelled", async ({ page, users, bookings }) => {
    const user = await users.create();

    const booking = await bookings.create(user.id, user.username, user.eventTypes[0].id, {
      status: BookingStatus.CANCELLED,
      rescheduled: true,
    });

    await user.apiLogin();
    await page.goto("/bookings/cancelled");

    const requestRescheduleSentElement = page.locator('[data-testid="request_reschedule_sent"]').nth(1);
    await expect(requestRescheduleSentElement).toBeVisible();
    await booking.delete();
  });

  test("Should do a reschedule from user owner", async ({ page, users, bookings }) => {
    const user = await users.create();

    const [eventType] = user.eventTypes;

    const booking = await bookings.create(user.id, user.username, eventType.id, {
      status: BookingStatus.CANCELLED,
      rescheduled: true,
    });

    await page.goto(`/${user.username}/${eventType.slug}?rescheduleUid=${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await expect(page.locator('[name="name"]')).toBeDisabled();
    await expect(page.locator('[name="email"]')).toBeDisabled();

    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    await page.waitForLoadState("networkidle");

    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    const newBooking = await prisma.booking.findFirstOrThrow({ where: { fromReschedule: booking.uid } });

    const rescheduledBooking = await prisma.booking.findFirstOrThrow({ where: { uid: booking.uid } });

    expect(newBooking).not.toBeNull();
    expect(rescheduledBooking.status).toBe(BookingStatus.CANCELLED);

    await prisma.booking.deleteMany({
      where: {
        id: {
          in: [newBooking.id, rescheduledBooking.id],
        },
      },
    });
  });

  test("Unpaid rescheduling should go to payment page", async ({ page, users, bookings, payments }) => {
    // eslint-disable-next-line playwright/no-skipped-test
    test.skip(!IS_STRIPE_ENABLED, "Skipped as Stripe is not installed");

    const user = await users.create();
    await user.apiLogin();
    await user.getPaymentCredential();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const eventType = user.eventTypes.find((e) => e.slug === "paid")!;

    const booking = await bookings.create(user.id, user.username, eventType.id, {
      rescheduled: true,
      status: BookingStatus.CANCELLED,
      paid: false,
    });
    await prisma.eventType.update({
      where: {
        id: eventType.id,
      },
      data: {
        metadata: {
          apps: {
            stripe: {
              price: 20000,
              enabled: true,
              currency: "usd",
            },
          },
        },
      },
    });

    const payment = await payments.create(booking.id);
    await page.goto(`/${user.username}/${eventType.slug}?rescheduleUid=${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    await page.waitForURL((url) => {
      return url.pathname.indexOf("/payment") > -1;
    });

    await expect(page).toHaveURL(/.*payment/);
  });

  test("Paid rescheduling should go to success page", async ({ page, users, bookings, payments }) => {
    const user = await users.create();
    await user.apiLogin();
    await user.getPaymentCredential();
    await users.logout();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const eventType = user.eventTypes.find((e) => e.slug === "paid")!;

    const booking = await bookings.create(user.id, user.username, eventType.id, {
      rescheduled: true,
      status: BookingStatus.CANCELLED,
      paid: true,
    });

    const payment = await payments.create(booking.id);
    await page.goto(`/${user?.username}/${eventType?.slug}?rescheduleUid=${booking?.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    await expect(page).toHaveURL(/.*booking/);
  });

  test("Opt in event should be PENDING when rescheduled by USER", async ({ page, users, bookings }) => {
    const user = await users.create();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const eventType = user.eventTypes.find((e) => e.slug === "opt-in")!;

    const booking = await bookings.create(user.id, user.username, eventType.id, {
      status: BookingStatus.ACCEPTED,
    });

    await page.goto(`/${user.username}/${eventType.slug}?rescheduleUid=${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    await expect(page).toHaveURL(/.*booking/);

    const newBooking = await prisma.booking.findFirst({ where: { fromReschedule: booking?.uid } });
    expect(newBooking).not.toBeNull();
    expect(newBooking?.status).toBe(BookingStatus.PENDING);
  });

  test("Opt in event should be ACCEPTED when rescheduled by OWNER", async ({ page, users, bookings }) => {
    const user = await users.create();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const eventType = user.eventTypes.find((e) => e.slug === "opt-in")!;

    const booking = await bookings.create(user.id, user.username, eventType.id, {
      status: BookingStatus.ACCEPTED,
    });
    await user.apiLogin();

    await page.goto(`/${user.username}/${eventType.slug}?rescheduleUid=${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    await expect(page).toHaveURL(/.*booking/);

    const newBooking = await prisma.booking.findFirst({ where: { fromReschedule: booking?.uid } });
    expect(newBooking).not.toBeNull();
    expect(newBooking?.status).toBe(BookingStatus.ACCEPTED);
  });

  test("Attendee should be able to reschedule a booking", async ({ page, users, bookings }) => {
    const user = await users.create();

    const eventType = user.eventTypes[0];

    const booking = await bookings.create(user.id, user.username, eventType.id);

    // Go to attendee's reschedule link
    await page.goto(`/reschedule/${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();

    await expect(page).toHaveURL(/.*booking/);

    const newBooking = await prisma.booking.findFirst({ where: { fromReschedule: booking?.uid } });
    expect(newBooking).not.toBeNull();
    expect(newBooking?.status).toBe(BookingStatus.ACCEPTED);
  });

  test("Should be able to book slot that overlaps with original rescheduled booking", async ({
    page,
    users,
    bookings,
  }) => {
    const user = await users.create();

    const eventType = user.eventTypes[0];

    let firstOfNextMonth = dayjs().add(1, "month").startOf("month");

    // find first available slot of next month (available monday-friday)
    // eslint-disable-next-line playwright/no-conditional-in-test
    while (firstOfNextMonth.day() < 1 || firstOfNextMonth.day() > 5) {
      firstOfNextMonth = firstOfNextMonth.add(1, "day");
    }

    // set startTime to first available slot
    const startTime = firstOfNextMonth.set("hour", 9).set("minute", 0).toDate();

    const endTime = firstOfNextMonth.set("hour", 9).set("minute", 30).toDate();

    const booking = await bookings.create(user.id, user.username, eventType.id, {}, startTime, endTime);

    await page.goto(`/reschedule/${booking.uid}`);

    await selectFirstAvailableTimeSlotNextMonth(page);

    await page.locator('[data-testid="confirm-reschedule-button"]').click();
    await expect(page).toHaveURL(/.*booking/);
  });
  test("Should load Valid Cal video url after rescheduling Opt in events", async ({
    page,
    users,
    bookings,
  }) => {
    const user = await users.create();
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const eventType = user.eventTypes.find((e) => e.slug === "opt-in")!;

    const confirmBooking = async (bookingId: number) => {
      await user.apiLogin();
      await page.goto("/bookings/upcoming");
      const elem = await page.locator(`[data-bookingid="${bookingId}"][data-testid="confirm"]`);
      await elem.click();
      await page.getByTestId("toast-success").waitFor();
      await user.logout();
    };

    await page.goto(`/${user.username}/${eventType.slug}`);
    await selectFirstAvailableTimeSlotNextMonth(page);
    await bookTimeSlot(page);
    await expect(page.locator("[data-testid=success-page]")).toBeVisible();

    const pageUrl = new URL(page.url());

    const pathSegments = pageUrl.pathname.split("/");

    const bookingUID = pathSegments[pathSegments.length - 1];

    const currentBooking = await prisma.booking.findFirst({ where: { uid: bookingUID } });
    expect(currentBooking).not.toBeUndefined();
    // eslint-disable-next-line playwright/no-conditional-in-test
    if (currentBooking) {
      await confirmBooking(currentBooking.id);

      await page.goto(`/${user.username}/${eventType.slug}?rescheduleUid=${currentBooking.uid}`);
      await selectFirstAvailableTimeSlotNextMonth(page);

      await page.locator('[data-testid="confirm-reschedule-button"]').click();
      await expect(page).toHaveURL(/.*booking/);

      const newBooking = await prisma.booking.findFirst({ where: { fromReschedule: currentBooking.uid } });
      expect(newBooking).not.toBeUndefined();
      expect(newBooking?.status).toBe(BookingStatus.PENDING);
      // eslint-disable-next-line playwright/no-conditional-in-test
      if (newBooking) {
        await confirmBooking(newBooking?.id);

        const booking = await prisma.booking.findFirst({ where: { id: newBooking.id } });
        expect(booking).not.toBeUndefined();
        expect(booking?.status).toBe(BookingStatus.ACCEPTED);

        const locationVideoCallUrl = bookingMetadataSchema.parse(booking?.metadata || {})?.videoCallUrl;
        expect(locationVideoCallUrl).not.toBeUndefined();

        // eslint-disable-next-line playwright/no-conditional-in-test
        if (booking && locationVideoCallUrl) {
          await page.goto(locationVideoCallUrl);
          await expect(page.frameLocator("iFrame").locator('text="Continue"')).toBeVisible();
        }
      }
    }
  });
});
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
});

export {};

const TwoFactorAuthAPI = {
  async setup(password: string) {
    return fetch("/api/auth/two-factor/totp/setup", {
      method: "POST",
      body: JSON.stringify({ password }),
      headers: {
        "Content-Type": "application/json",
      },
    });
  },

  async enable(code: string) {
    return fetch("/api/auth/two-factor/totp/enable", {
      method: "POST",
      body: JSON.stringify({ code }),
      headers: {
        "Content-Type": "application/json",
      },
    });
  },

  async disable(password: string, code: string, backupCode: string) {
    return fetch("/api/auth/two-factor/totp/disable", {
      method: "POST",
      body: JSON.stringify({ password, code, backupCode }),
      headers: {
        "Content-Type": "application/json",
      },
    });
  },
};

export default TwoFactorAuthAPI;

const TwoFactorAuthAPI = {
  async setup(password: string) {
    return fetch("/api/auth/two-factor/totp/setup", {
      method: "POST",
      body: JSON.stringify({ password }),
      headers: {
        "Content-Type": "application/json",
      },
    });
  },

  async enable(code: string) {
    return fetch("/api/auth/two-factor/totp/enable", {
      method: "POST",
      body: JSON.stringify({ code }),
      headers: {
        "Content-Type": "application/json",
      },
    });
  },

  async disable(password: string, code: string) {
    return fetch("/api/auth/two-factor/totp/disable", {
      method: "POST",
      body: JSON.stringify({ password, code }),
      headers: {
        "Content-Type": "application/json",
      },
    });
  },
};

export default TwoFactorAuthAPI;
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
});
import { execSync } from "child_process";

type Err = {
  stdout: string;
};

const diff = execSync(`git diff --name-only origin/main HEAD`).toString();

const files = diff
  .trim()
  .split("\n")
  .map((file) => file.trim())
  .filter(Boolean)
  .filter((file) => file.endsWith(".ts") || file.endsWith(".tsx"));

console.log("ℹ️ Changed files:");
console.log(files.map((str) => `  - ${str}`).join("\n"));

try {
  console.log("⏳ Checking type errors..");
  execSync("yarn tsc --noEmit", {});

  console.log("😻 No errors!");
} catch (_err) {
  const err = _err as Err;

  const output = err.stdout.toString() as string;

  const filesWithTypeErrors = files.filter((file) => output.includes(file));

  if (!filesWithTypeErrors.length) {
    console.log(`🎉 You haven't introduced any new type errors!`);
    process.exit(0);
  }
  console.log("❌ ❌ ❌ You seem to have touched files that have type errors ❌ ❌ ❌");
  console.log("🙏 Please inspect the following files:");
  console.log(filesWithTypeErrors.map((str) => `  - ${str}`).join("\n"));

  process.exit(1);
}
import type { Prisma } from "@prisma/client";

function isPrismaObj(obj: unknown): obj is Prisma.JsonObject {
  return typeof obj === "object" && !Array.isArray(obj);
}

export function isPrismaObjOrUndefined(obj: unknown) {
  return isPrismaObj(obj) ? obj : undefined;
}

export default isPrismaObj;
import { describe, it, expect } from "vitest";

import { buildNonce } from "./buildNonce";

describe("buildNonce", () => {
  it("should return an empty string for an empty array", () => {
    const nonce = buildNonce(new Uint8Array());

    expect(nonce).toEqual("");
    expect(atob(nonce).length).toEqual(0);
  });

  it("should return a base64 string for values from 0 to 63", () => {
    const array = Array(22)
      .fill(0)
      .map((_, i) => i);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("ABCDEFGHIJKLMNOPQRSTQQ==");

    expect(atob(nonce).length).toEqual(16);
  });

  it("should return a base64 string for values from 64 to 127", () => {
    const array = Array(22)
      .fill(0)
      .map((_, i) => i + 64);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("ABCDEFGHIJKLMNOPQRSTQQ==");

    expect(atob(nonce).length).toEqual(16);
  });

  it("should return a base64 string for values from 128 to 191", () => {
    const array = Array(22)
      .fill(0)
      .map((_, i) => i + 128);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("ABCDEFGHIJKLMNOPQRSTQQ==");

    expect(atob(nonce).length).toEqual(16);
  });

  it("should return a base64 string for values from 192 to 255", () => {
    const array = Array(22)
      .fill(0)
      .map((_, i) => i + 192);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("ABCDEFGHIJKLMNOPQRSTQQ==");

    expect(atob(nonce).length).toEqual(16);
  });

  it("should return a base64 string for values from 0 to 42", () => {
    const array = Array(22)
      .fill(0)
      .map((_, i) => 2 * i);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("ACEGIKMOQSUWYacegikmgg==");

    expect(atob(nonce).length).toEqual(16);
  });

  it("should return a base64 string for 0 values", () => {
    const array = Array(22)
      .fill(0)
      .map(() => 0);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("AAAAAAAAAAAAAAAAAAAAAA==");

    expect(atob(nonce).length).toEqual(16);
  });

  it("should return a base64 string for 0xFF values", () => {
    const array = Array(22)
      .fill(0)
      .map(() => 0xff);

    const nonce = buildNonce(new Uint8Array(array));

    expect(nonce.length).toEqual(24);
    expect(nonce).toEqual("////////////////////ww==");

    expect(atob(nonce).length).toEqual(16);
  });
});
import isPrismaObj from "./isPrismaObj";

const hasKeyInMetadata = <T extends string>(
  x: { metadata: unknown } | null,
  key: T
): x is { metadata: { [key in T]: string | boolean | number } } =>
  isPrismaObj(x?.metadata) && !!x?.metadata && key in x.metadata;

export default hasKeyInMetadata;

export type SVGComponent = React.FunctionComponent<React.SVGProps<SVGSVGElement>>;

export type TimeRange = {
  start: Date;
  end: Date;
};

export type Schedule = TimeRange[][];

/**
 * ```text
 * Ensure startTime and endTime in minutes since midnight; serialized to UTC by using the organizer timeZone, either by using the schedule timeZone or the user timeZone.
 * @see lib/availability.ts getWorkingHours(timeZone: string, availability: Availability[])
 * ```
 */
export type WorkingHours = {
  days: number[];
  startTime: number;
  endTime: number;
};

export type BookingResponse = Awaited<
  ReturnType<typeof import("@calcom/features/bookings/lib/handleNewBooking").default>
>;
/* eslint-disable @typescript-eslint/no-explicit-any */
type GetSSRResult<TProps> =
  //
  { props: TProps } | { redirect: { destination: string; permanent: boolean } } | { notFound: boolean };

type GetSSRFn<TProps> = (...args: any[]) => Promise<GetSSRResult<TProps>>;

export type inferSSRProps<TFn extends GetSSRFn<any>> = TFn extends GetSSRFn<infer TProps>
  ? NonNullable<TProps>
  : never;

export class HttpError<TCode extends number = number> extends Error {
  public readonly cause?: Error;
  public readonly statusCode: TCode;
  public readonly message: string;
  public readonly url: string | undefined;
  public readonly method: string | undefined;

  constructor(opts: { url?: string; method?: string; message?: string; statusCode: TCode; cause?: Error }) {
    super(opts.message ?? `HTTP Error ${opts.statusCode} `);

    Object.setPrototypeOf(this, HttpError.prototype);
    this.name = HttpError.prototype.constructor.name;

    this.cause = opts.cause;
    this.statusCode = opts.statusCode;
    this.url = opts.url;
    this.method = opts.method;
    this.message = opts.message ?? `HTTP Error ${opts.statusCode}`;

    if (opts.cause instanceof Error && opts.cause.stack) {
      this.stack = opts.cause.stack;
    }
  }

  public static fromRequest(request: Request, response: Response) {
    return new HttpError({
      message: response.statusText,
      url: response.url,
      method: request.method,
      statusCode: response.status,
    });
  }
}
// Base http Error
export { HttpError } from "./http-error";
import type { DefaultSeoProps, NextSeoProps } from "next-seo";

import { APP_NAME, SEO_IMG_DEFAULT, SEO_IMG_OGIMG } from "@calcom/lib/constants";

export type HeadSeoProps = {
  title: string;
  description: string;
  siteName?: string;
  name?: string;
  url?: string;
  username?: string;
  canonical?: string;
  nextSeoProps?: NextSeoProps;
};

const seoImages = {
  default: SEO_IMG_DEFAULT,
  ogImage: SEO_IMG_OGIMG,
};

export const getSeoImage = (key: keyof typeof seoImages): string => {
  return seoImages[key];
};

export const seoConfig: {
  headSeo: Required<Pick<HeadSeoProps, "siteName">>;
  defaultNextSeo: DefaultSeoProps;
} = {
  headSeo: {
    siteName: APP_NAME,
  },
  defaultNextSeo: {
    twitter: {
      handle: "@calcom",
      site: "@calcom",
      cardType: "summary_large_image",
    },
  },
} as const;
import { getOrgUsernameFromEmail } from "@calcom/features/auth/signup/utils/getOrgUsernameFromEmail";
import { getOrgFullOrigin } from "@calcom/features/ee/organizations/lib/orgDomains";
import { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import prisma from "@calcom/prisma";
import type { Team, User } from "@calcom/prisma/client";
import { RedirectType } from "@calcom/prisma/client";
import { Prisma } from "@calcom/prisma/client";
import type { MembershipRole } from "@calcom/prisma/enums";
import { teamMetadataSchema } from "@calcom/prisma/zod-utils";

const log = logger.getSubLogger({ prefix: ["orgMigration"] });

type UserMetadata = {
  migratedToOrgFrom?: {
    username: string;
    reverted: boolean;
    revertTime: string;
    lastMigrationTime: string;
  };
};

/**
 * Make sure that the migration is idempotent
 */
export async function moveUserToOrg({
  user: { id: userId, userName: userName },
  targetOrg: {
    id: targetOrgId,
    username: targetOrgUsername,
    membership: { role: targetOrgRole, accepted: targetOrgMembershipAccepted = true },
  },
  shouldMoveTeams,
}: {
  user: { id?: number; userName?: string };
  targetOrg: {
    id: number;
    username?: string;
    membership: { role: MembershipRole; accepted?: boolean };
  };
  shouldMoveTeams: boolean;
}) {
  assertUserIdOrUserName(userId, userName);
  const team = await getTeamOrThrowError(targetOrgId);

  const teamMetadata = teamMetadataSchema.parse(team?.metadata);

  if (!teamMetadata?.isOrganization) {
    throw new Error(`Team with ID:${targetOrgId} is not an Org`);
  }

  const targetOrganization = {
    ...team,
    metadata: teamMetadata,
  };
  const userToMoveToOrg = await getUniqueUserThatDoesntBelongToOrg(userName, userId, targetOrgId);
  assertUserPartOfOtherOrg(userToMoveToOrg, userName, userId, targetOrgId);

  if (!targetOrgUsername) {
    targetOrgUsername = getOrgUsernameFromEmail(
      userToMoveToOrg.email,
      targetOrganization.metadata.orgAutoAcceptEmail || ""
    );
  }

  const userWithSameUsernameInOrg = await prisma.user.findFirst({
    where: {
      username: targetOrgUsername,
      organizationId: targetOrgId,
    },
  });

  log.debug({
    userWithSameUsernameInOrg,
    targetOrgUsername,
    targetOrgId,
    userId,
  });

  if (userWithSameUsernameInOrg && userWithSameUsernameInOrg.id !== userId) {
    throw new HttpError({
      statusCode: 400,
      message: `Username ${targetOrgUsername} already exists for orgId: ${targetOrgId} for some other user`,
    });
  }

  assertUserPartOfOrgAndRemigrationAllowed(userToMoveToOrg, targetOrgId, targetOrgUsername, userId);

  const orgMetadata = teamMetadata;

  const userToMoveToOrgMetadata = (userToMoveToOrg.metadata || {}) as UserMetadata;

  const nonOrgUserName =
    (userToMoveToOrgMetadata.migratedToOrgFrom?.username as string) || userToMoveToOrg.username;
  if (!nonOrgUserName) {
    throw new HttpError({
      statusCode: 400,
      message: `User with id: ${userId} doesn't have a non-org username`,
    });
  }

  await dbMoveUserToOrg({ userToMoveToOrg, targetOrgId, targetOrgUsername, nonOrgUserName });

  let teamsToBeMovedToOrg;
  if (shouldMoveTeams) {
    teamsToBeMovedToOrg = await moveTeamsWithoutMembersToOrg({ targetOrgId, userToMoveToOrg });
  }

  await updateMembership({ targetOrgId, userToMoveToOrg, targetOrgRole, targetOrgMembershipAccepted });

  await addRedirect({
    nonOrgUserName,
    teamsToBeMovedToOrg: teamsToBeMovedToOrg || [],
    organization: targetOrganization,
    targetOrgUsername,
  });

  await setOrgSlugIfNotSet(targetOrganization, orgMetadata, targetOrgId);

  log.debug(`orgId:${targetOrgId} attached to userId:${userId}`);
}

/**
 * Make sure that the migration is idempotent
 */
export async function removeUserFromOrg({ targetOrgId, userId }: { targetOrgId: number; userId: number }) {
  const userToRemoveFromOrg = await prisma.user.findUnique({
    where: {
      id: userId,
    },
  });

  if (!userToRemoveFromOrg) {
    throw new HttpError({
      statusCode: 400,
      message: `User with id: ${userId} not found`,
    });
  }

  if (userToRemoveFromOrg.organizationId !== targetOrgId) {
    throw new HttpError({
      statusCode: 400,
      message: `User with id: ${userId} is not part of orgId: ${targetOrgId}`,
    });
  }

  const userToRemoveFromOrgMetadata = (userToRemoveFromOrg.metadata || {}) as {
    migratedToOrgFrom?: {
      username: string;
      reverted: boolean;
      revertTime: string;
      lastMigrationTime: string;
    };
  };

  if (!userToRemoveFromOrgMetadata.migratedToOrgFrom) {
    throw new HttpError({
      statusCode: 400,
      message: `User with id: ${userId} wasn't migrated. So, there is nothing to revert`,
    });
  }

  const nonOrgUserName = userToRemoveFromOrgMetadata.migratedToOrgFrom.username as string;
  if (!nonOrgUserName) {
    throw new HttpError({
      statusCode: 500,
      message: `User with id: ${userId} doesn't have a non-org username`,
    });
  }

  const teamsToBeRemovedFromOrg = await removeTeamsWithoutItsMemberFromOrg({ userToRemoveFromOrg });
  await dbRemoveUserFromOrg({ userToRemoveFromOrg, nonOrgUserName });

  await removeUserAlongWithItsTeamsRedirects({ nonOrgUserName, teamsToBeRemovedFromOrg });
  await removeMembership({ targetOrgId, userToRemoveFromOrg });

  log.debug(`orgId:${targetOrgId} attached to userId:${userId}`);
}

/**
 * Make sure that the migration is idempotent
 */
export async function moveTeamToOrg({
  targetOrg,
  teamId,
  moveMembers,
}: {
  targetOrg: { id: number; teamSlug: string };
  teamId: number;
  moveMembers?: boolean;
}) {
  const possibleOrg = await getTeamOrThrowError(targetOrg.id);
  const { oldTeamSlug, updatedTeam } = await dbMoveTeamToOrg({ teamId, targetOrg });

  const teamMetadata = teamMetadataSchema.parse(possibleOrg?.metadata);

  if (!teamMetadata?.isOrganization) {
    throw new Error(`${targetOrg.id} is not an Org`);
  }

  const targetOrganization = possibleOrg;
  const orgMetadata = teamMetadata;
  await addTeamRedirect({
    oldTeamSlug,
    teamSlug: updatedTeam.slug,
    orgSlug: targetOrganization.slug || orgMetadata.requestedSlug || null,
  });
  await setOrgSlugIfNotSet({ slug: targetOrganization.slug }, orgMetadata, targetOrg.id);
  if (moveMembers) {
    for (const membership of updatedTeam.members) {
      await moveUserToOrg({
        user: {
          id: membership.userId,
        },
        targetOrg: {
          id: targetOrg.id,
          membership: {
            role: membership.role,
            accepted: membership.accepted,
          },
        },
        shouldMoveTeams: false,
      });
    }
  }
  log.debug(`Successfully moved team ${teamId} to org ${targetOrg.id}`);
}

/**
 * Make sure that the migration is idempotent
 */
export async function removeTeamFromOrg({ targetOrgId, teamId }: { targetOrgId: number; teamId: number }) {
  const removedTeam = await dbRemoveTeamFromOrg({ teamId });
  await removeTeamRedirect(removedTeam.slug);
  for (const membership of removedTeam.members) {
    await removeUserFromOrg({
      userId: membership.userId,
      targetOrgId,
    });
  }
  log.debug(`Successfully removed team ${teamId} from org ${targetOrgId}`);
}

async function dbMoveTeamToOrg({
  teamId,
  targetOrg,
}: {
  teamId: number;
  targetOrg: {
    id: number;
    teamSlug: string;
  };
}) {
  const team = await prisma.team.findUnique({
    where: {
      id: teamId,
    },
    include: {
      members: true,
    },
  });

  if (!team) {
    throw new HttpError({
      statusCode: 400,
      message: `Team with id: ${teamId} not found`,
    });
  }

  const teamMetadata = teamMetadataSchema.parse(team?.metadata);
  const oldTeamSlug = teamMetadata?.migratedToOrgFrom?.teamSlug || team.slug;

  const updatedTeam = await prisma.team.update({
    where: {
      id: teamId,
    },
    data: {
      slug: targetOrg.teamSlug,
      parentId: targetOrg.id,
      metadata: {
        ...teamMetadata,
        migratedToOrgFrom: {
          teamSlug: team.slug,
          lastMigrationTime: new Date().toISOString(),
        },
      },
    },
    include: {
      members: true,
    },
  });

  return { oldTeamSlug, updatedTeam };
}

async function getUniqueUserThatDoesntBelongToOrg(
  userName: string | undefined,
  userId: number | undefined,
  excludeOrgId: number
) {
  log.debug("getUniqueUserThatDoesntBelongToOrg", { userName, userId, excludeOrgId });
  if (userName) {
    const matchingUsers = await prisma.user.findMany({
      where: {
        username: userName,
      },
    });

    const foundUsers = matchingUsers.filter(
      (user) => user.organizationId === excludeOrgId || user.organizationId === null
    );

    if (foundUsers.length > 1) {
      throw new Error(`More than one user found with username: ${userName}`);
    }
    return foundUsers[0];
  } else {
    return await prisma.user.findUnique({
      where: {
        id: userId,
      },
    });
  }
}

async function setOrgSlugIfNotSet(
  targetOrganization: {
    slug: string | null;
  },
  orgMetadata: {
    requestedSlug?: string | undefined;
  },
  targetOrgId: number
) {
  if (targetOrganization.slug) {
    return;
  }
  if (!orgMetadata.requestedSlug) {
    throw new HttpError({
      statusCode: 400,
      message: `Org with id: ${targetOrgId} doesn't have a slug. Tried using requestedSlug but that's also not present. So, all migration done but failed to set the Organization slug. Please set it manually`,
    });
  }
  await setOrgSlug({
    targetOrgId,
    targetSlug: orgMetadata.requestedSlug,
  });
}

function assertUserPartOfOrgAndRemigrationAllowed(
  userToMoveToOrg: {
    organizationId: User["organizationId"];
  },
  targetOrgId: number,
  targetOrgUsername: string,
  userId: number | undefined
) {
  if (userToMoveToOrg.organizationId) {
    if (userToMoveToOrg.organizationId !== targetOrgId) {
      throw new HttpError({
        statusCode: 400,
        message: `User ${targetOrgUsername} already exists for different Org with orgId: ${targetOrgId}`,
      });
    } else {
      log.debug(`Redoing migration for userId: ${userId} to orgId:${targetOrgId}`);
    }
  }
}

async function getTeamOrThrowError(targetOrgId: number) {
  const team = await prisma.team.findUnique({
    where: {
      id: targetOrgId,
    },
  });

  if (!team) {
    throw new HttpError({
      statusCode: 400,
      message: `Org with id: ${targetOrgId} not found`,
    });
  }
  return team;
}

function assertUserPartOfOtherOrg(
  userToMoveToOrg: {
    organizationId: User["organizationId"];
  } | null,
  userName: string | undefined,
  userId: number | undefined,
  targetOrgId: number
): asserts userToMoveToOrg {
  if (!userToMoveToOrg) {
    throw new HttpError({
      message: `User ${userName ? userName : `ID:${userId}`} is part of an org already`,
      statusCode: 400,
    });
  }

  if (userToMoveToOrg.organizationId && userToMoveToOrg.organizationId !== targetOrgId) {
    throw new HttpError({
      message: `User is already a part of different organization ID: ${userToMoveToOrg.organizationId}`,
      statusCode: 400,
    });
  }
}

function assertUserIdOrUserName(userId: number | undefined, userName: string | undefined) {
  if (!userId && !userName) {
    throw new HttpError({ statusCode: 400, message: "userId or userName is required" });
  }
  if (userId && userName) {
    throw new HttpError({ statusCode: 400, message: "Provide either userId or userName" });
  }
}

async function addRedirect({
  nonOrgUserName,
  organization,
  targetOrgUsername,
  teamsToBeMovedToOrg,
}: {
  nonOrgUserName: string | null;
  organization: Team;
  targetOrgUsername: string;
  teamsToBeMovedToOrg: { slug: string | null }[];
}) {
  if (!nonOrgUserName) {
    return;
  }
  const orgSlug = organization.slug || (organization.metadata as { requestedSlug?: string })?.requestedSlug;
  if (!orgSlug) {
    log.debug("No slug for org. Not adding the redirect", safeStringify({ organization, nonOrgUserName }));

    return;
  }
  // If the user had a username earlier, we need to redirect it to the new org username
  const orgUrlPrefix = getOrgFullOrigin(orgSlug);
  log.debug({
    orgUrlPrefix,
    nonOrgUserName,
    targetOrgUsername,
  });

  await prisma.tempOrgRedirect.upsert({
    where: {
      from_type_fromOrgId: {
        type: RedirectType.User,
        from: nonOrgUserName,
        fromOrgId: 0,
      },
    },
    create: {
      type: RedirectType.User,
      from: nonOrgUserName,
      fromOrgId: 0,
      toUrl: `${orgUrlPrefix}/${targetOrgUsername}`,
    },
    update: {
      toUrl: `${orgUrlPrefix}/${targetOrgUsername}`,
    },
  });

  for (const [, team] of Object.entries(teamsToBeMovedToOrg)) {
    if (!team.slug) {
      log.debug("No slug for team. Not adding the redirect", safeStringify({ team }));
      continue;
    }
    await prisma.tempOrgRedirect.upsert({
      where: {
        from_type_fromOrgId: {
          type: RedirectType.Team,
          from: team.slug,
          fromOrgId: 0,
        },
      },
      create: {
        type: RedirectType.Team,
        from: team.slug,
        fromOrgId: 0,
        toUrl: `${orgUrlPrefix}/team/${team.slug}`,
      },
      update: {
        toUrl: `${orgUrlPrefix}/team/${team.slug}`,
      },
    });
  }
}

async function addTeamRedirect({
  oldTeamSlug,
  teamSlug,
  orgSlug,
}: {
  oldTeamSlug: string | null;
  teamSlug: string | null;
  orgSlug: string | null;
}) {
  if (!oldTeamSlug) {
    throw new HttpError({
      statusCode: 400,
      message: "No oldSlug for team. Not adding the redirect",
    });
  }
  if (!teamSlug) {
    throw new HttpError({
      statusCode: 400,
      message: "No slug for team. Not adding the redirect",
    });
  }
  if (!orgSlug) {
    log.warn(`No slug for org. Not adding the redirect`);

    return;
  }
  const orgUrlPrefix = getOrgFullOrigin(orgSlug);

  await prisma.tempOrgRedirect.upsert({
    where: {
      from_type_fromOrgId: {
        type: RedirectType.Team,
        from: oldTeamSlug,
        fromOrgId: 0,
      },
    },
    create: {
      type: RedirectType.Team,
      from: oldTeamSlug,
      fromOrgId: 0,
      toUrl: `${orgUrlPrefix}/${teamSlug}`,
    },
    update: {
      toUrl: `${orgUrlPrefix}/${teamSlug}`,
    },
  });
}

async function updateMembership({
  targetOrgId,
  userToMoveToOrg,
  targetOrgRole,
  targetOrgMembershipAccepted,
}: {
  targetOrgId: number;
  userToMoveToOrg: User;
  targetOrgRole: MembershipRole;
  targetOrgMembershipAccepted: boolean;
}) {
  log.debug("updateMembership", { targetOrgId, userToMoveToOrg, targetOrgRole, targetOrgMembershipAccepted });
  await prisma.membership.upsert({
    where: {
      userId_teamId: {
        teamId: targetOrgId,
        userId: userToMoveToOrg.id,
      },
    },
    create: {
      teamId: targetOrgId,
      userId: userToMoveToOrg.id,
      role: targetOrgRole,
      accepted: targetOrgMembershipAccepted,
    },
    update: {
      role: targetOrgRole,
      accepted: targetOrgMembershipAccepted,
    },
  });
}

async function dbMoveUserToOrg({
  userToMoveToOrg,
  targetOrgId,
  targetOrgUsername,
  nonOrgUserName,
}: {
  userToMoveToOrg: User;
  targetOrgId: number;
  targetOrgUsername: string;
  nonOrgUserName: string | null;
}) {
  await prisma.user.update({
    where: {
      id: userToMoveToOrg.id,
    },
    data: {
      organizationId: targetOrgId,
      username: targetOrgUsername,
      metadata: {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        ...(userToMoveToOrg.metadata || {}),
        migratedToOrgFrom: {
          username: nonOrgUserName,
          lastMigrationTime: new Date().toISOString(),
        },
      },
    },
  });
}

async function moveTeamsWithoutMembersToOrg({
  targetOrgId,
  userToMoveToOrg,
}: {
  targetOrgId: number;
  userToMoveToOrg: User;
}) {
  const memberships = await prisma.membership.findMany({
    where: {
      userId: userToMoveToOrg.id,
    },
  });

  const membershipTeamIds = memberships.map((m) => m.teamId);
  const teams = await prisma.team.findMany({
    where: {
      id: {
        in: membershipTeamIds,
      },
    },
    select: {
      id: true,
      slug: true,
      metadata: true,
    },
  });

  const teamsToBeMovedToOrg = teams
    .map((team) => {
      return {
        ...team,
        metadata: teamMetadataSchema.parse(team.metadata),
      };
    })
    // Remove Orgs from the list
    .filter((team) => !team.metadata?.isOrganization);

  const teamIdsToBeMovedToOrg = teamsToBeMovedToOrg.map((t) => t.id);

  if (memberships.length) {
    // Add the user's teams to the org
    await prisma.team.updateMany({
      where: {
        id: {
          in: teamIdsToBeMovedToOrg,
        },
      },
      data: {
        parentId: targetOrgId,
      },
    });
  }
  return teamsToBeMovedToOrg;
}

/**
 * Make sure you pass it an organization ID only and not a team ID.
 */
async function setOrgSlug({ targetOrgId, targetSlug }: { targetOrgId: number; targetSlug: string }) {
  await prisma.team.update({
    where: {
      id: targetOrgId,
    },
    data: {
      slug: targetSlug,
    },
  });
}

async function removeTeamRedirect(teamSlug: string | null) {
  if (!teamSlug) {
    throw new HttpError({
      statusCode: 400,
      message: "No slug for team. Not removing the redirect",
    });

    return;
  }

  await prisma.tempOrgRedirect.deleteMany({
    where: {
      type: RedirectType.Team,
      from: teamSlug,
      fromOrgId: 0,
    },
  });
}

async function removeUserAlongWithItsTeamsRedirects({
  nonOrgUserName,
  teamsToBeRemovedFromOrg,
}: {
  nonOrgUserName: string | null;
  teamsToBeRemovedFromOrg: { slug: string | null }[];
}) {
  if (!nonOrgUserName) {
    return;
  }

  await prisma.tempOrgRedirect.deleteMany({
    // This where clause is unique, so we will get only one result but using deleteMany because it doesn't throw an error if there are no rows to delete
    where: {
      type: RedirectType.User,
      from: nonOrgUserName,
      fromOrgId: 0,
    },
  });

  for (const [, team] of Object.entries(teamsToBeRemovedFromOrg)) {
    if (!team.slug) {
      log.debug("No slug for team. Not removing the redirect", safeStringify({ team }));
      continue;
    }
    await prisma.tempOrgRedirect.deleteMany({
      where: {
        type: RedirectType.Team,
        from: team.slug,
        fromOrgId: 0,
      },
    });
  }
}

async function dbRemoveTeamFromOrg({ teamId }: { teamId: number }) {
  const team = await prisma.team.findUnique({
    where: {
      id: teamId,
    },
  });

  if (!team) {
    throw new HttpError({
      statusCode: 400,
      message: `Team with id: ${teamId} not found`,
    });
  }

  const teamMetadata = teamMetadataSchema.parse(team?.metadata);
  try {
    return await prisma.team.update({
      where: {
        id: teamId,
      },
      data: {
        parentId: null,
        slug: teamMetadata?.migratedToOrgFrom?.teamSlug || team.slug,
        metadata: {
          ...teamMetadata,
          migratedToOrgFrom: {
            reverted: true,
            lastRevertTime: new Date().toISOString(),
          },
        },
      },
      include: {
        members: true,
      },
    });
  } catch (e) {
    if (e instanceof Prisma.PrismaClientKnownRequestError) {
      if (e.code === "P2002") {
        throw new HttpError({
          message: `Looks like the team's name is already taken by some other team outside the org or an org itself. Please change this team's name or the other team/org's name. If you rename the team that you are trying to remove from the org, you will have to manually remove the redirect from the database for that team as the slug would have changed.`,
          statusCode: 400,
        });
      }
    }
    throw e;
  }
}

async function removeTeamsWithoutItsMemberFromOrg({ userToRemoveFromOrg }: { userToRemoveFromOrg: User }) {
  const memberships = await prisma.membership.findMany({
    where: {
      userId: userToRemoveFromOrg.id,
    },
  });

  const membershipTeamIds = memberships.map((m) => m.teamId);
  const teams = await prisma.team.findMany({
    where: {
      id: {
        in: membershipTeamIds,
      },
    },
    select: {
      id: true,
      slug: true,
      metadata: true,
    },
  });

  const teamsToBeRemovedFromOrg = teams
    .map((team) => {
      return {
        ...team,
        metadata: teamMetadataSchema.parse(team.metadata),
      };
    })
    // Remove Orgs from the list
    .filter((team) => !team.metadata?.isOrganization);

  const teamIdsToBeRemovedFromOrg = teamsToBeRemovedFromOrg.map((t) => t.id);

  if (memberships.length) {
    // Remove the user's teams from the org
    await prisma.team.updateMany({
      where: {
        id: {
          in: teamIdsToBeRemovedFromOrg,
        },
      },
      data: {
        parentId: null,
      },
    });
  }
  return teamsToBeRemovedFromOrg;
}

async function dbRemoveUserFromOrg({
  userToRemoveFromOrg,
  nonOrgUserName,
}: {
  userToRemoveFromOrg: User;
  nonOrgUserName: string;
}) {
  await prisma.user.update({
    where: {
      id: userToRemoveFromOrg.id,
    },
    data: {
      organizationId: null,
      username: nonOrgUserName,
      metadata: {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        ...(userToRemoveFromOrg.metadata || {}),
        migratedToOrgFrom: {
          username: null,
          reverted: true,
          revertTime: new Date().toISOString(),
        },
      },
    },
  });
}

async function removeMembership({
  targetOrgId,
  userToRemoveFromOrg,
}: {
  targetOrgId: number;
  userToRemoveFromOrg: User;
}) {
  await prisma.membership.deleteMany({
    where: {
      teamId: targetOrgId,
      userId: userToRemoveFromOrg.id,
    },
  });
}
export function ensureArray<T>(val: unknown): T[] {
  if (Array.isArray(val)) {
    return val;
  }
  if (typeof val === "undefined") {
    return [];
  }
  return [val] as T[];
}

const MAX_IMAGE_SIZE = 512;

export type Area = {
  width: number;
  height: number;
  x: number;
  y: number;
};

const createImage = (url: string) =>
  new Promise<HTMLImageElement>((resolve, reject) => {
    const image = new Image();
    image.addEventListener("load", () => resolve(image));
    image.addEventListener("error", (error) => reject(error));
    image.setAttribute("crossOrigin", "anonymous"); // needed to avoid cross-origin issues on CodeSandbox
    image.src = url;
  });

export async function getCroppedImg(imageSrc: string, pixelCrop: Area): Promise<string> {
  const image = await createImage(imageSrc);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  if (!ctx) throw new Error("Context is null, this should never happen.");

  const maxSize = Math.max(image.naturalWidth, image.naturalHeight);
  const resizeRatio = MAX_IMAGE_SIZE / maxSize < 1 ? Math.max(MAX_IMAGE_SIZE / maxSize, 0.75) : 1;
  // huh, what? - Having this turned off actually improves image quality as otherwise anti-aliasing is applied
  // this reduces the quality of the image overall because it anti-aliases the existing, copied image; blur results
  ctx.imageSmoothingEnabled = false;
  // pixelCrop is always 1:1 - width = height
  canvas.width = canvas.height = Math.min(maxSize * resizeRatio, pixelCrop.width);

  ctx.drawImage(
    image,
    pixelCrop.x,
    pixelCrop.y,
    pixelCrop.width,
    pixelCrop.height,
    0,
    0,
    canvas.width,
    canvas.height
  );

  // on very low ratios, the quality of the resize becomes awful. For this reason the resizeRatio is limited to 0.75
  if (resizeRatio <= 0.75) {
    // With a smaller image, thus improved ratio. Keep doing this until the resizeRatio > 0.75.
    return getCroppedImg(canvas.toDataURL("image/png"), {
      width: canvas.width,
      height: canvas.height,
      x: 0,
      y: 0,
    });
  }

  return canvas.toDataURL("image/png");
}
import type { IncomingMessage, OutgoingMessage } from "http";
import type { NextRequest, NextResponse } from "next/server";
import { z } from "zod";

import { IS_PRODUCTION } from "@calcom/lib/constants";
import { WEBAPP_URL } from "@calcom/lib/constants";

import { buildNonce } from "./buildNonce";

function getCspPolicy(nonce: string) {
  //TODO: Do we need to explicitly define it in turbo.json
  const CSP_POLICY = process.env.CSP_POLICY;

  // Note: "non-strict" policy only allows inline styles otherwise it's the same as "strict"
  // We can remove 'unsafe-inline' from style-src when we add nonces to all style tags
  // Maybe see how @next-safe/middleware does it if it's supported.
  const useNonStrictPolicy = CSP_POLICY === "non-strict";

  // We add WEBAPP_URL to img-src because of booking pages, which end up loading images from app.cal.com on cal.com
  // FIXME: Write a layer to extract out EventType Analytics tracking endpoints and add them to img-src or connect-src as needed. e.g. fathom, Google Analytics and others
  return `
	  default-src 'self' ${IS_PRODUCTION ? "" : "data:"};
	  script-src ${
      IS_PRODUCTION
        ? // 'self' 'unsafe-inline' https: added for Browsers not supporting strict-dynamic not supporting strict-dynamic
          `'nonce-${nonce}' 'strict-dynamic' 'self' 'unsafe-inline' https:`
        : // Note: We could use 'strict-dynamic' with 'nonce-..' instead of unsafe-inline but there are some streaming related scripts that get blocked(because they don't have nonce on them). It causes a really frustrating full page error model by Next.js to show up sometimes
          "'unsafe-inline' 'unsafe-eval' https: http:"
    };
    object-src 'none';
    base-uri 'none';
	  child-src app.cal.com;
	  style-src 'self' ${
      IS_PRODUCTION ? (useNonStrictPolicy ? "'unsafe-inline'" : "") : "'unsafe-inline'"
    } app.cal.com;
	  font-src 'self';
	  img-src 'self' ${WEBAPP_URL} https://img.youtube.com https://eu.ui-avatars.com/api/ data:;
    connect-src 'self'
	`;
}

// Taken from @next-safe/middleware
const isPagePathRequest = (url: URL) => {
  const isNonPagePathPrefix = /^\/(?:_next|api)\//;
  const isFile = /\..*$/;
  const { pathname } = url;
  return !isNonPagePathPrefix.test(pathname) && !isFile.test(pathname);
};

export function csp(req: IncomingMessage | NextRequest | null, res: OutgoingMessage | NextResponse | null) {
  if (!req) {
    return { nonce: undefined };
  }
  const existingNonce = "cache" in req ? req.headers.get("x-nonce") : req.headers["x-nonce"];

  if (existingNonce) {
    const existingNoneParsed = z.string().safeParse(existingNonce);

    return { nonce: existingNoneParsed.success ? existingNoneParsed.data : "" };
  }
  if (!req.url) {
    return { nonce: undefined };
  }
  const CSP_POLICY = process.env.CSP_POLICY;
  const cspEnabledForInstance = CSP_POLICY;
  const nonce = buildNonce(crypto.getRandomValues(new Uint8Array(22)));

  const parsedUrl = new URL(req.url, "http://base_url");
  const cspEnabledForPage = cspEnabledForInstance && isPagePathRequest(parsedUrl);
  if (!cspEnabledForPage) {
    return {
      nonce: undefined,
    };
  }
  // Set x-nonce request header to be used by `getServerSideProps` or similar fns and `Document.getInitialProps` to read the nonce from
  // It is generated for all page requests but only used by pages that need CSP

  if ("cache" in req) {
    req.headers.set("x-nonce", nonce);
  } else {
    req.headers["x-nonce"] = nonce;
  }

  if (res) {
    const enforced =
      "cache" in req ? req.headers.get("x-csp-enforce") === "true" : req.headers["x-csp-enforce"] === "true";

    const name = enforced ? "Content-Security-Policy" : "Content-Security-Policy-Report-Only";

    const value = getCspPolicy(nonce)
      .replace(/\s{2,}/g, " ")
      .trim();

    if ("body" in res) {
      res.headers.set(name, value);
    } else {
      res.setHeader(name, value);
    }
  }

  return { nonce };
}
import { trpc } from "@calcom/trpc/react";

export function useMeQuery() {
  const meQuery = trpc.viewer.me.useQuery(undefined, {
    retry(failureCount) {
      return failureCount > 3;
    },
  });

  return meQuery;
}

export default useMeQuery;
import React from "react";

const isInteractionObserverSupported = typeof window !== "undefined" && "IntersectionObserver" in window;

export const useInViewObserver = (onInViewCallback: () => void) => {
  const [node, setRef] = React.useState<HTMLElement | null>(null);

  const onInViewCallbackRef = React.useRef(onInViewCallback);
  onInViewCallbackRef.current = onInViewCallback;

  React.useEffect(() => {
    if (!isInteractionObserverSupported) {
      // Skip interaction check if not supported in browser
      return;
    }

    let observer: IntersectionObserver;

    if (node && node.parentElement) {
      observer = new IntersectionObserver(
        ([entry]) => {
          if (entry.isIntersecting) {
            onInViewCallbackRef.current();
          }
        },
        {
          root: document.body,
        }
      );
      observer.observe(node);
    }

    return () => {
      if (observer) {
        observer.disconnect();
      }
    };
  }, [node]);

  return {
    ref: setRef,
  };
};
import useMeQuery from "./useMeQuery";

export const useCurrentUserId = () => {
  const query = useMeQuery();
  const user = query.data;
  return user?.id;
};

export default useCurrentUserId;
import { usePathname } from "next/navigation";

import { useCompatSearchParams } from "@calcom/lib/hooks/useCompatSearchParams";

export default function useIsBookingPage(): boolean {
  const pathname = usePathname();
  const isBookingPage = ["/booking/", "/cancel", "/reschedule"].some((route) => pathname?.startsWith(route));

  const searchParams = useCompatSearchParams();
  const userParam = Boolean(searchParams?.get("user"));
  const teamParam = Boolean(searchParams?.get("team"));

  return isBookingPage || userParam || teamParam;
}
// lets refactor and move this into packages/lib/hooks/
import { useState, useEffect } from "react";

const useMediaQuery = (query: string) => {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);

    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    window.addEventListener("resize", listener);

    return () => window.removeEventListener("resize", listener);
  }, [matches, query]);

  return matches;
};

export default useMediaQuery;
import { usePathname, useRouter } from "next/navigation";
import { useCallback } from "react";

import { useCompatSearchParams } from "@calcom/lib/hooks/useCompatSearchParams";

export default function useRouterQuery<T extends string>(name: T) {
  const searchParams = useCompatSearchParams();
  const pathname = usePathname();
  const router = useRouter();

  const setQuery = useCallback(
    (newValue: string | number | null | undefined) => {
      const _searchParams = new URLSearchParams(searchParams ?? undefined);
      _searchParams.set(name, newValue as string);
      router.replace(`${pathname}?${_searchParams.toString()}`);
    },
    [name, pathname, router, searchParams]
  );

  return { [name]: searchParams?.get(name), setQuery } as {
    [K in T]: string | undefined;
  } & { setQuery: typeof setQuery };
}
import { useEffect, useState } from "react";

type ReadAsMethod = "readAsText" | "readAsDataURL" | "readAsArrayBuffer" | "readAsBinaryString";

type UseFileReaderProps = {
  method: ReadAsMethod;
  onLoad?: (result: unknown) => void;
};

export const useFileReader = (options: UseFileReaderProps) => {
  const { method = "readAsText", onLoad } = options;
  const [file, setFile] = useState<File | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<DOMException | null>(null);
  const [result, setResult] = useState<string | ArrayBuffer | null>(null);

  useEffect(() => {
    if (!file && result) {
      setResult(null);
    }
  }, [file, result]);

  useEffect(() => {
    if (!file) {
      return;
    }

    const reader = new FileReader();
    reader.onloadstart = () => setLoading(true);
    reader.onloadend = () => setLoading(false);
    reader.onerror = () => setError(reader.error);

    reader.onload = (e: ProgressEvent<FileReader>) => {
      setResult(e.target?.result ?? null);
      if (onLoad) {
        onLoad(e.target?.result ?? null);
      }
    };
    reader[method](file);
  }, [file, method, onLoad]);

  return [{ result, error, file, loading }, setFile] as const;
};
import { getBookingFieldsWithSystemFields } from "@calcom/features/bookings/lib/getBookingFields";
import { bookingResponsesDbSchema } from "@calcom/features/bookings/lib/getBookingResponsesSchema";
import prisma from "@calcom/prisma";
import type { Prisma } from "@calcom/prisma/client";
import { BookingStatus } from "@calcom/prisma/enums";
import { EventTypeMetaDataSchema } from "@calcom/prisma/zod-utils";

export const getEventTypesFromDB = async (id: number) => {
  const userSelect = {
    id: true,
    name: true,
    username: true,
    hideBranding: true,
    theme: true,
    brandColor: true,
    darkBrandColor: true,
    email: true,
    timeZone: true,
  };
  const eventType = await prisma.eventType.findUnique({
    where: {
      id,
    },
    select: {
      id: true,
      title: true,
      description: true,
      length: true,
      eventName: true,
      recurringEvent: true,
      requiresConfirmation: true,
      userId: true,
      successRedirectUrl: true,
      customInputs: true,
      locations: true,
      price: true,
      currency: true,
      bookingFields: true,
      disableGuests: true,
      timeZone: true,
      owner: {
        select: userSelect,
      },
      users: {
        select: userSelect,
      },
      hosts: {
        select: {
          user: {
            select: userSelect,
          },
        },
      },
      team: {
        select: {
          slug: true,
          name: true,
          hideBranding: true,
        },
      },
      workflows: {
        select: {
          workflow: {
            select: {
              id: true,
              steps: true,
            },
          },
        },
      },
      metadata: true,
      seatsPerTimeSlot: true,
      seatsShowAttendees: true,
      seatsShowAvailabilityCount: true,
      periodStartDate: true,
      periodEndDate: true,
    },
  });

  if (!eventType) {
    return eventType;
  }

  const metadata = EventTypeMetaDataSchema.parse(eventType.metadata);

  return {
    isDynamic: false,
    ...eventType,
    bookingFields: getBookingFieldsWithSystemFields(eventType),
    metadata,
  };
};

export const handleSeatsEventTypeOnBooking = async (
  eventType: {
    seatsPerTimeSlot?: number | null;
    seatsShowAttendees: boolean | null;
    seatsShowAvailabilityCount: boolean | null;
    [x: string | number | symbol]: unknown;
  },
  bookingInfo: Partial<
    Prisma.BookingGetPayload<{
      include: {
        attendees: { select: { name: true; email: true } };
        seatsReferences: { select: { referenceUid: true } };
        user: {
          select: {
            id: true;
            name: true;
            email: true;
            username: true;
            timeZone: true;
          };
        };
      };
    }>
  >,
  seatReferenceUid?: string,
  isHost?: boolean
) => {
  bookingInfo["responses"] = {};
  type seatAttendee = {
    attendee: {
      email: string;
      name: string;
    };
    id: number;
    data: Prisma.JsonValue;
    bookingId: number;
    attendeeId: number;
    referenceUid: string;
  } | null;
  let seatAttendee: seatAttendee = null;
  if (seatReferenceUid) {
    seatAttendee = await prisma.bookingSeat.findFirst({
      where: {
        referenceUid: seatReferenceUid,
      },
      include: {
        attendee: {
          select: {
            name: true,
            email: true,
          },
        },
      },
    });
  }
  if (seatAttendee) {
    const seatAttendeeData = seatAttendee.data as unknown as {
      description?: string;
      responses: Prisma.JsonValue;
    };
    bookingInfo["description"] = seatAttendeeData.description ?? null;
    bookingInfo["responses"] = bookingResponsesDbSchema.parse(seatAttendeeData.responses ?? {});
  }

  if (!eventType.seatsShowAttendees && !isHost) {
    if (seatAttendee) {
      const attendee = bookingInfo?.attendees?.find((a) => {
        return a.email === seatAttendee?.attendee?.email;
      });
      bookingInfo["attendees"] = attendee ? [attendee] : [];
    } else {
      bookingInfo["attendees"] = [];
    }
  }

  // // @TODO: If handling teams, we need to do more check ups for this.
  // if (bookingInfo?.user?.id === userId) {
  //   return;
  // }
  return bookingInfo;
};

export async function getRecurringBookings(recurringEventId: string | null) {
  if (!recurringEventId) return null;
  const recurringBookings = await prisma.booking.findMany({
    where: {
      recurringEventId,
      status: BookingStatus.ACCEPTED,
    },
    select: {
      startTime: true,
    },
  });
  return recurringBookings.map((obj) => obj.startTime.toString());
}
// handles logic related to user clock display using 24h display / timeZone options.
import dayjs from "@calcom/dayjs";
import {
  getIs24hClockFromLocalStorage,
  isBrowserLocale24h,
  setIs24hClockInLocalStorage,
} from "@calcom/lib/timeFormat";
import { localStorage } from "@calcom/lib/webstorage";

interface TimeOptions {
  is24hClock: boolean;
  inviteeTimeZone: string;
}

const timeOptions: TimeOptions = {
  is24hClock: false,
  inviteeTimeZone: "",
};

const isInitialized = false;

const initClock = () => {
  if (isInitialized) {
    return;
  }
  // This only sets browser locale if there's no preference on localStorage.
  if (getIs24hClockFromLocalStorage() === null) set24hClock(isBrowserLocale24h());
  timeOptions.is24hClock = !!getIs24hClockFromLocalStorage();
  timeOptions.inviteeTimeZone =
    localStorage.getItem("timeOption.preferredTimeZone") || dayjs.tz.guess() || "Europe/London";
};

const is24h = (is24hClock?: boolean) => {
  initClock();
  if (typeof is24hClock !== "undefined") set24hClock(is24hClock);
  return timeOptions.is24hClock;
};

const set24hClock = (is24hClock: boolean) => {
  setIs24hClockInLocalStorage(is24hClock);
  timeOptions.is24hClock = is24hClock;
};

function setTimeZone(selectedTimeZone: string) {
  localStorage.setItem("timeOption.preferredTimeZone", selectedTimeZone);
  timeOptions.inviteeTimeZone = selectedTimeZone;
}

const timeZone = (selectedTimeZone?: string) => {
  initClock();
  if (selectedTimeZone) setTimeZone(selectedTimeZone);
  return timeOptions.inviteeTimeZone;
};

export { is24h, timeZone };
// TODO: Remove this file once every `classNames` is imported from `@calcom/lib`
export { default } from "@calcom/lib/classNames";

const BASE64_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

/*
The buildNonce array allows a randomly generated 22-unsigned-byte array
and returns a 24-ASCII character string that mimics a base64-string.
*/

export const buildNonce = (uint8array: Uint8Array): string => {
  // the random uint8array should contain 22 bytes
  // 22 bytes mimic the base64-encoded 16 bytes
  // base64 encodes 6 bits (log2(64)) with 8 bits (64 allowed characters)
  // thus ceil(16*8/6) gives us 22 bytes
  if (uint8array.length != 22) {
    return "";
  }

  // for each random byte, we take:
  // a) only the last 6 bits (so we map them to the base64 alphabet)
  // b) for the last byte, we are interested in two bits
  // explaination:
  // 16*8 bits = 128 bits of information (order: left->right)
  // 22*6 bits = 132 bits (order: left->right)
  // thus the last byte has 4 redundant (least-significant, right-most) bits
  // it leaves the last byte with 2 bits of information before the redundant bits
  // so the bitmask is 0x110000 (2 bits of information, 4 redundant bits)
  const bytes = uint8array.map((value, i) => {
    if (i < 20) {
      return value & 0b111111;
    }

    return value & 0b110000;
  });

  const nonceCharacters: string[] = [];

  bytes.forEach((value) => {
    nonceCharacters.push(BASE64_ALPHABET.charAt(value));
  });

  // base64-encoded strings can be padded with 1 or 2 `=`
  // since 22 % 4 = 2, we pad with two `=`
  nonceCharacters.push("==");

  // the end result has 22 information and 2 padding ASCII characters = 24 ASCII characters
  return nonceCharacters.join("");
};
import type { ParsedUrlQuery } from "querystring";
import { stringify } from "querystring";

import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import type { RedirectType } from "@calcom/prisma/client";

const log = logger.getSubLogger({ prefix: ["lib", "getTemporaryOrgRedirect"] });

export const getTemporaryOrgRedirect = async ({
  slugs,
  redirectType,
  eventTypeSlug,
  currentQuery,
}: {
  slugs: string[] | string;
  redirectType: RedirectType;
  eventTypeSlug: string | null;
  currentQuery: ParsedUrlQuery;
}) => {
  const prisma = (await import("@calcom/prisma")).default;
  slugs = slugs instanceof Array ? slugs : [slugs];
  log.debug(
    `Looking for redirect for`,
    safeStringify({
      slugs,
      redirectType,
      eventTypeSlug,
    })
  );

  const redirects = await prisma.tempOrgRedirect.findMany({
    where: {
      type: redirectType,
      from: {
        in: slugs,
      },
      fromOrgId: 0,
    },
  });

  const currentQueryString = stringify(currentQuery);
  if (!redirects.length) {
    return null;
  }

  // Use the first redirect origin as the new origin as we aren't supposed to handle different org usernames in a group
  const newOrigin = new URL(redirects[0].toUrl).origin;
  const query = currentQueryString ? `?${currentQueryString}` : "";
  // Use the same order as in input slugs - It is important from Dynamic Group perspective as the first user's settings are used for various things
  const newSlugs = slugs.map((slug) => {
    const redirect = redirects.find((redirect) => redirect.from === slug);

    if (!redirect) {
      return slug;
    }
    const newSlug = new URL(redirect.toUrl).pathname.slice(1);

    return newSlug;
  });

  const newSlug = newSlugs.join("+");
  const newPath = newSlug ? `/${newSlug}` : "";

  const newDestination = `${newOrigin}${newPath}${eventTypeSlug ? `/${eventTypeSlug}` : ""}${query}`;
  log.debug(`Suggesting redirect from ${slugs} to ${newDestination}`);

  return {
    redirect: {
      permanent: false,
      destination: newDestination,
    },
  } as const;
};
import type { Metadata } from "next";

import { truncateOnWord } from "@calcom/lib/text";

type RootMetadataRecipe = Readonly<{
  twitterCreator: string;
  twitterSite: string;
  robots: {
    index: boolean;
    follow: boolean;
  };
}>;

export type PageMetadataRecipe = Readonly<{
  title: string;
  canonical: string;
  image: string;
  description: string;
  siteName: string;
  metadataBase: URL;
}>;

export const prepareRootMetadata = (recipe: RootMetadataRecipe): Metadata => ({
  icons: {
    icon: "/favicon.icon",
    apple: "/api/logo?type=apple-touch-icon",
    other: [
      {
        rel: "icon-mask",
        url: "/safari-pinned-tab.svg",
        color: "#000000",
      },
      {
        url: "/api/logo?type=favicon-16",
        sizes: "16x16",
        type: "image/png",
      },
      {
        url: "/api/logo?type=favicon-32",
        sizes: "32x32",
        type: "image/png",
      },
    ],
  },
  manifest: "/site.webmanifest",
  viewport: "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0",
  robots: recipe.robots,
  other: {
    "application-TileColor": "#ff0000",
  },
  themeColor: [
    {
      media: "(prefers-color-scheme: light)",
      color: "#f9fafb",
    },
    {
      media: "(prefers-color-scheme: dark)",
      color: "#1C1C1C",
    },
  ],
  twitter: {
    site: recipe.twitterSite,
    creator: recipe.twitterCreator,
    card: "summary_large_image",
  },
});

export const preparePageMetadata = (recipe: PageMetadataRecipe): Metadata => ({
  title: recipe.title,
  alternates: {
    canonical: recipe.canonical,
  },
  openGraph: {
    description: truncateOnWord(recipe.description, 158),
    url: recipe.canonical,
    type: "website",
    siteName: recipe.siteName,
    title: recipe.title,
    images: [recipe.image],
  },
  metadataBase: recipe.metadataBase,
});
import type { Request, Response } from "express";
import type { Redirect } from "next";
import type { NextApiRequest, NextApiResponse } from "next";
import { createMocks } from "node-mocks-http";
import { describe, expect, it } from "vitest";

import withEmbedSsr from "./withEmbedSsr";

export type CustomNextApiRequest = NextApiRequest & Request;

export type CustomNextApiResponse = NextApiResponse & Response;

export function createMockNextJsRequest(...args: Parameters<typeof createMocks>) {
  return createMocks<CustomNextApiRequest, CustomNextApiResponse>(...args);
}

function getServerSidePropsFnGenerator(
  config:
    | { redirectUrl: string }
    | { props: Record<string, unknown> }
    | {
        notFound: true;
      }
) {
  if ("redirectUrl" in config)
    return async () => {
      return {
        redirect: {
          permanent: false,
          destination: config.redirectUrl,
        } satisfies Redirect,
      };
    };

  if ("props" in config)
    return async () => {
      return {
        props: config.props,
      };
    };

  if ("notFound" in config)
    return async () => {
      return {
        notFound: true as const,
      };
    };

  throw new Error("Invalid config");
}

function getServerSidePropsContextArg({
  embedRelatedParams,
}: {
  embedRelatedParams?: Record<string, string>;
}) {
  return {
    ...createMockNextJsRequest(),
    query: {
      ...embedRelatedParams,
    },
    resolvedUrl: "/MOCKED_RESOLVED_URL",
  };
}

describe("withEmbedSsr", () => {
  describe("when gSSP returns redirect", () => {
    describe("when redirect destination is relative, should add /embed to end of the path", () => {
      it("should add layout and embed params from the current query", async () => {
        const withEmbedGetSsr = withEmbedSsr(
          getServerSidePropsFnGenerator({
            redirectUrl: "/reschedule",
          })
        );

        const ret = await withEmbedGetSsr(
          getServerSidePropsContextArg({
            embedRelatedParams: {
              layout: "week_view",
              embed: "namespace1",
            },
          })
        );
        expect(ret).toEqual({
          redirect: {
            destination: "/reschedule/embed?layout=week_view&embed=namespace1",
            permanent: false,
          },
        });
      });

      it("should add layout and embed params without losing query params that were in redirect", async () => {
        const withEmbedGetSsr = withEmbedSsr(
          getServerSidePropsFnGenerator({
            redirectUrl: "/reschedule?redirectParam=1",
          })
        );

        const ret = await withEmbedGetSsr(
          getServerSidePropsContextArg({
            embedRelatedParams: {
              layout: "week_view",
              embed: "namespace1",
            },
          })
        );
        expect(ret).toEqual({
          redirect: {
            destination: "/reschedule/embed?redirectParam=1&layout=week_view&embed=namespace1",
            permanent: false,
          },
        });
      });

      it("should add embed param even when it was empty(i.e. default namespace of embed)", async () => {
        const withEmbedGetSsr = withEmbedSsr(
          getServerSidePropsFnGenerator({
            redirectUrl: "/reschedule?redirectParam=1",
          })
        );

        const ret = await withEmbedGetSsr(
          getServerSidePropsContextArg({
            embedRelatedParams: {
              layout: "week_view",
              embed: "",
            },
          })
        );
        expect(ret).toEqual({
          redirect: {
            destination: "/reschedule/embed?redirectParam=1&layout=week_view&embed=",
            permanent: false,
          },
        });
      });
    });

    describe("when redirect destination is absolute, should add /embed to end of the path", () => {
      it("should add layout and embed params from the current query when destination URL is HTTPS", async () => {
        const withEmbedGetSsr = withEmbedSsr(
          getServerSidePropsFnGenerator({
            redirectUrl: "https://calcom.cal.local/owner",
          })
        );

        const ret = await withEmbedGetSsr(
          getServerSidePropsContextArg({
            embedRelatedParams: {
              layout: "week_view",
              embed: "namespace1",
            },
          })
        );

        expect(ret).toEqual({
          redirect: {
            destination: "https://calcom.cal.local/owner/embed?layout=week_view&embed=namespace1",
            permanent: false,
          },
        });
      });
      it("should add layout and embed params from the current query when destination URL is HTTP", async () => {
        const withEmbedGetSsr = withEmbedSsr(
          getServerSidePropsFnGenerator({
            redirectUrl: "http://calcom.cal.local/owner",
          })
        );

        const ret = await withEmbedGetSsr(
          getServerSidePropsContextArg({
            embedRelatedParams: {
              layout: "week_view",
              embed: "namespace1",
            },
          })
        );

        expect(ret).toEqual({
          redirect: {
            destination: "http://calcom.cal.local/owner/embed?layout=week_view&embed=namespace1",
            permanent: false,
          },
        });
      });
      it("should correctly identify a URL as non absolute URL if protocol is missing", async () => {
        const withEmbedGetSsr = withEmbedSsr(
          getServerSidePropsFnGenerator({
            redirectUrl: "httpcalcom.cal.local/owner",
          })
        );

        const ret = await withEmbedGetSsr(
          getServerSidePropsContextArg({
            embedRelatedParams: {
              layout: "week_view",
              embed: "namespace1",
            },
          })
        );

        expect(ret).toEqual({
          redirect: {
            // FIXME: Note that it is adding a / in the beginning of the path, which might be fine for now, but could be an issue
            destination: "/httpcalcom.cal.local/owner/embed?layout=week_view&embed=namespace1",
            permanent: false,
          },
        });
      });
    });
  });

  describe("when gSSP returns props", () => {
    it("should add isEmbed=true prop", async () => {
      const withEmbedGetSsr = withEmbedSsr(
        getServerSidePropsFnGenerator({
          props: {
            prop1: "value1",
          },
        })
      );
      const ret = await withEmbedGetSsr(
        getServerSidePropsContextArg({
          embedRelatedParams: {
            layout: "week_view",
            embed: "",
          },
        })
      );
      expect(ret).toEqual({
        props: {
          prop1: "value1",
          isEmbed: true,
        },
      });
    });
  });

  describe("when gSSP doesn't have props or redirect ", () => {
    it("should return the result from gSSP as is", async () => {
      const withEmbedGetSsr = withEmbedSsr(
        getServerSidePropsFnGenerator({
          notFound: true,
        })
      );

      const ret = await withEmbedGetSsr(
        getServerSidePropsContextArg({
          embedRelatedParams: {
            layout: "week_view",
            embed: "",
          },
        })
      );

      expect(ret).toEqual({ notFound: true });
    });
  });
});
import prismock from "../../../tests/libs/__mocks__/prisma";

import { describe, expect, it } from "vitest";
import type { z } from "zod";

import { WEBSITE_URL } from "@calcom/lib/constants";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import type { MembershipRole, Prisma } from "@calcom/prisma/client";
import { RedirectType } from "@calcom/prisma/enums";
import type { teamMetadataSchema } from "@calcom/prisma/zod-utils";

import { moveTeamToOrg, moveUserToOrg, removeTeamFromOrg, removeUserFromOrg } from "./orgMigration";

const WEBSITE_PROTOCOL = new URL(WEBSITE_URL).protocol;
describe("orgMigration", () => {
  describe("moveUserToOrg", () => {
    describe("when user email does not match orgAutoAcceptEmail", () => {
      it(`should migrate a user to become a part of an organization with ADMIN role
          - username in the organization should be automatically derived from email when it isn't passed`, async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@example.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1-example",
          },
          targetOrg: {
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "ADMIN",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        const dbOrg = await createOrg({
          name: data.targetOrg.name,
          slug: data.targetOrg.slug,
        });

        const team1 = await createTeamOutsideOrg({
          name: "Team-1",
          slug: "team-1",
        });

        // Make userToMigrate part of team-1
        await addMemberShipOfUserWithTeam({
          teamId: team1.id,
          userId: dbUserToMigrate.id,
          role: "MEMBER",
          accepted: true,
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });

        await expectTeamToBeNotPartOfAnyOrganization({
          teamId: team1.id,
        });

        expectUserRedirectToBeEnabled({
          from: {
            username: data.userToMigrate.username,
          },
          to: data.userToMigrate.expectedUsernameInOrg,
          orgSlug: data.targetOrg.slug,
        });
      });

      it("should migrate a user to become a part of an organization(which has slug set) with MEMBER role", async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@example.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1-example",
          },
          targetOrg: {
            id: 1,
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "MEMBER",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        const dbOrg = await createOrg({
          slug: data.targetOrg.slug,
          name: data.targetOrg.name,
        });

        await moveUserToOrg({
          user: {
            id: dbOrg.id,
          },
          targetOrg: {
            id: data.targetOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: data.targetOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });
      });

      it(`should migrate a user to become a part of an organization(which has no slug but requestedSlug) with MEMBER role
        1. Should set the slug as requestedSlug for the organization(so that the redirect doesnt take to an unpublished organization page)`, async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@example.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1-example",
          },
          targetOrg: {
            name: "Org 1",
            requestedSlug: "org1",
          },
          membershipWeWant: {
            role: "MEMBER",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: "user-1@example.com",
          username: "user-1",
        });

        const dbOrg = await createOrg({
          name: data.targetOrg.name,
          metadata: {
            requestedSlug: data.targetOrg.requestedSlug,
          },
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        const organization = await prismock.team.findUnique({
          where: {
            id: dbOrg.id,
          },
        });

        expect(organization?.slug).toBe(data.targetOrg.requestedSlug);

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });
      });

      it("should migrate a user along with its teams(without other members)", async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@example.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1-example",
            teams: [
              {
                name: "Team 100",
                slug: "team-100",
              },
              {
                name: "Team 101",
                slug: "team-101",
              },
            ],
          },
          targetOrg: {
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "MEMBER",
          } as const,
          userPartOfTeam1: {
            username: "user-2",
            email: "user-2@example.com",
          },
          userPartOfTeam2: {
            username: "user-3",
            email: "user-3@example.com",
          },
        };

        // Create user to migrate
        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        // Create another user that would be part of team-1 along with userToMigrate
        const userPartOfTeam1 = await createUserOutsideOrg({
          email: data.userPartOfTeam1.email,
          username: data.userPartOfTeam1.username,
        });

        // Create another user that would be part of team-2 along with userToMigrate
        const userPartOfTeam2 = await createUserOutsideOrg({
          email: data.userPartOfTeam2.email,
          username: data.userPartOfTeam2.username,
        });

        const team1 = await createTeamOutsideOrg({
          name: data.userToMigrate.teams[0].name,
          slug: data.userToMigrate.teams[0].slug,
        });

        const team2 = await createTeamOutsideOrg({
          name: data.userToMigrate.teams[1].name,
          slug: data.userToMigrate.teams[1].slug,
        });

        // Make userToMigrate part of team-1
        await addMemberShipOfUserWithTeam({
          teamId: team1.id,
          userId: dbUserToMigrate.id,
          role: "MEMBER",
          accepted: true,
        });

        // Make userToMigrate part of team-2
        await addMemberShipOfUserWithTeam({
          teamId: team2.id,
          userId: dbUserToMigrate.id,
          role: "MEMBER",
          accepted: true,
        });

        // Make userPartofTeam1 part of team-1
        await addMemberShipOfUserWithTeam({
          teamId: team1.id,
          userId: userPartOfTeam1.id,
          role: "MEMBER",
          accepted: true,
        });

        // Make userPartofTeam2 part of team2
        await addMemberShipOfUserWithTeam({
          teamId: team2.id,
          userId: userPartOfTeam2.id,
          role: "MEMBER",
          accepted: true,
        });

        const dbOrg = await createOrg({
          name: data.targetOrg.name,
          slug: data.targetOrg.slug,
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: true,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });

        await expectTeamToBeAPartOfOrg({
          teamId: team1.id,
          orgId: dbOrg.id,
          teamSlugInOrg: team1.slug,
        });

        await expectTeamToBeAPartOfOrg({
          teamId: team2.id,
          orgId: dbOrg.id,
          teamSlugInOrg: team2.slug,
        });

        await expectUserToBeNotAPartOfTheOrg({
          userId: userPartOfTeam1.id,
          orgId: dbOrg.id,
          username: data.userPartOfTeam1.username,
        });

        await expectUserToBeNotAPartOfTheOrg({
          userId: userPartOfTeam2.id,
          orgId: dbOrg.id,
          username: data.userPartOfTeam2.username,
        });
      });

      it(`should migrate a user to become a part of an organization
      - username in the organization should same as provided to moveUserToOrg`, async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@example.com",
            usernameInOrgThatWeWant: "user-1-in-org",
          },
          targetOrg: {
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "ADMIN",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        const dbOrg = await createOrg({
          name: data.targetOrg.name,
          slug: data.targetOrg.slug,
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            username: data.userToMigrate.usernameInOrgThatWeWant,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.usernameInOrgThatWeWant,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });

        expectUserRedirectToBeEnabled({
          from: {
            username: data.userToMigrate.username,
          },
          to: data.userToMigrate.usernameInOrgThatWeWant,
          orgSlug: data.targetOrg.slug,
        });
      });

      it(`should be able to re-migrate an already migrated user fixing things as we do it
          - Redirect should correctly determine the nonOrgUsername so that on repeat migrations, the original user link doesn't break`, async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@example.com",
            // Because example.com isn't the orgAutoAcceptEmail
            usernameWeWantInOrg: "user-1-in-org",
          },
          targetOrg: {
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "MEMBER",
          } as const,
        };

        const dbOrg = await createOrg({
          name: data.targetOrg.name,
          slug: data.targetOrg.slug,
        });

        const dbUserToMigrate = await createUserInsideTheOrg(
          {
            email: data.userToMigrate.email,
            username: data.userToMigrate.username,
          },
          dbOrg.id
        );

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            username: data.userToMigrate.usernameWeWantInOrg,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.usernameWeWantInOrg,
          // membership role should be updated
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            username: data.userToMigrate.usernameWeWantInOrg,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.usernameWeWantInOrg,
          // membership role should be updated
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });

        expectUserRedirectToBeEnabled({
          from: {
            username: data.userToMigrate.username,
          },
          to: data.userToMigrate.usernameWeWantInOrg,
          orgSlug: data.targetOrg.slug,
        });

        console.log(await prismock.tempOrgRedirect.findMany({}));
      });

      describe("Failures handling", () => {
        it("migration should fail if the username already exists in the organization", async () => {
          const data = {
            userToMigrate: {
              username: "user-1",
              email: "user-1@example.com",
              // Because example.com isn't the orgAutoAcceptEmail
              expectedUsernameInOrg: "user-1-example",
            },
            targetOrg: {
              name: "Org 1",
              slug: "org1",
            },
            membershipWeWant: {
              role: "MEMBER",
            } as const,
          };

          const dbOrg = await createOrg({
            name: data.targetOrg.name,
            slug: data.targetOrg.slug,
          });

          await createUserInsideTheOrg(
            {
              email: data.userToMigrate.email,
              username: data.userToMigrate.username,
            },
            dbOrg.id
          );

          // User with same username exists outside the org as well as inside the org
          const dbUserToMigrate = await createUserOutsideOrg({
            email: data.userToMigrate.email,
            username: data.userToMigrate.username,
          });

          expect(() => {
            return moveUserToOrg({
              user: {
                id: dbUserToMigrate.id,
              },
              targetOrg: {
                id: dbOrg.id,
                username: data.userToMigrate.username,
                membership: {
                  role: data.membershipWeWant.role,
                },
              },
              shouldMoveTeams: false,
            });
          }).rejects.toThrowError("already exists");
        });

        it("should fail the migration if the target org doesn't exist", async () => {
          const data = {
            userToMigrate: {
              username: "user-1",
              email: "user-1@example.com",
              // Because example.com isn't the orgAutoAcceptEmail
              expectedUsernameInOrg: "user-1-example",
            },
            targetOrg: {
              name: "Org 1",
              slug: "org1",
            },
            membershipWeWant: {
              role: "MEMBER",
            } as const,
          };

          const dbOrg = await createOrg({
            name: data.targetOrg.name,
            slug: data.targetOrg.slug,
          });

          await createUserInsideTheOrg(
            {
              email: data.userToMigrate.email,
              username: data.userToMigrate.username,
            },
            dbOrg.id
          );

          // User with same username exists outside the org as well as inside the org
          const dbUserToMigrate = await createUserOutsideOrg({
            email: data.userToMigrate.email,
            username: data.userToMigrate.username,
          });

          expect(() => {
            return moveUserToOrg({
              user: {
                id: dbUserToMigrate.id,
              },
              targetOrg: {
                // Non existent teamId
                id: 1001,
                username: data.userToMigrate.username,
                membership: {
                  role: data.membershipWeWant.role,
                },
              },
              shouldMoveTeams: false,
            });
          }).rejects.toThrowError(/Org .* not found/);
        });

        it("should fail the migration if the target teamId is not an organization", async () => {
          const data = {
            userToMigrate: {
              username: "user-1",
              email: "user-1@example.com",
              // Because example.com isn't the orgAutoAcceptEmail
              expectedUsernameInOrg: "user-1-example",
            },
            targetOrg: {
              name: "Org 1",
              slug: "org1",
            },
            membershipWeWant: {
              role: "MEMBER",
            } as const,
          };

          // Create a team instead of an organization
          const dbOrgWhichIsActuallyATeam = await createTeamOutsideOrg({
            name: data.targetOrg.name,
            slug: data.targetOrg.slug,
          });

          const dbUserToMigrate = await createUserOutsideOrg({
            email: data.userToMigrate.email,
            username: data.userToMigrate.username,
          });

          expect(() => {
            return moveUserToOrg({
              user: {
                id: dbUserToMigrate.id,
              },
              targetOrg: {
                // Non existent teamId
                id: dbOrgWhichIsActuallyATeam.id,
                username: data.userToMigrate.username,
                membership: {
                  role: data.membershipWeWant.role,
                },
              },
              shouldMoveTeams: false,
            });
          }).rejects.toThrowError(/is not an Org/);
        });

        it("should fail the migration if the user is part of any other organization", async () => {
          const data = {
            userToMigrate: {
              username: "user-1",
              email: "user-1@example.com",
              // Because example.com isn't the orgAutoAcceptEmail
              expectedUsernameInOrg: "user-1-example",
            },
            targetOrg: {
              name: "Org 1",
              slug: "org1",
            },
            membershipWeWant: {
              role: "MEMBER",
            } as const,
          };

          const dbOrg = await createOrg({
            name: data.targetOrg.name,
            slug: data.targetOrg.slug,
          });

          const dbOrgOther = await createOrg({
            name: data.targetOrg.name,
            slug: data.targetOrg.slug,
          });

          const dbUserToMigrate = await createUserInsideTheOrg(
            {
              email: data.userToMigrate.email,
              username: data.userToMigrate.username,
            },
            dbOrgOther.id
          );

          expect(() => {
            return moveUserToOrg({
              user: {
                id: dbUserToMigrate.id,
              },
              targetOrg: {
                // Non existent teamId
                id: dbOrg.id,
                username: data.userToMigrate.username,
                membership: {
                  role: data.membershipWeWant.role,
                },
              },
              shouldMoveTeams: false,
            });
          }).rejects.toThrowError(/already a part of different organization/);
        });
      });
    });

    describe("when user email matches orgAutoAcceptEmail", () => {
      const orgMetadata = {
        orgAutoAcceptEmail: "org1.com",
      } as const;

      it(`should migrate a user to become a part of an organization with ADMIN role`, async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@org1.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1",
          },
          targetOrg: {
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "ADMIN",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        const dbOrg = await createOrg({
          slug: data.targetOrg.slug,
          name: data.targetOrg.name,
          metadata: {
            ...orgMetadata,
          },
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });

        expectUserRedirectToBeEnabled({
          from: {
            username: data.userToMigrate.username,
          },
          to: data.userToMigrate.expectedUsernameInOrg,
          orgSlug: data.targetOrg.slug,
        });
      });

      it("should migrate a user to become a part of an organization(which has slug set) with MEMBER role", async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@org1.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1",
          },
          targetOrg: {
            name: "Org 1",
            slug: "org1",
          },
          membershipWeWant: {
            role: "MEMBER",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        const dbOrg = await createOrg({
          slug: data.targetOrg.slug,
          name: data.targetOrg.name,
          metadata: {
            ...orgMetadata,
          },
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });
      });

      it(`should migrate a user to become a part of an organization(which has no slug but requestedSlug) with MEMBER role
        1. Should set the slug as requestedSlug for the organization(so that the redirect doesnt take to an unpublished organization page)`, async () => {
        const data = {
          userToMigrate: {
            username: "user-1",
            email: "user-1@org1.com",
            // Because example.com isn't the orgAutoAcceptEmail
            expectedUsernameInOrg: "user-1",
          },
          targetOrg: {
            name: "Org 1",
            requestedSlug: "org1",
          },
          membershipWeWant: {
            role: "MEMBER",
          } as const,
        };

        const dbUserToMigrate = await createUserOutsideOrg({
          email: data.userToMigrate.email,
          username: data.userToMigrate.username,
        });

        const dbOrg = await createOrg({
          name: data.targetOrg.name,
          metadata: {
            requestedSlug: data.targetOrg.requestedSlug,
            ...orgMetadata,
          },
        });

        await moveUserToOrg({
          user: {
            id: dbUserToMigrate.id,
          },
          targetOrg: {
            id: dbOrg.id,
            membership: {
              role: data.membershipWeWant.role,
            },
          },
          shouldMoveTeams: false,
        });

        const organization = await prismock.team.findUnique({
          where: {
            id: dbOrg.id,
          },
        });

        expect(organization?.slug).toBe(data.targetOrg.requestedSlug);

        await expectUserToBeAPartOfOrg({
          userId: dbUserToMigrate.id,
          orgId: dbOrg.id,
          usernameInOrg: data.userToMigrate.expectedUsernameInOrg,
          expectedMembership: { role: data.membershipWeWant.role, accepted: true },
        });
      });
    });
  });

  describe("moveTeamToOrg", () => {
    it(`should migrate a team to become a part of an organization`, async () => {
      const data = {
        teamToMigrate: {
          id: 1,
          name: "Team 1",
          slug: "team1",
          newSlug: "team1-new-slug",
        },
        targetOrg: {
          id: 2,
          name: "Org 1",
          slug: "org1",
        },
      };

      await prismock.team.create({
        data: {
          id: data.teamToMigrate.id,
          slug: data.teamToMigrate.slug,
          name: data.teamToMigrate.name,
        },
      });

      await prismock.team.create({
        data: {
          id: data.targetOrg.id,
          slug: data.targetOrg.slug,
          name: data.targetOrg.name,
          metadata: {
            isOrganization: true,
          },
        },
      });

      await moveTeamToOrg({
        teamId: data.teamToMigrate.id,
        targetOrg: {
          id: data.targetOrg.id,
          teamSlug: data.teamToMigrate.newSlug,
        },
      });

      await expectTeamToBeAPartOfOrg({
        teamId: data.teamToMigrate.id,
        orgId: data.targetOrg.id,
        teamSlugInOrg: data.teamToMigrate.newSlug,
      });

      expectTeamRedirectToBeEnabled({
        from: {
          teamSlug: data.teamToMigrate.slug,
        },
        to: data.teamToMigrate.newSlug,
        orgSlug: data.targetOrg.slug,
      });
    });
    it.todo("should migrate a team with members");
    it.todo("Try migrating an already migrated team");
  });

  describe("removeUserFromOrg", () => {
    it(`should remove a user from an organization but he should remain in team`, async () => {
      const data = {
        userToUnmigrate: {
          username: "user1-in-org1",
          email: "user-1@example.com",
          usernameBeforeMovingToOrg: "user1",
        },
        targetOrg: {
          name: "Org 1",
          slug: "org1",
        },
        membershipWeWant: {
          role: "ADMIN",
        } as const,
      };

      const dbOrg = await createOrg({
        slug: data.targetOrg.slug,
        name: data.targetOrg.name,
      });

      const dbTeamOutsideOrg = await createTeamOutsideOrg({
        slug: "team-1",
        name: "Team 1",
      });

      const dbUser = await createUserInsideTheOrg(
        {
          email: data.userToUnmigrate.email,
          username: data.userToUnmigrate.username,
          metadata: {
            migratedToOrgFrom: {
              username: data.userToUnmigrate.usernameBeforeMovingToOrg,
            },
          },
        },
        dbOrg.id
      );

      await addMemberShipOfUserWithOrg({
        userId: dbUser.id,
        teamId: dbTeamOutsideOrg.id,
        role: "MEMBER",
        accepted: true,
      });

      await addMemberShipOfUserWithTeam({
        userId: dbUser.id,
        teamId: dbOrg.id,
        role: data.membershipWeWant.role,
        accepted: true,
      });

      const userToUnmigrate = await prismock.user.findUnique({
        where: {
          id: dbUser.id,
        },
        include: {
          organization: true,
        },
      });

      if (!userToUnmigrate?.organizationId || !userToUnmigrate.organization) {
        throw new Error(
          `Couldn't setup user to unmigrate properly userToUnMigrate: ${{
            organizationId: userToUnmigrate?.organizationId,
            organization: !!userToUnmigrate?.organization,
          }}`
        );
      }

      await removeUserFromOrg({
        userId: dbUser.id,
        targetOrgId: dbOrg.id,
      });

      await expectUserToBeNotAPartOfTheOrg({
        userId: dbUser.id,
        orgId: dbOrg.id,
        username: data.userToUnmigrate.usernameBeforeMovingToOrg,
      });

      await expectUserToBeAPartOfTeam({
        userId: dbUser.id,
        teamId: dbTeamOutsideOrg.id,
        expectedMembership: {
          role: "MEMBER",
          accepted: true,
        },
      });

      expectUserRedirectToBeNotEnabled({
        from: {
          username: data.userToUnmigrate.username,
        },
      });
    });
  });

  describe("removeTeamFromOrg", () => {
    it(`should remove a team from an organization`, async () => {
      const data = {
        teamToUnmigrate: {
          name: "Team 1",
          slug: "team1",
        },
        targetOrg: {
          name: "Org 1",
          slug: "org1",
        },
      };

      const targetOrg = await prismock.team.create({
        data: {
          slug: data.targetOrg.slug,
          name: data.targetOrg.name,
          metadata: {
            isOrganization: true,
          },
        },
      });

      const { id: teamToUnMigrateId } = await prismock.team.create({
        data: {
          slug: data.teamToUnmigrate.slug,
          name: data.teamToUnmigrate.name,
          parent: {
            connect: {
              id: targetOrg.id,
            },
          },
        },
      });

      const teamToUnmigrate = await prismock.team.findUnique({
        where: {
          id: teamToUnMigrateId,
        },
        include: {
          parent: true,
        },
      });

      if (!teamToUnmigrate?.parent || !teamToUnmigrate.parentId) {
        throw new Error(`Couldn't setup team to unmigrate properly ID:${teamToUnMigrateId}`);
      }

      await removeTeamFromOrg({
        teamId: teamToUnMigrateId,
        targetOrgId: targetOrg.id,
      });

      await expectTeamToBeNotPartOfAnyOrganization({
        teamId: teamToUnMigrateId,
      });

      expectTeamRedirectToBeNotEnabled({
        from: {
          teamSlug: data.teamToUnmigrate.slug,
        },
        to: data.teamToUnmigrate.slug,
        orgSlug: data.targetOrg.slug,
      });
    });

    it(`should remove a team from an organization with it's members`, async () => {
      const data = {
        teamToUnmigrate: {
          name: "Team 1",
          slug: "team1",
          members: [
            {
              username: "user1-example",
              email: "user1@example.com",
              usernameBeforeMovingToOrg: "user1",
            },
          ],
        },
        targetOrg: {
          name: "Org 1",
          slug: "org1",
        },
      };

      const targetOrg = await prismock.team.create({
        data: {
          slug: data.targetOrg.slug,
          name: data.targetOrg.name,
          metadata: {
            isOrganization: true,
          },
        },
      });

      const { id: teamToUnMigrateId } = await prismock.team.create({
        data: {
          slug: data.teamToUnmigrate.slug,
          name: data.teamToUnmigrate.name,
          parent: {
            connect: {
              id: targetOrg.id,
            },
          },
        },
      });

      const teamToUnmigrate = await prismock.team.findUnique({
        where: {
          id: teamToUnMigrateId,
        },
        include: {
          parent: true,
        },
      });

      if (!teamToUnmigrate?.parent || !teamToUnmigrate.parentId) {
        throw new Error(`Couldn't setup team to unmigrate properly ID:${teamToUnMigrateId}`);
      }

      const member1OfTeam = await createUserInsideTheOrg(
        {
          email: data.teamToUnmigrate.members[0].email,
          username: data.teamToUnmigrate.members[0].username,
          metadata: {
            migratedToOrgFrom: {
              username: data.teamToUnmigrate.members[0].usernameBeforeMovingToOrg,
            },
          },
        },
        targetOrg.id
      );

      addMemberShipOfUserWithOrg({
        userId: member1OfTeam.id,
        teamId: targetOrg.id,
        role: "MEMBER",
        accepted: true,
      });

      addMemberShipOfUserWithTeam({
        teamId: teamToUnmigrate.id,
        userId: member1OfTeam.id,
        role: "MEMBER",
        accepted: true,
      });

      expectUserToBeAPartOfOrg({
        userId: member1OfTeam.id,
        orgId: targetOrg.id,
        usernameInOrg: data.teamToUnmigrate.members[0].username,
        expectedMembership: {
          role: "MEMBER",
          accepted: true,
        },
      });

      expectUserToBeAPartOfTeam({
        userId: member1OfTeam.id,
        teamId: teamToUnmigrate.id,
        expectedMembership: {
          role: "MEMBER",
          accepted: true,
        },
      });

      await removeTeamFromOrg({
        teamId: teamToUnMigrateId,
        targetOrgId: targetOrg.id,
      });

      await expectTeamToBeNotPartOfAnyOrganization({
        teamId: teamToUnMigrateId,
      });

      expectTeamRedirectToBeNotEnabled({
        from: {
          teamSlug: data.teamToUnmigrate.slug,
        },
        to: data.teamToUnmigrate.slug,
        orgSlug: data.targetOrg.slug,
      });

      expectUserRedirectToBeNotEnabled({
        from: {
          username: data.teamToUnmigrate.members[0].usernameBeforeMovingToOrg,
        },
      });

      expectUserToBeNotAPartOfTheOrg({
        userId: member1OfTeam.id,
        orgId: targetOrg.id,
        username: data.teamToUnmigrate.members[0].usernameBeforeMovingToOrg,
      });

      expectUserToBeNotAPartOfTheTeam({
        userId: member1OfTeam.id,
        teamId: targetOrg.id,
        username: data.teamToUnmigrate.members[0].usernameBeforeMovingToOrg,
      });
    });
  });
});

async function expectUserToBeAPartOfOrg({
  userId,
  orgId,
  expectedMembership,
  usernameInOrg,
}: {
  userId: number;
  orgId: number;
  usernameInOrg: string;
  expectedMembership: {
    role: MembershipRole;
    accepted: boolean;
  };
}) {
  const migratedUser = await prismock.user.findUnique({
    where: {
      id: userId,
    },
    include: {
      teams: true,
    },
  });
  if (!migratedUser) {
    throw new Error(`User with id ${userId} does not exist`);
  }

  expect(migratedUser.username).toBe(usernameInOrg);
  expect(migratedUser.organizationId).toBe(orgId);

  const membership = migratedUser.teams.find(
    (membership) => membership.teamId === orgId && membership.userId === userId
  );

  expect(membership).not.toBeNull();
  if (!membership) {
    throw new Error(`User with id ${userId} is not a part of org with id ${orgId}`);
  }
  expect(membership.role).toBe(expectedMembership.role);
  expect(membership.accepted).toBe(expectedMembership.accepted);
}

async function expectUserToBeAPartOfTeam({
  userId,
  teamId,
  expectedMembership,
}: {
  userId: number;
  teamId: number;
  expectedMembership: {
    role: MembershipRole;
    accepted: boolean;
  };
}) {
  const user = await prismock.user.findUnique({
    where: {
      id: userId,
    },
    include: {
      teams: true,
    },
  });
  if (!user) {
    throw new Error(`User with id ${userId} does not exist`);
  }

  const membership = user.teams.find(
    (membership) => membership.teamId === teamId && membership.userId === userId
  );

  expect(membership).not.toBeNull();
  if (!membership) {
    throw new Error(`User with id ${userId} is not a part of team with id ${teamId}`);
  }
  expect(membership.role).toBe(expectedMembership.role);
  expect(membership.accepted).toBe(expectedMembership.accepted);
}

async function expectUserToBeNotAPartOfTheOrg({
  userId,
  orgId,
  username,
}: {
  userId: number;
  orgId: number;
  username: string;
}) {
  expectUserToBeNotAPartOfTheTeam({
    userId,
    teamId: orgId,
    username,
  });
}

async function expectUserToBeNotAPartOfTheTeam({
  userId,
  teamId,
  username,
}: {
  userId: number;
  teamId: number;
  username: string;
}) {
  const user = await prismock.user.findUnique({
    where: {
      id: userId,
    },
    include: {
      teams: true,
    },
  });
  if (!user) {
    throw new Error(`User with id ${userId} does not exist`);
  }

  expect(user.username).toBe(username);
  expect(user.organizationId).toBe(null);

  const membership = user.teams.find(
    (membership) => membership.teamId === teamId && membership.userId === userId
  );

  expect(membership).toBeUndefined();
}

async function expectTeamToBeAPartOfOrg({
  teamId,
  orgId,
  teamSlugInOrg,
}: {
  teamId: number;
  orgId: number;
  teamSlugInOrg: string | null;
}) {
  const migratedTeam = await prismock.team.findUnique({
    where: {
      id: teamId,
    },
  });
  if (!migratedTeam) {
    throw new Error(`Team with id ${teamId} does not exist`);
  }

  if (!teamSlugInOrg) {
    throw new Error(`teamSlugInOrg should be defined`);
  }
  expect(migratedTeam.parentId).toBe(orgId);
  expect(migratedTeam.slug).toBe(teamSlugInOrg);
}

async function expectTeamToBeNotPartOfAnyOrganization({ teamId }: { teamId: number }) {
  const team = await prismock.team.findUnique({
    where: {
      id: teamId,
    },
  });
  if (!team) {
    throw new Error(`Team with id ${teamId} does not exist`);
  }

  expect(team.parentId).toBe(null);
}

async function expectUserRedirectToBeEnabled({
  from,
  to,
  orgSlug,
}: {
  from: { username: string } | { teamSlug: string };
  to: string;
  orgSlug: string;
}) {
  expectRedirectToBeEnabled({
    from,
    to,
    orgSlug,
    redirectType: RedirectType.User,
  });
}

async function expectTeamRedirectToBeEnabled({
  from,
  to,
  orgSlug,
}: {
  from: { username: string } | { teamSlug: string };
  to: string;
  orgSlug: string;
}) {
  expectRedirectToBeEnabled({
    from,
    to,
    orgSlug,
    redirectType: RedirectType.Team,
  });
}

async function expectUserRedirectToBeNotEnabled({
  from,
}: {
  from: { username: string } | { teamSlug: string };
}) {
  expectRedirectToBeNotEnabled({
    from,
  });
}

async function expectTeamRedirectToBeNotEnabled({
  from,
}: {
  from: { username: string } | { teamSlug: string };
  to: string;
  orgSlug: string;
}) {
  expectRedirectToBeNotEnabled({
    from,
  });
}

async function expectRedirectToBeEnabled({
  from,
  to,
  orgSlug,
  redirectType,
}: {
  from: { username: string } | { teamSlug: string };
  to: string;
  orgSlug: string;
  redirectType: RedirectType;
}) {
  let tempOrgRedirectWhere = null;
  let tempOrgRedirectThatShouldNotExistWhere = null;
  if ("username" in from) {
    tempOrgRedirectWhere = {
      from_type_fromOrgId: {
        from: from.username,
        type: RedirectType.User,
        fromOrgId: 0,
      },
    };

    // Normally with user migration `from.username != to`
    if (from.username !== to) {
      // There must not be a redirect setup from=To to something else as that would cause double redirection
      tempOrgRedirectThatShouldNotExistWhere = {
        from_type_fromOrgId: {
          from: to,
          type: RedirectType.User,
          fromOrgId: 0,
        },
      };
    }
  } else if ("teamSlug" in from) {
    tempOrgRedirectWhere = {
      from_type_fromOrgId: {
        from: from.teamSlug,
        type: RedirectType.Team,
        fromOrgId: 0,
      },
    };

    if (from.teamSlug !== to) {
      // There must not be a redirect setup from=To to something else as that would cause double redirection
      tempOrgRedirectThatShouldNotExistWhere = {
        from_type_fromOrgId: {
          from: to,
          type: RedirectType.Team,
          fromOrgId: 0,
        },
      };
    }
  } else {
    throw new Error("Atleast one of userId or teamId should be present in from");
  }
  const redirect = await prismock.tempOrgRedirect.findUnique({
    where: tempOrgRedirectWhere,
  });

  if (tempOrgRedirectThatShouldNotExistWhere) {
    const redirectThatShouldntBeThere = await prismock.tempOrgRedirect.findUnique({
      where: tempOrgRedirectThatShouldNotExistWhere,
    });
    expect(redirectThatShouldntBeThere).toBeNull();
  }

  expect(redirect).not.toBeNull();
  expect(redirect?.toUrl).toBe(`${WEBSITE_PROTOCOL}//${orgSlug}.cal.local:3000/${to}`);
  if (!redirect) {
    throw new Error(`Redirect doesn't exist for ${JSON.stringify(tempOrgRedirectWhere)}`);
  }
  expect(redirect.type).toBe(redirectType);
}

async function expectRedirectToBeNotEnabled({ from }: { from: { username: string } | { teamSlug: string } }) {
  let tempOrgRedirectWhere = null;
  if ("username" in from) {
    tempOrgRedirectWhere = {
      from_type_fromOrgId: {
        from: from.username,
        type: RedirectType.User,
        fromOrgId: 0,
      },
    };
  } else if ("teamSlug" in from) {
    tempOrgRedirectWhere = {
      from_type_fromOrgId: {
        from: from.teamSlug,
        type: RedirectType.Team,
        fromOrgId: 0,
      },
    };
  } else {
    throw new Error("Atleast one of userId or teamId should be present in from");
  }
  const redirect = await prismock.tempOrgRedirect.findUnique({
    where: tempOrgRedirectWhere,
  });
  expect(redirect).toBeNull();
}

async function createOrg(
  data: Omit<Prisma.TeamCreateArgs["data"], "metadata" | "parent"> & {
    metadata?: z.infer<typeof teamMetadataSchema>;
  }
) {
  return await prismock.team.create({
    data: {
      ...data,
      metadata: {
        ...(data.metadata || {}),
        isOrganization: true,
      },
    },
  });
}

async function createTeamOutsideOrg(
  data: Omit<Prisma.TeamCreateArgs["data"], "metadata" | "parent"> & {
    metadata?: z.infer<typeof teamMetadataSchema>;
  }
) {
  return await prismock.team.create({
    data: {
      ...data,
      parentId: null,
      metadata: {
        ...(data.metadata || {}),
        isOrganization: false,
      },
    },
  });
}

async function createUserOutsideOrg(data: Omit<Prisma.UserCreateArgs["data"], "organization">) {
  return await prismock.user.create({
    data: {
      ...data,
      organizationId: null,
    },
  });
}

async function createUserInsideTheOrg(
  data: Omit<Prisma.UserUncheckedCreateInput, "organization" | "organizationId" | "id">,
  orgId: number
) {
  const org = await prismock.team.findUnique({
    where: {
      id: orgId,
    },
  });
  if (!org) {
    throw new Error(`Org with id ${orgId} does not exist`);
  }
  logger.debug(
    `Creating user inside org`,
    safeStringify({
      orgId,
      data,
    })
  );
  return await prismock.user.create({
    data: {
      ...data,
      organization: {
        connect: {
          id: orgId,
        },
      },
    },
  });
}

async function addMemberShipOfUserWithTeam({
  teamId,
  userId,
  role,
  accepted,
}: {
  teamId: number;
  userId: number;
  role: MembershipRole;
  accepted: boolean;
}) {
  await prismock.membership.create({
    data: {
      role,
      accepted,
      team: {
        connect: {
          id: teamId,
        },
      },
      user: {
        connect: {
          id: userId,
        },
      },
    },
  });

  const membership = await prismock.membership.findUnique({
    where: {
      userId_teamId: {
        teamId,
        userId,
      },
    },
  });
  if (!membership) {
    throw new Error(`Membership between teamId ${teamId} and userId ${userId} couldn't be created`);
  }
}

const addMemberShipOfUserWithOrg = addMemberShipOfUserWithTeam;
import prismaMock from "../../../tests/libs/__mocks__/prismaMock";

import { describe, it, expect, beforeEach } from "vitest";

import { RedirectType } from "@calcom/prisma/client";

import { getTemporaryOrgRedirect } from "./getTemporaryOrgRedirect";

const mockData = {
  redirects: [] as {
    toUrl: string;
    from: string;
    redirectType: RedirectType;
  }[],
};

function mockARedirectInDB({
  toUrl,
  slug,
  redirectType,
}: {
  toUrl: string;
  slug: string;
  redirectType: RedirectType;
}) {
  mockData.redirects.push({
    toUrl,
    from: slug,
    redirectType,
  });
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  //@ts-ignore
  prismaMock.tempOrgRedirect.findMany.mockImplementation(({ where }) => {
    return new Promise((resolve) => {
      const tempOrgRedirects: typeof mockData.redirects = [];
      where.from.in.forEach((whereSlug: string) => {
        const matchingRedirect = mockData.redirects.find((redirect) => {
          return where.type === redirect.redirectType && whereSlug === redirect.from && where.fromOrgId === 0;
        });

        if (matchingRedirect) {
          tempOrgRedirects.push(matchingRedirect);
        }
      });
      resolve(tempOrgRedirects);
    });
  });
}

beforeEach(() => {
  mockData.redirects = [];
});

describe("getTemporaryOrgRedirect", () => {
  it("should generate event-type URL without existing query params", async () => {
    mockARedirectInDB({ slug: "slug", toUrl: "https://calcom.cal.com", redirectType: RedirectType.User });

    const redirect = await getTemporaryOrgRedirect({
      slugs: "slug",
      redirectType: RedirectType.User,
      eventTypeSlug: "30min",
      currentQuery: {},
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/30min",
      },
    });
  });

  it("should generate event-type URL with existing query params", async () => {
    mockARedirectInDB({ slug: "slug", toUrl: "https://calcom.cal.com", redirectType: RedirectType.User });

    const redirect = await getTemporaryOrgRedirect({
      slugs: "slug",
      redirectType: RedirectType.User,
      eventTypeSlug: "30min",
      currentQuery: {
        abc: "1",
      },
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/30min?abc=1",
      },
    });
  });

  it("should generate User URL with existing query params", async () => {
    mockARedirectInDB({ slug: "slug", toUrl: "https://calcom.cal.com", redirectType: RedirectType.User });

    const redirect = await getTemporaryOrgRedirect({
      slugs: "slug",
      redirectType: RedirectType.User,
      eventTypeSlug: null,
      currentQuery: {
        abc: "1",
      },
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com?abc=1",
      },
    });
  });

  it("should generate Team Profile URL with existing query params", async () => {
    mockARedirectInDB({
      slug: "seeded-team",
      toUrl: "https://calcom.cal.com",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: "seeded-team",
      redirectType: RedirectType.Team,
      eventTypeSlug: null,
      currentQuery: {
        abc: "1",
      },
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com?abc=1",
      },
    });
  });

  it("should generate Team Event URL with existing query params", async () => {
    mockARedirectInDB({
      slug: "seeded-team",
      toUrl: "https://calcom.cal.com",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: "seeded-team",
      redirectType: RedirectType.Team,
      eventTypeSlug: "30min",
      currentQuery: {
        abc: "1",
      },
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/30min?abc=1",
      },
    });
  });

  it("should generate Team Event URL without query params", async () => {
    mockARedirectInDB({
      slug: "seeded-team",
      toUrl: "https://calcom.cal.com",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: "seeded-team",
      redirectType: RedirectType.Team,
      eventTypeSlug: "30min",
      currentQuery: {},
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/30min",
      },
    });
  });

  it("should generate Dynamic Group Booking Profile Url", async () => {
    mockARedirectInDB({
      slug: "first",
      toUrl: "https://calcom.cal.com/first-in-org1",
      redirectType: RedirectType.Team,
    });
    mockARedirectInDB({
      slug: "second",
      toUrl: "https://calcom.cal.com/second-in-org1",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: ["first", "second"],
      redirectType: RedirectType.Team,
      eventTypeSlug: null,
      currentQuery: {},
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/first-in-org1+second-in-org1",
      },
    });
  });

  it("should generate Dynamic Group Booking Profile Url - same order", async () => {
    mockARedirectInDB({
      slug: "second",
      toUrl: "https://calcom.cal.com/second-in-org1",
      redirectType: RedirectType.Team,
    });
    mockARedirectInDB({
      slug: "first",
      toUrl: "https://calcom.cal.com/first-in-org1",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: ["first", "second"],
      redirectType: RedirectType.Team,
      eventTypeSlug: null,
      currentQuery: {},
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/first-in-org1+second-in-org1",
      },
    });

    const redirect1 = await getTemporaryOrgRedirect({
      slugs: ["second", "first"],
      redirectType: RedirectType.Team,
      eventTypeSlug: null,
      currentQuery: {},
    });

    expect(redirect1).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/second-in-org1+first-in-org1",
      },
    });
  });

  it("should generate Dynamic Group Booking Profile Url with query params", async () => {
    mockARedirectInDB({
      slug: "first",
      toUrl: "https://calcom.cal.com/first-in-org1",
      redirectType: RedirectType.Team,
    });
    mockARedirectInDB({
      slug: "second",
      toUrl: "https://calcom.cal.com/second-in-org1",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: ["first", "second"],
      redirectType: RedirectType.Team,
      eventTypeSlug: null,
      currentQuery: {
        abc: "1",
      },
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/first-in-org1+second-in-org1?abc=1",
      },
    });
  });

  it("should generate Dynamic Group Booking EventType Url", async () => {
    mockARedirectInDB({
      slug: "first",
      toUrl: "https://calcom.cal.com/first-in-org1",
      redirectType: RedirectType.Team,
    });
    mockARedirectInDB({
      slug: "second",
      toUrl: "https://calcom.cal.com/second-in-org1",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: ["first", "second"],
      redirectType: RedirectType.Team,
      eventTypeSlug: "30min",
      currentQuery: {},
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/first-in-org1+second-in-org1/30min",
      },
    });
  });

  it("should generate Dynamic Group Booking EventType Url with query params", async () => {
    mockARedirectInDB({
      slug: "first",
      toUrl: "https://calcom.cal.com/first-in-org1",
      redirectType: RedirectType.Team,
    });
    mockARedirectInDB({
      slug: "second",
      toUrl: "https://calcom.cal.com/second-in-org1",
      redirectType: RedirectType.Team,
    });

    const redirect = await getTemporaryOrgRedirect({
      slugs: ["first", "second"],
      redirectType: RedirectType.Team,
      eventTypeSlug: "30min",
      currentQuery: {
        abc: "1",
      },
    });

    expect(redirect).toEqual({
      redirect: {
        permanent: false,
        destination: "https://calcom.cal.com/first-in-org1+second-in-org1/30min?abc=1",
      },
    });
  });
});

export const validStatuses = ["upcoming", "recurring", "past", "cancelled", "unconfirmed"] as const;
import OtherTeamListView from "@calcom/features/ee/organizations/pages/settings/other-team-listing-view";

import PageWrapper from "@components/PageWrapper";
import type { CalPageWrapper } from "@components/PageWrapper";

const Page = OtherTeamListView as CalPageWrapper;
Page.PageWrapper = PageWrapper;

export default Page;
import TeamListView from "@calcom/features/ee/teams/pages/team-listing-view";

import PageWrapper from "@components/PageWrapper";
import type { CalPageWrapper } from "@components/PageWrapper";

const Page = TeamListView as CalPageWrapper;
Page.PageWrapper = PageWrapper;

export default Page;

export { getServerSideProps, default } from "../../../../team/[slug]/[type]";

export { getServerSideProps, default } from "../../../../team/[slug]";

export { getServerSideProps, default } from "../../team/[slug]";
import type { NextApiRequest, NextApiResponse } from "next";
import z from "zod";

import { appStoreMetadata } from "@calcom/app-store/appStoreMetaData";
import { APP_CREDENTIAL_SHARING_ENABLED } from "@calcom/lib/constants";
import { symmetricDecrypt } from "@calcom/lib/crypto";
import prisma from "@calcom/prisma";

const appCredentialWebhookRequestBodySchema = z.object({
  // UserId of the cal.com user
  userId: z.number().int(),
  appSlug: z.string(),
  // Keys should be AES256 encrypted with the CALCOM_APP_CREDENTIAL_ENCRYPTION_KEY
  keys: z.string(),
});
/** */
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (!APP_CREDENTIAL_SHARING_ENABLED) {
    return res.status(403).json({ message: "Credential sharing is not enabled" });
  }

  if (
    req.headers[process.env.CALCOM_WEBHOOK_HEADER_NAME || "calcom-webhook-secret"] !==
    process.env.CALCOM_WEBHOOK_SECRET
  ) {
    return res.status(403).json({ message: "Invalid webhook secret" });
  }

  const reqBody = appCredentialWebhookRequestBodySchema.parse(req.body);

  const user = await prisma.user.findUnique({ where: { id: reqBody.userId } });

  if (!user) {
    return res.status(404).json({ message: "User not found" });
  }

  const app = await prisma.app.findUnique({
    where: { slug: reqBody.appSlug },
    select: { dirName: true },
  });

  if (!app) {
    return res.status(404).json({ message: "App not found" });
  }

  const appMetadata = appStoreMetadata[app.dirName as keyof typeof appStoreMetadata];

  if (!appMetadata) {
    return res.status(404).json({ message: "App not found. Ensure that you have the correct app slug" });
  }

  const keys = JSON.parse(
    symmetricDecrypt(reqBody.keys, process.env.CALCOM_APP_CREDENTIAL_ENCRYPTION_KEY || "")
  );

  // INFO: Can't use prisma upsert as we don't know the id of the credential
  const appCredential = await prisma.credential.findFirst({
    where: {
      userId: reqBody.userId,
      appId: appMetadata.slug,
    },
    select: {
      id: true,
    },
  });

  if (appCredential) {
    await prisma.credential.update({
      where: {
        id: appCredential.id,
      },
      data: {
        key: keys,
      },
    });

    return res.status(200).json({ message: `Credentials updated for userId: ${reqBody.userId}` });
  } else {
    await prisma.credential.create({
      data: {
        key: keys,
        userId: reqBody.userId,
        appId: appMetadata.slug,
        type: appMetadata.type,
      },
    });

    return res.status(200).json({ message: `Credentials created for userId: ${reqBody.userId}` });
  }
}
export { default } from "@calcom/features/ee/organizations/api/subteams";
import type { WebhookTriggerEvents } from "@prisma/client";
import { createHmac } from "crypto";
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { DailyLocationType } from "@calcom/app-store/locations";
import { getDownloadLinkOfCalVideoByRecordingId } from "@calcom/core/videoClient";
import { sendDailyVideoRecordingEmails } from "@calcom/emails";
import getWebhooks from "@calcom/features/webhooks/lib/getWebhooks";
import sendPayload from "@calcom/features/webhooks/lib/sendPayload";
import { getTeamIdFromEventType } from "@calcom/lib/getTeamIdFromEventType";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import { defaultHandler } from "@calcom/lib/server";
import { getTranslation } from "@calcom/lib/server/i18n";
import prisma, { bookingMinimalSelect } from "@calcom/prisma";
import type { CalendarEvent } from "@calcom/types/Calendar";

const log = logger.getSubLogger({ prefix: ["recorded-daily-video"] });

const schema = z
  .object({
    version: z.string(),
    type: z.string(),
    id: z.string(),
    payload: z.object({
      recording_id: z.string(),
      end_ts: z.number().optional(),
      room_name: z.string(),
      start_ts: z.number().optional(),
      status: z.string(),

      max_participants: z.number().optional(),
      duration: z.number().optional(),
      s3_key: z.string().optional(),
    }),
    event_ts: z.number().optional(),
  })
  .passthrough();

const downloadLinkSchema = z.object({
  download_link: z.string(),
});

const triggerWebhook = async ({
  evt,
  downloadLink,
  booking,
}: {
  evt: CalendarEvent;
  downloadLink: string;
  booking: {
    userId: number | undefined;
    eventTypeId: number | null;
    eventTypeParentId: number | null | undefined;
    teamId?: number | null;
  };
}) => {
  const eventTrigger: WebhookTriggerEvents = "RECORDING_READY";

  // Send Webhook call if hooked to BOOKING.RECORDING_READY
  const triggerForUser = !booking.teamId || (booking.teamId && booking.eventTypeParentId);

  const subscriberOptions = {
    userId: triggerForUser ? booking.userId : null,
    eventTypeId: booking.eventTypeId,
    triggerEvent: eventTrigger,
    teamId: booking.teamId,
  };
  const webhooks = await getWebhooks(subscriberOptions);

  log.debug(
    "Webhooks:",
    safeStringify({
      webhooks,
    })
  );

  const promises = webhooks.map((webhook) =>
    sendPayload(webhook.secret, eventTrigger, new Date().toISOString(), webhook, {
      ...evt,
      downloadLink,
    }).catch((e) => {
      console.error(`Error executing webhook for event: ${eventTrigger}, URL: ${webhook.subscriberUrl}`, e);
    })
  );
  await Promise.all(promises);
};

const testRequestSchema = z.object({
  test: z.enum(["test"]),
});

async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (!process.env.SENDGRID_API_KEY || !process.env.SENDGRID_EMAIL) {
    return res.status(405).json({ message: "No SendGrid API key or email" });
  }

  if (testRequestSchema.safeParse(req.body).success) {
    return res.status(200).json({ message: "Test request successful" });
  }

  const hmacSecret = process.env.DAILY_WEBHOOK_SECRET;
  if (!hmacSecret) {
    return res.status(405).json({ message: "No Daily Webhook Secret" });
  }

  const signature = `${req.headers["x-webhook-timestamp"]}.${JSON.stringify(req.body)}`;
  const base64DecodedSecret = Buffer.from(hmacSecret, "base64");
  const hmac = createHmac("sha256", base64DecodedSecret);
  const computed_signature = hmac.update(signature).digest("base64");

  if (req.headers["x-webhook-signature"] !== computed_signature) {
    return res.status(403).json({ message: "Signature does not match" });
  }

  const response = schema.safeParse(req.body);

  log.debug(
    "Recording Request Body:",
    safeStringify({
      response,
    })
  );

  if (!response.success || response.data.type !== "recording.ready-to-download") {
    return res.status(400).send({
      message: "Invalid Payload",
    });
  }

  const { room_name, recording_id, status } = response.data.payload;

  if (status !== "finished") {
    return res.status(400).send({
      message: "Recording not finished",
    });
  }

  try {
    const bookingReference = await prisma.bookingReference.findFirst({
      where: { type: "daily_video", uid: room_name, meetingId: room_name },
      select: { bookingId: true },
    });

    if (!bookingReference || !bookingReference.bookingId) {
      log.error(
        "bookingReference:",
        safeStringify({
          bookingReference,
        })
      );
      return res.status(404).send({ message: "Booking reference not found" });
    }

    const booking = await prisma.booking.findUniqueOrThrow({
      where: {
        id: bookingReference.bookingId,
      },
      select: {
        ...bookingMinimalSelect,
        uid: true,
        location: true,
        isRecorded: true,
        eventTypeId: true,
        eventType: {
          select: {
            teamId: true,
            parentId: true,
          },
        },
        user: {
          select: {
            id: true,
            timeZone: true,
            email: true,
            name: true,
            locale: true,
            destinationCalendar: true,
          },
        },
      },
    });

    if (!booking || !(booking.location === DailyLocationType || booking?.location?.trim() === "")) {
      log.error(
        "Booking:",
        safeStringify({
          booking,
        })
      );

      return res.status(404).send({
        message: `Booking of room_name ${room_name} does not exist or does not contain daily video as location`,
      });
    }

    const t = await getTranslation(booking?.user?.locale ?? "en", "common");

    const attendeesListPromises = booking.attendees.map(async (attendee) => {
      return {
        id: attendee.id,
        name: attendee.name,
        email: attendee.email,
        timeZone: attendee.timeZone,
        language: {
          translate: await getTranslation(attendee.locale ?? "en", "common"),
          locale: attendee.locale ?? "en",
        },
      };
    });

    const attendeesList = await Promise.all(attendeesListPromises);

    await prisma.booking.update({
      where: {
        uid: booking.uid,
      },
      data: {
        isRecorded: true,
      },
    });

    const response = await getDownloadLinkOfCalVideoByRecordingId(recording_id);

    const downloadLinkResponse = downloadLinkSchema.parse(response);

    const downloadLink = downloadLinkResponse.download_link;

    const evt: CalendarEvent = {
      type: booking.title,
      title: booking.title,
      description: booking.description || undefined,
      startTime: booking.startTime.toISOString(),
      endTime: booking.endTime.toISOString(),
      organizer: {
        email: booking.user?.email || "Email-less",
        name: booking.user?.name || "Nameless",
        timeZone: booking.user?.timeZone || "Europe/London",
        language: { translate: t, locale: booking?.user?.locale ?? "en" },
      },
      attendees: attendeesList,
      uid: booking.uid,
    };

    const teamId = await getTeamIdFromEventType({
      eventType: {
        team: { id: booking?.eventType?.teamId ?? null },
        parentId: booking?.eventType?.parentId ?? null,
      },
    });

    await triggerWebhook({
      evt,
      downloadLink,
      booking: {
        userId: booking?.user?.id,
        eventTypeId: booking.eventTypeId,
        eventTypeParentId: booking.eventType?.parentId,
        teamId,
      },
    });

    // send emails to all attendees only when user has team plan
    await sendDailyVideoRecordingEmails(evt, downloadLink);

    return res.status(200).json({ message: "Success" });
  } catch (err) {
    console.error("Error in /recorded-daily-video", err);

    return res.status(500).json({ message: "something went wrong" });
  }
}

export default defaultHandler({
  POST: Promise.resolve({ default: handler }),
});
import type { NextApiRequest, NextApiResponse } from "next";

type Response = {
  message: string;
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Response>): Promise<void> {
  return res.status(400).json({ message: "Please don't" });
}
import type { NextApiRequest, NextApiResponse } from "next";

import isAuthorized from "@calcom/features/auth/lib/oAuthAuthorization";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const requiredScopes = ["READ_PROFILE"];

  const account = await isAuthorized(req, requiredScopes);

  if (!account) {
    return res.status(401).json({ message: "Unauthorized" });
  }
  return res.status(201).json({ username: account.name });
}
import jwt from "jsonwebtoken";
import type { NextApiRequest, NextApiResponse } from "next";

import prisma from "@calcom/prisma";
import { generateSecret } from "@calcom/trpc/server/routers/viewer/oAuth/addClient.handler";
import type { OAuthTokenPayload } from "@calcom/types/oauth";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") {
    res.status(405).json({ message: "Invalid method" });

    return;
  }

  const { code, client_id, client_secret, grant_type, redirect_uri } = req.body;

  if (grant_type !== "authorization_code") {
    res.status(400).json({ message: "grant_type invalid" });

    return;
  }

  const [hashedSecret] = generateSecret(client_secret);

  const client = await prisma.oAuthClient.findFirst({
    where: {
      clientId: client_id,
      clientSecret: hashedSecret,
    },
    select: {
      redirectUri: true,
    },
  });

  if (!client || client.redirectUri !== redirect_uri) {
    res.status(401).json({ message: "Unauthorized" });

    return;
  }

  const accessCode = await prisma.accessCode.findFirst({
    where: {
      code: code,
      clientId: client_id,
      expiresAt: {
        gt: new Date(),
      },
    },
  });

  //delete all expired accessCodes + the one that is used here
  await prisma.accessCode.deleteMany({
    where: {
      OR: [
        {
          expiresAt: {
            lt: new Date(),
          },
        },
        {
          code: code,
          clientId: client_id,
        },
      ],
    },
  });

  if (!accessCode) {
    res.status(401).json({ message: "Unauthorized" });

    return;
  }

  const secretKey = process.env.CALENDSO_ENCRYPTION_KEY || "";

  const payloadAuthToken: OAuthTokenPayload = {
    userId: accessCode.userId,
    teamId: accessCode.teamId,
    scope: accessCode.scopes,
    token_type: "Access Token",
    clientId: client_id,
  };

  const payloadRefreshToken: OAuthTokenPayload = {
    userId: accessCode.userId,
    teamId: accessCode.teamId,
    scope: accessCode.scopes,
    token_type: "Refresh Token",
    clientId: client_id,
  };

  const access_token = jwt.sign(payloadAuthToken, secretKey, {
    expiresIn: 1800, // 30 min
  });

  const refresh_token = jwt.sign(payloadRefreshToken, secretKey, {
    expiresIn: 30 * 24 * 60 * 60, // 30 days
  });

  res.status(200).json({ access_token, refresh_token });
}
import jwt from "jsonwebtoken";
import type { NextApiRequest, NextApiResponse } from "next";

import prisma from "@calcom/prisma";
import { generateSecret } from "@calcom/trpc/server/routers/viewer/oAuth/addClient.handler";
import type { OAuthTokenPayload } from "@calcom/types/oauth";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") {
    res.status(405).json({ message: "Invalid method" });

    return;
  }

  const refreshToken = req.headers.authorization?.split(" ")[1] || "";

  const { client_id, client_secret, grant_type } = req.body;

  if (grant_type !== "refresh_token") {
    res.status(400).json({ message: "grant type invalid" });

    return;
  }

  const [hashedSecret] = generateSecret(client_secret);

  const client = await prisma.oAuthClient.findFirst({
    where: {
      clientId: client_id,
      clientSecret: hashedSecret,
    },
    select: {
      redirectUri: true,
    },
  });

  if (!client) {
    res.status(401).json({ message: "Unauthorized" });

    return;
  }

  const secretKey = process.env.CALENDSO_ENCRYPTION_KEY || "";

  let decodedRefreshToken: OAuthTokenPayload;

  try {
    decodedRefreshToken = jwt.verify(refreshToken, secretKey) as OAuthTokenPayload;
  } catch {
    res.status(401).json({ message: "Unauthorized" });

    return;
  }

  if (!decodedRefreshToken || decodedRefreshToken.token_type !== "Refresh Token") {
    res.status(401).json({ message: "Unauthorized" });

    return;
  }

  const payload: OAuthTokenPayload = {
    userId: decodedRefreshToken.userId,
    teamId: decodedRefreshToken.teamId,
    scope: decodedRefreshToken.scope,
    token_type: "Access Token",
    clientId: client_id,
  };

  const access_token = jwt.sign(payload, secretKey, {
    expiresIn: 1800, // 30 min
  });

  res.status(200).json({ access_token });
}
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import dayjs from "@calcom/dayjs";
import { WEBAPP_URL } from "@calcom/lib/constants";
import { prisma } from "@calcom/prisma";

const verifySchema = z.object({
  token: z.string(),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { token } = verifySchema.parse(req.query);

  const foundToken = await prisma.verificationToken.findFirst({
    where: {
      token,
    },
  });

  if (!foundToken) {
    return res.status(401).json({ message: "No token found" });
  }

  if (dayjs(foundToken?.expires).isBefore(dayjs())) {
    return res.status(401).json({ message: "Token expired" });
  }

  const user = await prisma.user.update({
    where: {
      email: foundToken?.identifier,
    },
    data: {
      emailVerified: new Date(),
    },
  });

  // Delete token from DB after it has been used
  await prisma.verificationToken.delete({
    where: {
      id: foundToken?.id,
    },
  });

  const hasCompletedOnboarding = user.completedOnboarding;

  res.redirect(`${WEBAPP_URL}/${hasCompletedOnboarding ? "/event-types" : "/getting-started"}`);
}
import type { NextApiRequest, NextApiResponse } from "next";

import { ErrorCode } from "@calcom/features/auth/lib/ErrorCode";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { hashPassword } from "@calcom/features/auth/lib/hashPassword";
import { verifyPassword } from "@calcom/features/auth/lib/verifyPassword";
import prisma from "@calcom/prisma";
import { IdentityProvider } from "@calcom/prisma/enums";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const session = await getServerSession({ req, res });

  if (!session || !session.user || !session.user.email) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }

  const user = await prisma.user.findFirst({
    where: {
      email: session.user.email,
    },
    select: {
      id: true,
      password: true,
      identityProvider: true,
    },
  });

  if (!user) {
    res.status(404).json({ message: "User not found" });

    return;
  }

  if (user.identityProvider !== IdentityProvider.CAL) {
    return res.status(400).json({ error: ErrorCode.ThirdPartyIdentityProviderEnabled });
  }

  const oldPassword = req.body.oldPassword;
  const newPassword = req.body.newPassword;

  const currentPassword = user.password;
  if (!currentPassword) {
    return res.status(400).json({ error: ErrorCode.UserMissingPassword });
  }

  const passwordsMatch = await verifyPassword(oldPassword, currentPassword);
  if (!passwordsMatch) {
    return res.status(403).json({ error: ErrorCode.IncorrectPassword });
  }

  if (oldPassword === newPassword) {
    return res.status(400).json({ error: ErrorCode.NewPasswordMatchesOld });
  }

  const hashedPassword = await hashPassword(newPassword);
  await prisma.user.update({
    where: {
      id: user.id,
    },
    data: {
      password: hashedPassword,
    },
  });

  res.status(200).json({ message: "Password updated successfully" });
}
import type { NextApiRequest } from "next";
import z from "zod";

import { hashPassword } from "@calcom/features/auth/lib/hashPassword";
import { isPasswordValid } from "@calcom/features/auth/lib/isPasswordValid";
import { HttpError } from "@calcom/lib/http-error";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";
import slugify from "@calcom/lib/slugify";
import prisma from "@calcom/prisma";
import { IdentityProvider } from "@calcom/prisma/enums";

const querySchema = z.object({
  username: z
    .string()
    .refine((val) => val.trim().length >= 1, { message: "Please enter at least one character" }),
  full_name: z.string().min(3, "Please enter at least 3 characters"),
  email_address: z.string().email({ message: "Please enter a valid email" }),
  password: z.string().refine((val) => isPasswordValid(val.trim(), false, true), {
    message:
      "The password must be a minimum of 15 characters long containing at least one number and have a mixture of uppercase and lowercase letters",
  }),
});

async function handler(req: NextApiRequest) {
  const userCount = await prisma.user.count();
  if (userCount !== 0) {
    throw new HttpError({ statusCode: 400, message: "No setup needed." });
  }

  const parsedQuery = querySchema.safeParse(req.body);
  if (!parsedQuery.success) {
    throw new HttpError({ statusCode: 422, message: parsedQuery.error.message });
  }

  const username = slugify(parsedQuery.data.username.trim());
  const userEmail = parsedQuery.data.email_address.toLowerCase();

  const hashedPassword = await hashPassword(parsedQuery.data.password);

  await prisma.user.create({
    data: {
      username,
      email: userEmail,
      password: hashedPassword,
      role: "ADMIN",
      name: parsedQuery.data.full_name,
      emailVerified: new Date(),
      locale: "en", // TODO: We should revisit this
      identityProvider: IdentityProvider.CAL,
    },
  });

  return { message: "First admin user created successfully." };
}

export default defaultHandler({
  POST: Promise.resolve({ default: defaultResponder(handler) }),
});
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { passwordResetRequest } from "@calcom/features/auth/lib/passwordResetRequest";
import { checkRateLimitAndThrowError } from "@calcom/lib/checkRateLimitAndThrowError";
import { defaultHandler } from "@calcom/lib/server";
import prisma from "@calcom/prisma";

async function handler(req: NextApiRequest, res: NextApiResponse) {
  const email = z
    .string()
    .email()
    .transform((val) => val.toLowerCase())
    .safeParse(req.body?.email);

  if (!email.success) {
    return res.status(400).json({ message: "email is required" });
  }

  // fallback to email if ip is not present
  let ip = (req.headers["x-real-ip"] as string) ?? email.data;

  const forwardedFor = req.headers["x-forwarded-for"] as string;
  if (!ip && forwardedFor) {
    ip = forwardedFor?.split(",").at(0) ?? email.data;
  }

  // 10 requests per minute

  await checkRateLimitAndThrowError({
    rateLimitingType: "core",
    identifier: ip,
  });

  try {
    const user = await prisma.user.findUnique({
      where: { email: email.data },
      select: { name: true, email: true, locale: true },
    });
    // Don't leak info about whether the user exists
    if (!user) return res.status(201).json({ message: "password_reset_email_sent" });
    await passwordResetRequest(user);

    return res.status(201).json({ message: "password_reset_email_sent" });
  } catch (reason) {
    console.error(reason);

    return res.status(500).json({ message: "Unable to create password reset request" });
  }
}

export default defaultHandler({
  POST: Promise.resolve({ default: handler }),
});
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { hashPassword } from "@calcom/features/auth/lib/hashPassword";
import { validPassword } from "@calcom/features/auth/lib/validPassword";
import prisma from "@calcom/prisma";

const passwordResetRequestSchema = z.object({
  password: z.string().refine(validPassword, () => ({
    message: "Password does not meet the requirements",
  })),
  requestId: z.string(), // format doesn't matter.
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Bad Method when not POST
  if (req.method !== "POST") return res.status(405).end();

  const { password: rawPassword, requestId: rawRequestId } = passwordResetRequestSchema.parse(req.body);
  // rate-limited there is a low, very low chance that a password request stays valid long enough
  // to brute force 3.8126967e+40 options.
  const maybeRequest = await prisma.resetPasswordRequest.findFirstOrThrow({
    where: {
      id: rawRequestId,
      expires: {
        gt: new Date(),
      },
    },
    select: {
      email: true,
    },
  });

  const hashedPassword = await hashPassword(rawPassword);
  // this can fail if a password request has been made for an email that has since changed or-
  // never existed within Cal. In this case we do not want to disclose the email's existence.
  // instead, we just return 404
  try {
    await prisma.user.update({
      where: {
        email: maybeRequest.email,
      },
      data: {
        password: hashedPassword,
      },
    });
  } catch (e) {
    return res.status(404).end();
  }

  await expireResetPasswordRequest(rawRequestId);

  return res.status(201).json({ message: "Password reset." });
}

async function expireResetPasswordRequest(rawRequestId: string) {
  await prisma.resetPasswordRequest.update({
    where: {
      id: rawRequestId,
    },
    data: {
      // We set the expiry to now to invalidate the request
      expires: new Date(),
    },
  });
}
import type { NextApiResponse } from "next";

import calcomSignupHandler from "@calcom/feature-auth/signup/handlers/calcomHandler";
import selfHostedSignupHandler from "@calcom/feature-auth/signup/handlers/selfHostedHandler";
import { type RequestWithUsernameStatus } from "@calcom/features/auth/signup/username";
import { IS_PREMIUM_USERNAME_ENABLED } from "@calcom/lib/constants";
import { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { signupSchema } from "@calcom/prisma/zod-utils";

function ensureSignupIsEnabled(req: RequestWithUsernameStatus) {
  const { token } = signupSchema
    .pick({
      token: true,
    })
    .parse(req.body);

  // Stil allow signups if there is a team invite
  if (token) return;

  if (process.env.NEXT_PUBLIC_DISABLE_SIGNUP === "true") {
    throw new HttpError({
      statusCode: 403,
      message: "Signup is disabled",
    });
  }
}

function ensureReqIsPost(req: RequestWithUsernameStatus) {
  if (req.method !== "POST") {
    throw new HttpError({
      statusCode: 405,
      message: "Method not allowed",
    });
  }
}

export default async function handler(req: RequestWithUsernameStatus, res: NextApiResponse) {
  // Use a try catch instead of returning res every time
  try {
    ensureReqIsPost(req);
    ensureSignupIsEnabled(req);

    /**
     * Im not sure its worth merging these two handlers. They are different enough to be separate.
     * Calcom handles things like creating a stripe customer - which we don't need to do for self hosted.
     * It also handles things like premium username.
     * TODO: (SEAN) - Extract a lot of the logic from calcomHandler into a separate file and import it into both handlers.
     * @zomars: We need to be able to test this with E2E. They way it's done RN it will never run on CI.
     */
    if (IS_PREMIUM_USERNAME_ENABLED) {
      return await calcomSignupHandler(req, res);
    }

    return await selfHostedSignupHandler(req, res);
  } catch (e) {
    if (e instanceof HttpError) {
      return res.status(e.statusCode).json({ message: e.message });
    }
    logger.error(e);

    return res.status(500).json({ message: "Internal server error" });
  }
}
import type { NextApiRequest, NextApiResponse } from "next";

import { ErrorCode } from "@calcom/features/auth/lib/ErrorCode";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { symmetricDecrypt } from "@calcom/lib/crypto";
import { totpAuthenticatorCheck } from "@calcom/lib/totp";
import prisma from "@calcom/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const session = await getServerSession({ req, res });
  if (!session) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  if (!session.user?.id) {
    console.error("Session is missing a user id.");

    return res.status(500).json({ error: ErrorCode.InternalServerError });
  }

  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user) {
    console.error(`Session references user that no longer exists.`);

    return res.status(401).json({ message: "Not authenticated" });
  }

  if (user.twoFactorEnabled) {
    return res.status(400).json({ error: ErrorCode.TwoFactorAlreadyEnabled });
  }

  if (!user.twoFactorSecret) {
    return res.status(400).json({ error: ErrorCode.TwoFactorSetupRequired });
  }

  if (!process.env.CALENDSO_ENCRYPTION_KEY) {
    console.error("Missing encryption key; cannot proceed with two factor setup.");

    return res.status(500).json({ error: ErrorCode.InternalServerError });
  }

  const secret = symmetricDecrypt(user.twoFactorSecret, process.env.CALENDSO_ENCRYPTION_KEY);
  if (secret.length !== 32) {
    console.error(
      `Two factor secret decryption failed. Expected key with length 32 but got ${secret.length}`
    );

    return res.status(500).json({ error: ErrorCode.InternalServerError });
  }

  const isValidToken = totpAuthenticatorCheck(req.body.code, secret);
  if (!isValidToken) {
    return res.status(400).json({ error: ErrorCode.IncorrectTwoFactorCode });
  }

  await prisma.user.update({
    where: {
      id: session.user.id,
    },
    data: {
      twoFactorEnabled: true,
    },
  });

  return res.json({ message: "Two-factor enabled" });
}
import type { NextApiRequest, NextApiResponse } from "next";

import { ErrorCode } from "@calcom/features/auth/lib/ErrorCode";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { verifyPassword } from "@calcom/features/auth/lib/verifyPassword";
import { symmetricDecrypt } from "@calcom/lib/crypto";
import { totpAuthenticatorCheck } from "@calcom/lib/totp";
import prisma from "@calcom/prisma";
import { IdentityProvider } from "@calcom/prisma/client";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const session = await getServerSession({ req, res });
  if (!session) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  if (!session.user?.id) {
    console.error("Session is missing a user id.");

    return res.status(500).json({ error: ErrorCode.InternalServerError });
  }

  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user) {
    console.error(`Session references user that no longer exists.`);

    return res.status(401).json({ message: "Not authenticated" });
  }

  if (!user.password && user.identityProvider === IdentityProvider.CAL) {
    return res.status(400).json({ error: ErrorCode.UserMissingPassword });
  }

  if (!user.twoFactorEnabled) {
    return res.json({ message: "Two factor disabled" });
  }

  if (user.password && user.identityProvider === IdentityProvider.CAL) {
    const isCorrectPassword = await verifyPassword(req.body.password, user.password);

    if (!isCorrectPassword) {
      return res.status(400).json({ error: ErrorCode.IncorrectPassword });
    }
  }

  // if user has 2fa and using backup code
  if (user.twoFactorEnabled && req.body.backupCode) {
    if (!process.env.CALENDSO_ENCRYPTION_KEY) {
      console.error("Missing encryption key; cannot proceed with backup code login.");
      throw new Error(ErrorCode.InternalServerError);
    }

    if (!user.backupCodes) {
      return res.status(400).json({ error: ErrorCode.MissingBackupCodes });
    }

    const backupCodes = JSON.parse(symmetricDecrypt(user.backupCodes, process.env.CALENDSO_ENCRYPTION_KEY));

    // check if user-supplied code matches one
    const index = backupCodes.indexOf(req.body.backupCode.replaceAll("-", ""));

    if (index === -1) {
      return res.status(400).json({ error: ErrorCode.IncorrectBackupCode });
    }

    // we delete all stored backup codes at the end, no need to do this here

    // if user has 2fa and NOT using backup code, try totp
  } else if (user.twoFactorEnabled) {
    if (!req.body.code) {
      return res.status(400).json({ error: ErrorCode.SecondFactorRequired });
      // throw new Error(ErrorCode.SecondFactorRequired);
    }

    if (!user.twoFactorSecret) {
      console.error(`Two factor is enabled for user ${user.id} but they have no secret`);
      throw new Error(ErrorCode.InternalServerError);
    }

    if (!process.env.CALENDSO_ENCRYPTION_KEY) {
      console.error(`"Missing encryption key; cannot proceed with two factor login."`);
      throw new Error(ErrorCode.InternalServerError);
    }

    const secret = symmetricDecrypt(user.twoFactorSecret, process.env.CALENDSO_ENCRYPTION_KEY);

    if (secret.length !== 32) {
      console.error(
        `Two factor secret decryption failed. Expected key with length 32 but got ${secret.length}`
      );
      throw new Error(ErrorCode.InternalServerError);
    }

    // If user has 2fa enabled, check if body.code is correct
    const isValidToken = totpAuthenticatorCheck(req.body.code, secret);

    if (!isValidToken) {
      return res.status(400).json({ error: ErrorCode.IncorrectTwoFactorCode });

      // throw new Error(ErrorCode.IncorrectTwoFactorCode);
    }
  }
  // If it is, disable users 2fa
  await prisma.user.update({
    where: {
      id: session.user.id,
    },
    data: {
      backupCodes: null,
      twoFactorEnabled: false,
      twoFactorSecret: null,
    },
  });

  return res.json({ message: "Two factor disabled" });
}
import crypto from "crypto";
import type { NextApiRequest, NextApiResponse } from "next";
import { authenticator } from "otplib";
import qrcode from "qrcode";

import { ErrorCode } from "@calcom/features/auth/lib/ErrorCode";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { verifyPassword } from "@calcom/features/auth/lib/verifyPassword";
import { symmetricEncrypt } from "@calcom/lib/crypto";
import prisma from "@calcom/prisma";
import { IdentityProvider } from "@calcom/prisma/enums";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const session = await getServerSession({ req, res });
  if (!session) {
    return res.status(401).json({ message: "Not authenticated" });
  }

  if (!session.user?.id) {
    console.error("Session is missing a user id.");

    return res.status(500).json({ error: ErrorCode.InternalServerError });
  }

  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user) {
    console.error(`Session references user that no longer exists.`);

    return res.status(401).json({ message: "Not authenticated" });
  }

  if (user.identityProvider !== IdentityProvider.CAL) {
    return res.status(400).json({ error: ErrorCode.ThirdPartyIdentityProviderEnabled });
  }

  if (!user.password) {
    return res.status(400).json({ error: ErrorCode.UserMissingPassword });
  }

  if (user.twoFactorEnabled) {
    return res.status(400).json({ error: ErrorCode.TwoFactorAlreadyEnabled });
  }

  if (!process.env.CALENDSO_ENCRYPTION_KEY) {
    console.error("Missing encryption key; cannot proceed with two factor setup.");

    return res.status(500).json({ error: ErrorCode.InternalServerError });
  }

  const isCorrectPassword = await verifyPassword(req.body.password, user.password);
  if (!isCorrectPassword) {
    return res.status(400).json({ error: ErrorCode.IncorrectPassword });
  }

  // This generates a secret 32 characters in length. Do not modify the number of
  // bytes without updating the sanity checks in the enable and login endpoints.
  const secret = authenticator.generateSecret(20);

  // generate backup codes with 10 character length
  const backupCodes = Array.from(Array(10), () => crypto.randomBytes(5).toString("hex"));

  await prisma.user.update({
    where: {
      id: session.user.id,
    },
    data: {
      backupCodes: symmetricEncrypt(JSON.stringify(backupCodes), process.env.CALENDSO_ENCRYPTION_KEY),
      twoFactorEnabled: false,
      twoFactorSecret: symmetricEncrypt(secret, process.env.CALENDSO_ENCRYPTION_KEY),
    },
  });

  const name = user.email || user.username || user.id.toString();
  const keyUri = authenticator.keyuri(name, "Cal", secret);
  const dataUri = await qrcode.toDataURL(keyUri);

  return res.json({ secret, keyUri, dataUri, backupCodes });
}
import type { NextApiRequest, NextApiResponse } from "next";

import jackson from "@calcom/features/ee/sso/lib/jackson";
import { HttpError } from "@calcom/lib/http-error";

// This is the callback endpoint for the OIDC provider
// A team must set this endpoint in the OIDC provider's configuration
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "GET") {
    return res.status(400).send("Method not allowed");
  }

  const { code, state } = req.query as {
    code: string;
    state: string;
  };

  const { oauthController } = await jackson();

  try {
    const { redirect_url } = await oauthController.oidcAuthzResponse({ code, state });

    if (!redirect_url) {
      throw new HttpError({
        message: "No redirect URL found",
        statusCode: 500,
      });
    }

    return res.redirect(302, redirect_url);
  } catch (err) {
    const { message, statusCode = 500 } = err as HttpError;

    return res.status(statusCode).send(message);
  }
}
import type { NextApiRequest } from "next";
import z from "zod";

import jackson from "@calcom/features/ee/sso/lib/jackson";
import { HttpError } from "@calcom/lib/http-error";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";

const extractAuthToken = (req: NextApiRequest) => {
  const authHeader = req.headers["authorization"];
  const parts = (authHeader || "").split(" ");
  if (parts.length > 1) return parts[1];

  // check for query param
  let arr: string[] = [];
  const { access_token } = requestQuery.parse(req.query);
  arr = arr.concat(access_token);
  if (arr[0].length > 0) return arr[0];

  throw new HttpError({ statusCode: 401, message: "Unauthorized" });
};

const requestQuery = z.object({
  access_token: z.string(),
});

async function getHandler(req: NextApiRequest) {
  const { oauthController } = await jackson();
  const token = extractAuthToken(req);
  return await oauthController.userInfo(token);
}

export default defaultHandler({
  GET: Promise.resolve({ default: defaultResponder(getHandler) }),
});
import type { OAuthReq } from "@boxyhq/saml-jackson";
import type { NextApiRequest, NextApiResponse } from "next";

import jackson from "@calcom/features/ee/sso/lib/jackson";
import type { HttpError } from "@calcom/lib/http-error";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { oauthController } = await jackson();

  if (req.method !== "GET") {
    return res.status(400).send("Method not allowed");
  }

  try {
    const { redirect_url } = await oauthController.authorize(req.query as unknown as OAuthReq);

    return res.redirect(302, redirect_url as string);
  } catch (err) {
    const { message, statusCode = 500 } = err as HttpError;

    return res.status(statusCode).send(message);
  }
}
import type { NextApiRequest } from "next";

import jackson from "@calcom/features/ee/sso/lib/jackson";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";

async function postHandler(req: NextApiRequest) {
  const { oauthController } = await jackson();
  return await oauthController.token(req.body);
}

export default defaultHandler({
  POST: Promise.resolve({ default: defaultResponder(postHandler) }),
});
import type { NextApiRequest, NextApiResponse } from "next";

import jackson from "@calcom/features/ee/sso/lib/jackson";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";

async function postHandler(req: NextApiRequest, res: NextApiResponse) {
  const { oauthController } = await jackson();

  const { redirect_url } = await oauthController.samlResponse(req.body);

  if (redirect_url) {
    res.redirect(302, redirect_url);
  }
}

export default defaultHandler({
  POST: Promise.resolve({ default: defaultResponder(postHandler) }),
});
import { getFormSchema } from "@pages/settings/admin/orgMigrations/moveTeamToOrg";
import type { NextApiRequest, NextApiResponse } from "next/types";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import { getTranslation } from "@calcom/lib/server";
import { UserPermissionRole } from "@calcom/prisma/enums";

import { moveTeamToOrg } from "../../../lib/orgMigration";

const log = logger.getSubLogger({ prefix: ["moveTeamToOrg"] });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const rawBody = req.body;

  log.debug(
    "Moving team to org:",
    safeStringify({
      body: rawBody,
    })
  );

  const translate = await getTranslation("en", "common");
  const moveTeamToOrgSchema = getFormSchema(translate);

  const parsedBody = moveTeamToOrgSchema.safeParse(rawBody);

  const session = await getServerSession({ req, res });

  if (!session) {
    return res.status(403).json({ message: "No session found" });
  }

  const isAdmin = session.user.role === UserPermissionRole.ADMIN;

  if (!parsedBody.success) {
    log.error("moveTeamToOrg failed:", safeStringify(parsedBody.error));

    return res.status(400).json({ message: JSON.stringify(parsedBody.error) });
  }

  const { teamId, targetOrgId, moveMembers, teamSlugInOrganization } = parsedBody.data;
  const isAllowed = isAdmin;
  if (!isAllowed) {
    return res.status(403).json({ message: "Not Authorized" });
  }

  try {
    await moveTeamToOrg({
      targetOrg: {
        id: targetOrgId,
        teamSlug: teamSlugInOrganization,
      },
      teamId,
      moveMembers,
    });
  } catch (error) {
    if (error instanceof HttpError) {
      if (error.statusCode > 300) {
        log.error("moveTeamToOrg failed:", safeStringify(error.message));
      }
      return res.status(error.statusCode).json({ message: error.message });
    }
    log.error("moveTeamToOrg failed:", safeStringify(error));

    const errorMessage = error instanceof Error ? error.message : "Something went wrong";

    return res.status(500).json({ message: errorMessage });
  }

  return res.status(200).json({
    message: `Added team ${teamId} to Org: ${targetOrgId} ${
      moveMembers ? " along with the members" : " without the members"
    }`,
  });
}
import { getFormSchema } from "@pages/settings/admin/orgMigrations/removeUserFromOrg";
import type { NextApiRequest, NextApiResponse } from "next/types";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import { getTranslation } from "@calcom/lib/server";
import { UserPermissionRole } from "@calcom/prisma/enums";

import { removeUserFromOrg } from "../../../lib/orgMigration";

const log = logger.getSubLogger({ prefix: ["removeUserFromOrg"] });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const body = req.body;

  log.debug(
    "Starting reverse migration:",
    safeStringify({
      body,
    })
  );

  const translate = await getTranslation("en", "common");
  const migrateRevertBodySchema = getFormSchema(translate);
  const parsedBody = migrateRevertBodySchema.safeParse(body);
  const session = await getServerSession({ req });

  if (!session) {
    return res.status(403).json({ message: "No session found" });
  }

  const isAdmin = session.user.role === UserPermissionRole.ADMIN;
  if (!isAdmin) {
    return res.status(403).json({ message: "Only admin can take this action" });
  }

  if (parsedBody.success) {
    const { userId, targetOrgId } = parsedBody.data;

    try {
      await removeUserFromOrg({ targetOrgId, userId });
    } catch (error) {
      if (error instanceof HttpError) {
        if (error.statusCode > 300) {
          log.error("Reverse migration failed:", safeStringify(error));
        }
        return res.status(error.statusCode).json({ message: error.message });
      }
      log.error("Reverse migration failed:", safeStringify(error));
      const errorMessage = error instanceof Error ? error.message : "Something went wrong";

      return res.status(500).json({ message: errorMessage });
    }
    return res.status(200).json({ message: "Reverted" });
  }
  log.error("Reverse Migration failed:", safeStringify(parsedBody.error));
  return res.status(400).json({ message: JSON.stringify(parsedBody.error) });
}
import { getFormSchema } from "@pages/settings/admin/orgMigrations/removeTeamFromOrg";
import type { NextApiRequest, NextApiResponse } from "next/types";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import { getTranslation } from "@calcom/lib/server";
import { UserPermissionRole } from "@calcom/prisma/enums";

import { removeTeamFromOrg } from "../../../lib/orgMigration";

const log = logger.getSubLogger({ prefix: ["removeTeamFromOrg"] });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const rawBody = req.body;
  const translate = await getTranslation("en", "common");
  const removeTeamFromOrgSchema = getFormSchema(translate);
  log.debug(
    "Removing team from org:",
    safeStringify({
      body: rawBody,
    })
  );
  const parsedBody = removeTeamFromOrgSchema.safeParse(rawBody);

  const session = await getServerSession({ req });

  if (!session) {
    return res.status(403).json({ message: "No session found" });
  }

  const isAdmin = session.user.role === UserPermissionRole.ADMIN;

  if (!parsedBody.success) {
    log.error("RemoveTeamFromOrg failed:", safeStringify(parsedBody.error));

    return res.status(400).json({ message: JSON.stringify(parsedBody.error) });
  }
  const { teamId, targetOrgId } = parsedBody.data;
  const isAllowed = isAdmin;
  if (!isAllowed) {
    return res.status(403).json({ message: "Not Authorized" });
  }

  try {
    await removeTeamFromOrg({
      targetOrgId,
      teamId,
    });
  } catch (error) {
    if (error instanceof HttpError) {
      if (error.statusCode > 300) {
        log.error("RemoveTeamFromOrg failed:", safeStringify(error));
      }
      return res.status(error.statusCode).json({ message: error.message });
    }
    log.error("RemoveTeamFromOrg failed:", safeStringify(error));

    const errorMessage = error instanceof Error ? error.message : "Something went wrong";

    return res.status(500).json({ message: errorMessage });
  }

  return res.status(200).json({ message: `Removed team ${teamId} from ${targetOrgId}` });
}
import { getFormSchema } from "@pages/settings/admin/orgMigrations/moveUserToOrg";
import type { NextApiRequest, NextApiResponse } from "next/types";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { HttpError } from "@calcom/lib/http-error";
import logger from "@calcom/lib/logger";
import { safeStringify } from "@calcom/lib/safeStringify";
import { getTranslation } from "@calcom/lib/server";
import { UserPermissionRole } from "@calcom/prisma/enums";

import { moveUserToOrg } from "../../../lib/orgMigration";

const log = logger.getSubLogger({ prefix: ["moveUserToOrg"] });

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const rawBody = req.body;
  const translate = await getTranslation("en", "common");
  const migrateBodySchema = getFormSchema(translate);
  log.debug(
    "Starting migration:",
    safeStringify({
      body: rawBody,
    })
  );
  const parsedBody = migrateBodySchema.safeParse(rawBody);

  const session = await getServerSession({ req });

  if (!session) {
    res.status(403).json({ message: "No session found" });

    return;
  }

  const isAdmin = session.user.role === UserPermissionRole.ADMIN;

  if (parsedBody.success) {
    const { userId, userName, shouldMoveTeams, targetOrgId, targetOrgUsername, targetOrgRole } =
      parsedBody.data;

    const isAllowed = isAdmin;

    if (isAllowed) {
      try {
        await moveUserToOrg({
          targetOrg: {
            id: targetOrgId,
            username: targetOrgUsername,
            membership: {
              role: targetOrgRole,
            },
          },
          user: {
            id: userId,
            userName,
          },
          shouldMoveTeams,
        });
      } catch (error) {
        if (error instanceof HttpError) {
          if (error.statusCode > 300) {
            log.error("Migration failed:", safeStringify(error));
          }
          return res.status(error.statusCode).json({ message: error.message });
        }
        log.error("Migration failed:", safeStringify(error));

        const errorMessage = error instanceof Error ? error.message : "Something went wrong";

        return res.status(400).json({ message: errorMessage });
      }
    } else {
      return res.status(403).json({ message: "Not Authorized" });
    }
    return res.status(200).json({ message: "Migrated" });
  }
  log.error("Migration failed:", safeStringify(parsedBody.error));
  return res.status(400).json({ message: JSON.stringify(parsedBody.error) });
}
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { webhookRouter } from "@calcom/trpc/server/routers/viewer/webhook/_router";

export default createNextApiHandler(webhookRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { viewerOrganizationsRouter } from "@calcom/trpc/server/routers/viewer/organizations/_router";

export default createNextApiHandler(viewerOrganizationsRouter);
import { insightsRouter } from "@calcom/features/insights/server/trpc-router";
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";

export default createNextApiHandler(insightsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { googleWorkspaceRouter } from "@calcom/trpc/server/routers/viewer/googleWorkspace/_router";

export default createNextApiHandler(googleWorkspaceRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { paymentsRouter } from "@calcom/trpc/server/routers/viewer/payments/_router";

export default createNextApiHandler(paymentsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { oAuthRouter } from "@calcom/trpc/server/routers/viewer/oAuth/_router";

export default createNextApiHandler(oAuthRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { bookingsRouter } from "@calcom/trpc/server/routers/viewer/bookings/_router";

export default createNextApiHandler(bookingsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { authRouter } from "@calcom/trpc/server/routers/viewer/auth/_router";

export default createNextApiHandler(authRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { appsRouter } from "@calcom/trpc/server/routers/viewer/apps/_router";

export default createNextApiHandler(appsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { apiKeysRouter } from "@calcom/trpc/server/routers/viewer/apiKeys/_router";

export default createNextApiHandler(apiKeysRouter);
import { featureFlagRouter } from "@calcom/features/flags/server/router";
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";

export default createNextApiHandler(featureFlagRouter, true, "features");
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { adminRouter } from "@calcom/trpc/server/routers/viewer/admin/_router";

export default createNextApiHandler(adminRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { workflowsRouter } from "@calcom/trpc/server/routers/viewer/workflows/_router";

export default createNextApiHandler(workflowsRouter);
import appBasecamp3 from "@calcom/app-store/basecamp3/trpc-router";
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";

export default createNextApiHandler(appBasecamp3);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { loggedInViewerRouter } from "@calcom/trpc/server/routers/loggedInViewer/_router";

export default createNextApiHandler(loggedInViewerRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { publicViewerRouter } from "@calcom/trpc/server/routers/publicViewer/_router";

export default createNextApiHandler(publicViewerRouter, true);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { deploymentSetupRouter } from "@calcom/trpc/server/routers/viewer/deploymentSetup/_router";

export default createNextApiHandler(deploymentSetupRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { eventTypesRouter } from "@calcom/trpc/server/routers/viewer/eventTypes/_router";

export default createNextApiHandler(eventTypesRouter);
import { userAdminRouter } from "@calcom/features/ee/users/server/trpc-router";
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";

export default createNextApiHandler(userAdminRouter);
import appRoutingForms from "@calcom/app-store/routing-forms/trpc-router";
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";

export default createNextApiHandler(appRoutingForms);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { viewerTeamsRouter } from "@calcom/trpc/server/routers/viewer/teams/_router";

export default createNextApiHandler(viewerTeamsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { availabilityRouter } from "@calcom/trpc/server/routers/viewer/availability/_router";

export default createNextApiHandler(availabilityRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { appsRouter } from "@calcom/trpc/server/routers/viewer/apps/_router";

export default createNextApiHandler(appsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { slotsRouter } from "@calcom/trpc/server/routers/viewer/slots/_router";

export default createNextApiHandler(slotsRouter);
import { createNextApiHandler } from "@calcom/trpc/server/createNextApiHandler";
import { ssoRouter } from "@calcom/trpc/server/routers/viewer/sso/_router";

export default createNextApiHandler(ssoRouter);
import { collectApiHandler } from "next-collect/server";

import { extendEventData, nextCollectBasicSettings } from "@calcom/lib/telemetry";

export default collectApiHandler({
  ...nextCollectBasicSettings,
  cookieName: "__clnds",
  extend: extendEventData,
});
import type { NextApiRequest, NextApiResponse } from "next";

import { renderEmail } from "@calcom/emails";
import { IS_PRODUCTION } from "@calcom/lib/constants";
import { getTranslation } from "@calcom/lib/server/i18n";

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  if (IS_PRODUCTION) return res.write("Only for development purposes"), res.end();
  const t = await getTranslation("en", "common");

  res.statusCode = 200;

  res.setHeader("Content-Type", "text/html");
  res.setHeader("Cache-Control", "no-cache, no-store, private, must-revalidate");
  res.write(
    await renderEmail("MonthlyDigestEmail", {
      language: t,
      Created: 12,
      Completed: 13,
      Rescheduled: 14,
      Cancelled: 16,
      mostBookedEvents: [
        {
          eventTypeId: 3,
          eventTypeName: "Test1",
          count: 3,
        },
        {
          eventTypeId: 4,
          eventTypeName: "Test2",
          count: 5,
        },
      ],
      membersWithMostBookings: [
        {
          userId: 4,
          user: {
            id: 4,
            name: "User1 name",
            email: "email.com",
            avatar: "none",
            username: "User1",
          },
          count: 4,
        },
        {
          userId: 6,
          user: {
            id: 6,
            name: "User2 name",
            email: "email2.com",
            avatar: "none",
            username: "User2",
          },
          count: 8,
        },
      ],
      admin: { email: "admin.com", name: "admin" },
      team: { name: "Team1", id: 4 },
    })
  );
  res.end();
};

export default handler;
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import {
  orgDomainConfig,
  whereClauseForOrgWithSlugOrRequestedSlug,
} from "@calcom/features/ee/organizations/lib/orgDomains";
import { AVATAR_FALLBACK } from "@calcom/lib/constants";
import { getPlaceholderAvatar } from "@calcom/lib/defaultAvatarImage";
import logger from "@calcom/lib/logger";
import prisma from "@calcom/prisma";

const log = logger.getSubLogger({ prefix: ["team/[slug]"] });

const querySchema = z
  .object({
    username: z.string(),
    teamname: z.string(),
    /**
     * Passed when we want to fetch avatar of a particular organization
     */
    orgSlug: z.string(),
    /**
     * Allow fetching avatar of a particular organization
     * Avatars being public, we need not worry about others accessing it.
     */
    orgId: z.string().transform((s) => Number(s)),
  })
  .partial();

async function getIdentityData(req: NextApiRequest) {
  const { username, teamname, orgId, orgSlug } = querySchema.parse(req.query);
  const { currentOrgDomain, isValidOrgDomain } = orgDomainConfig(req);

  const org = isValidOrgDomain ? currentOrgDomain : null;

  const orgQuery = orgId
    ? {
        id: orgId,
      }
    : org
    ? whereClauseForOrgWithSlugOrRequestedSlug(org)
    : null;

  if (username) {
    const user = await prisma.user.findFirst({
      where: {
        username,
        organization: orgQuery,
      },
      select: { avatar: true, email: true },
    });

    return {
      name: username,
      email: user?.email,
      avatar: user?.avatar,
      org,
    };
  }

  if (teamname) {
    const team = await prisma.team.findFirst({
      where: {
        slug: teamname,
        parent: orgQuery,
      },
      select: { logo: true },
    });

    return {
      org,
      name: teamname,
      email: null,
      avatar: getPlaceholderAvatar(team?.logo, teamname),
    };
  }

  if (orgSlug) {
    const orgs = await prisma.team.findMany({
      where: {
        ...whereClauseForOrgWithSlugOrRequestedSlug(orgSlug),
      },
      select: {
        slug: true,
        logo: true,
        name: true,
      },
    });

    if (orgs.length > 1) {
      // This should never happen, but instead of throwing error, we are just logging to be able to observe when it happens.
      log.error("More than one organization found for slug", orgSlug);
    }

    const org = orgs[0];

    return {
      org: org?.slug,
      name: org?.name,
      email: null,
      avatar: getPlaceholderAvatar(org?.logo, org?.name),
    };
  }
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const identity = await getIdentityData(req);
  const img = identity?.avatar;
  // If image isn't set or links to this route itself, use default avatar
  if (!img) {
    if (identity?.org) {
      res.setHeader("x-cal-org", identity.org);
    }
    res.writeHead(302, {
      Location: AVATAR_FALLBACK,
    });

    return res.end();
  }

  if (!img.includes("data:image")) {
    if (identity.org) {
      res.setHeader("x-cal-org", identity.org);
    }
    res.writeHead(302, { Location: img });

    return res.end();
  }

  const decoded = img.toString().replace("data:image/png;base64,", "").replace("data:image/jpeg;base64,", "");
  const imageResp = Buffer.from(decoded, "base64");
  if (identity.org) {
    res.setHeader("x-cal-org", identity.org);
  }
  res.writeHead(200, {
    "Content-Type": "image/png",
    "Content-Length": imageResp.length,
  });
  res.end(imageResp);
}
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { orgDomainConfig } from "@calcom/features/ee/organizations/lib/orgDomains";
import { checkUsername } from "@calcom/lib/server/checkUsername";

type Response = {
  available: boolean;
  premium: boolean;
};

const bodySchema = z.object({
  username: z.string(),
  orgSlug: z.string().optional(),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse<Response>): Promise<void> {
  const { currentOrgDomain } = orgDomainConfig(req);
  const { username, orgSlug } = bodySchema.parse(req.body);
  const result = await checkUsername(username, currentOrgDomain || orgSlug);
  return res.status(200).json(result);
}
import type { NextApiRequest, NextApiResponse } from "next";
import crypto from "node:crypto";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { defaultHandler } from "@calcom/lib/server";

async function handler(req: NextApiRequest, res: NextApiResponse) {
  const session = await getServerSession({ req, res });
  const secret = process.env.INTERCOM_SECRET;

  if (!session) {
    return res.status(401).json({ message: "user not authenticated" });
  }

  if (!secret) {
    return res.status(400).json({ message: "Intercom Identity Verification secret not set" });
  }

  const hmac = crypto.createHmac("sha256", secret);
  hmac.update(String(session.user.id));
  const hash = hmac.digest("hex");

  return res.status(200).json({ hash });
}

export default defaultHandler({
  GET: Promise.resolve({ default: handler }),
});
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { orgDomainConfig } from "@calcom/features/ee/organizations/lib/orgDomains";
import {
  ANDROID_CHROME_ICON_192,
  ANDROID_CHROME_ICON_256,
  APPLE_TOUCH_ICON,
  FAVICON_16,
  FAVICON_32,
  IS_SELF_HOSTED,
  LOGO,
  LOGO_ICON,
  MSTILE_ICON,
  WEBAPP_URL,
} from "@calcom/lib/constants";
import logger from "@calcom/lib/logger";

const log = logger.getSubLogger({ prefix: ["[api/logo]"] });

function removePort(url: string) {
  return url.replace(/:\d+$/, "");
}

function extractSubdomainAndDomain(hostname: string) {
  const hostParts = removePort(hostname).split(".");

  const subdomainParts = hostParts.slice(0, hostParts.length - 2);
  const domain = hostParts.slice(hostParts.length - 2).join(".");

  return [subdomainParts[0], domain];
}

const logoApiSchema = z.object({
  type: z.coerce.string().optional(),
});

const SYSTEM_SUBDOMAINS = ["console", "app", "www"];

type LogoType =
  | "logo"
  | "icon"
  | "favicon-16"
  | "favicon-32"
  | "apple-touch-icon"
  | "mstile"
  | "android-chrome-192"
  | "android-chrome-256";

type LogoTypeDefinition = {
  fallback: string;
  w?: number;
  h?: number;
  source: "appLogo" | "appIconLogo";
};

const logoDefinitions: Record<LogoType, LogoTypeDefinition> = {
  logo: {
    fallback: `${WEBAPP_URL}${LOGO}`,
    source: "appLogo",
  },
  icon: {
    fallback: `${WEBAPP_URL}${LOGO_ICON}`,
    source: "appIconLogo",
  },
  "favicon-16": {
    fallback: `${WEBAPP_URL}${FAVICON_16}`,
    w: 16,
    h: 16,
    source: "appIconLogo",
  },
  "favicon-32": {
    fallback: `${WEBAPP_URL}${FAVICON_32}`,
    w: 32,
    h: 32,
    source: "appIconLogo",
  },
  "apple-touch-icon": {
    fallback: `${WEBAPP_URL}${APPLE_TOUCH_ICON}`,
    w: 180,
    h: 180,
    source: "appLogo",
  },
  mstile: {
    fallback: `${WEBAPP_URL}${MSTILE_ICON}`,
    w: 150,
    h: 150,
    source: "appLogo",
  },
  "android-chrome-192": {
    fallback: `${WEBAPP_URL}${ANDROID_CHROME_ICON_192}`,
    w: 192,
    h: 192,
    source: "appLogo",
  },
  "android-chrome-256": {
    fallback: `${WEBAPP_URL}${ANDROID_CHROME_ICON_256}`,
    w: 256,
    h: 256,
    source: "appLogo",
  },
};

function isValidLogoType(type: string): type is LogoType {
  return type in logoDefinitions;
}

async function getTeamLogos(subdomain: string, isValidOrgDomain: boolean) {
  try {
    if (
      // if not cal.com
      IS_SELF_HOSTED ||
      // missing subdomain (empty string)
      !subdomain ||
      // in SYSTEM_SUBDOMAINS list
      SYSTEM_SUBDOMAINS.includes(subdomain)
    ) {
      throw new Error("No custom logo needed");
    }
    // load from DB
    const { default: prisma } = await import("@calcom/prisma");

    const team = await prisma.team.findFirst({
      where: {
        slug: subdomain,
        ...(isValidOrgDomain && {
          metadata: {
            path: ["isOrganization"],
            equals: true,
          },
        }),
      },
      select: {
        appLogo: true,
        appIconLogo: true,
      },
    });

    return {
      appLogo: team?.appLogo,
      appIconLogo: team?.appIconLogo,
    };
  } catch (error) {
    if (error instanceof Error) log.debug(error.message);

    return {
      appLogo: undefined,
      appIconLogo: undefined,
    };
  }
}

/**
 * This API endpoint is used to serve the logo associated with a team if no logo is found we serve our default logo
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { query } = req;
  const parsedQuery = logoApiSchema.parse(query);
  const { isValidOrgDomain } = orgDomainConfig(req);

  const hostname = req?.headers["host"];
  if (!hostname) throw new Error("No hostname");
  const domains = extractSubdomainAndDomain(hostname);
  if (!domains) throw new Error("No domains");

  const [subdomain] = domains;
  const teamLogos = await getTeamLogos(subdomain, isValidOrgDomain);

  // Resolve all icon types to team logos, falling back to Cal.com defaults.
  const type: LogoType = parsedQuery?.type && isValidLogoType(parsedQuery.type) ? parsedQuery.type : "logo";
  const logoDefinition = logoDefinitions[type];
  const filteredLogo = teamLogos[logoDefinition.source] ?? logoDefinition.fallback;

  try {
    const response = await fetch(filteredLogo);

    const arrayBuffer = await response.arrayBuffer();

    let buffer = Buffer.from(arrayBuffer);

    // If we need to resize the team logos (via Next.js' built-in image processing)
    if (teamLogos[logoDefinition.source] && logoDefinition.w) {
      const { detectContentType, optimizeImage } = await import("next/dist/server/image-optimizer");
      buffer = await optimizeImage({
        buffer,
        contentType: detectContentType(buffer) ?? "image/jpeg",
        quality: 100,
        width: logoDefinition.w,
        height: logoDefinition.h, // optional
      });
    }

    res.setHeader("Content-Type", response.headers.get("content-type") as string);
    res.setHeader("Cache-Control", "s-maxage=86400, stale-while-revalidate=60");
    res.send(buffer);
  } catch (error) {
    res.statusCode = 404;
    res.json({ error: "Failed fetching logo" });
  }
}
export { default, config } from "@calcom/features/ee/payments/api/webhook";

export { default, config } from "@calcom/app-store/alby/api/webhook";
import type { NextApiRequest, NextApiResponse } from "next";
import type { Session } from "next-auth";

import getInstalledAppPath from "@calcom/app-store/_utils/getInstalledAppPath";
import { throwIfNotHaveAdminAccessToTeam } from "@calcom/app-store/_utils/throwIfNotHaveAdminAccessToTeam";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { deriveAppDictKeyFromType } from "@calcom/lib/deriveAppDictKeyFromType";
import { HttpError } from "@calcom/lib/http-error";
import prisma from "@calcom/prisma";
import type { AppDeclarativeHandler, AppHandler } from "@calcom/types/AppHandler";

const defaultIntegrationAddHandler = async ({
  slug,
  supportsMultipleInstalls,
  appType,
  user,
  teamId = undefined,
  createCredential,
}: {
  slug: string;
  supportsMultipleInstalls: boolean;
  appType: string;
  user?: Session["user"];
  teamId?: number;
  createCredential: AppDeclarativeHandler["createCredential"];
}) => {
  if (!user?.id) {
    throw new HttpError({ statusCode: 401, message: "You must be logged in to do this" });
  }
  if (!supportsMultipleInstalls) {
    const alreadyInstalled = await prisma.credential.findFirst({
      where: {
        appId: slug,
        ...(teamId ? { AND: [{ userId: user.id }, { teamId }] } : { userId: user.id }),
      },
    });

    if (alreadyInstalled) {
      throw new Error("App is already installed");
    }
  }

  await throwIfNotHaveAdminAccessToTeam({ teamId: teamId ?? null, userId: user.id });

  await createCredential({ user: user, appType, slug, teamId });
};

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  // Check that user is authenticated
  req.session = await getServerSession({ req, res });

  const { args, teamId } = req.query;

  if (!Array.isArray(args)) {
    return res.status(404).json({ message: `API route not found` });
  }

  const [appName, apiEndpoint] = args;
  try {
    /* Absolute path didn't work */
    const handlerMap = (await import("@calcom/app-store/apps.server.generated")).apiHandlers;

    const handlerKey = deriveAppDictKeyFromType(appName, handlerMap);

    const handlers = await handlerMap[handlerKey as keyof typeof handlerMap];

    if (!handlers) throw new HttpError({ statusCode: 404, message: `No handlers found for ${handlerKey}` });

    const handler = handlers[apiEndpoint as keyof typeof handlers] as AppHandler;

    let redirectUrl = "/apps/installed";

    if (typeof handler === "undefined")
      throw new HttpError({ statusCode: 404, message: `API handler not found` });

    if (typeof handler === "function") {
      await handler(req, res);
    } else {
      await defaultIntegrationAddHandler({ user: req.session?.user, teamId: Number(teamId), ...handler });
      redirectUrl = handler.redirect?.url || getInstalledAppPath(handler);
      res.json({ url: redirectUrl, newTab: handler.redirect?.newTab });
    }
    if (!res.writableEnded) return res.status(200);

    return res;
  } catch (error) {
    console.error(error);

    if (error instanceof HttpError) {
      return res.status(error.statusCode).json({ message: error.message });
    }
    if (error instanceof Error) {
      return res.status(400).json({ message: error.message });
    }
    return res.status(404).json({ message: `API handler not found` });
  }
};

export default handler;
import { buffer } from "micro";
import type { NextApiRequest, NextApiResponse } from "next";
import type Stripe from "stripe";

import stripe from "@calcom/app-store/stripepayment/lib/server";
import { IS_PRODUCTION } from "@calcom/lib/constants";
import { getErrorFromUnknown } from "@calcom/lib/errors";
import { HttpError as HttpCode } from "@calcom/lib/http-error";
import prisma from "@calcom/prisma";

export const config = {
  api: {
    bodyParser: false,
  },
};

// This file is a catch-all for any integration related subscription/paid app.

const handleSubscriptionUpdate = async (event: Stripe.Event) => {
  const subscription = event.data.object as Stripe.Subscription;
  if (!subscription.id) throw new HttpCode({ statusCode: 400, message: "Subscription ID not found" });

  const app = await prisma.credential.findFirst({
    where: {
      subscriptionId: subscription.id,
    },
  });

  if (!app) {
    throw new HttpCode({ statusCode: 202, message: "Received and discarded" });
  }

  await prisma.credential.update({
    where: {
      id: app.id,
    },
    data: {
      paymentStatus: subscription.status,
    },
  });
};

const handleSubscriptionDeleted = async (event: Stripe.Event) => {
  const subscription = event.data.object as Stripe.Subscription;
  if (!subscription.id) throw new HttpCode({ statusCode: 400, message: "Subscription ID not found" });

  const app = await prisma.credential.findFirst({
    where: {
      subscriptionId: subscription.id,
    },
  });

  if (!app) {
    throw new HttpCode({ statusCode: 202, message: "Received and discarded" });
  }

  // should we delete the credential here rather than marking as inactive?
  await prisma.credential.update({
    where: {
      id: app.id,
    },
    data: {
      paymentStatus: "inactive",
      billingCycleStart: null,
    },
  });
};

type WebhookHandler = (event: Stripe.Event) => Promise<void>;

const webhookHandlers: Record<string, WebhookHandler | undefined> = {
  "customer.subscription.updated": handleSubscriptionUpdate,
  "customer.subscription.deleted": handleSubscriptionDeleted,
};

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    if (req.method !== "POST") {
      throw new HttpCode({ statusCode: 405, message: "Method Not Allowed" });
    }
    const sig = req.headers["stripe-signature"];

    if (!sig) {
      throw new HttpCode({ statusCode: 400, message: "Missing stripe-signature" });
    }

    if (!process.env.STRIPE_WEBHOOK_SECRET_APPS) {
      throw new HttpCode({ statusCode: 500, message: "Missing process.env.STRIPE_WEBHOOK_SECRET_APPS" });
    }
    const requestBuffer = await buffer(req);

    const payload = requestBuffer.toString();

    const event = stripe.webhooks.constructEvent(payload, sig, process.env.STRIPE_WEBHOOK_SECRET_APPS);

    const handler = webhookHandlers[event.type];

    if (handler) {
      await handler(event);
    } else {
      /** Not really an error, just letting Stripe know that the webhook was received but unhandled */
      throw new HttpCode({
        statusCode: 202,
        message: `Unhandled Stripe Webhook event type ${event.type}`,
      });
    }
  } catch (_err) {
    const err = getErrorFromUnknown(_err);
    console.error(`Webhook Error: ${err.message}`);
    res.status(err.statusCode ?? 500).send({
      message: err.message,
      stack: IS_PRODUCTION ? undefined : err.stack,
    });

    return;
  }

  // Return a response to acknowledge receipt of the event
  res.json({ received: true });
}
export { default, config } from "@calcom/app-store/paypal/api/webhook";
import type { NextApiRequest, NextApiResponse } from "next";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import handleNewBooking from "@calcom/features/bookings/lib/handleNewBooking";
import type { BookingResponse, RecurringBookingCreateBody } from "@calcom/features/bookings/types";
import { checkRateLimitAndThrowError } from "@calcom/lib/checkRateLimitAndThrowError";
import getIP from "@calcom/lib/getIP";
import { defaultResponder } from "@calcom/lib/server";
import type { AppsStatus } from "@calcom/types/Calendar";

// @TODO: Didn't look at the contents of this function in order to not break old booking page.

async function handler(req: NextApiRequest & { userId?: number }, res: NextApiResponse) {
  const userIp = getIP(req);

  await checkRateLimitAndThrowError({
    rateLimitingType: "core",
    identifier: userIp,
  });
  const data: RecurringBookingCreateBody[] = req.body;
  const session = await getServerSession({ req, res });
  const createdBookings: BookingResponse[] = [];
  const allRecurringDates: { start: string | undefined; end: string | undefined }[] = data.map((booking) => {
    return { start: booking.start, end: booking.end };
  });
  const appsStatus: AppsStatus[] | undefined = undefined;

  /* To mimic API behavior and comply with types */
  req.userId = session?.user?.id || -1;
  const numSlotsToCheckForAvailability = 2;

  let thirdPartyRecurringEventId = null;
  for (let key = 0; key < data.length; key++) {
    const booking = data[key];
    // Disable AppStatus in Recurring Booking Email as it requires us to iterate backwards to be able to compute the AppsStatus for all the bookings except the very first slot and then send that slot's email with statuses
    // It is also doubtful that how useful is to have the AppsStatus of all the bookings in the email.
    // It is more important to iterate forward and check for conflicts for only first few bookings defined by 'numSlotsToCheckForAvailability'
    // if (key === 0) {
    //   const calcAppsStatus: { [key: string]: AppsStatus } = createdBookings
    //     .flatMap((book) => (book.appsStatus !== undefined ? book.appsStatus : []))
    //     .reduce((prev, curr) => {
    //       if (prev[curr.type]) {
    //         prev[curr.type].failures += curr.failures;
    //         prev[curr.type].success += curr.success;
    //       } else {
    //         prev[curr.type] = curr;
    //       }
    //       return prev;
    //     }, {} as { [key: string]: AppsStatus });
    //   appsStatus = Object.values(calcAppsStatus);
    // }

    const recurringEventReq: NextApiRequest & { userId?: number } = req;

    recurringEventReq.body = {
      ...booking,
      appsStatus,
      allRecurringDates,
      isFirstRecurringSlot: key == 0,
      thirdPartyRecurringEventId,
      numSlotsToCheckForAvailability,
      currentRecurringIndex: key,
      noEmail: key !== 0,
    };

    const promiseEachRecurringBooking: ReturnType<typeof handleNewBooking> = handleNewBooking(
      recurringEventReq,
      {
        isNotAnApiCall: true,
      }
    );

    const eachRecurringBooking = await promiseEachRecurringBooking;

    createdBookings.push(eachRecurringBooking);

    if (!thirdPartyRecurringEventId) {
      if (eachRecurringBooking.references && eachRecurringBooking.references.length > 0) {
        for (const reference of eachRecurringBooking.references!) {
          if (reference.thirdPartyRecurringEventId) {
            thirdPartyRecurringEventId = reference.thirdPartyRecurringEventId;

            break;
          }
        }
      }
    }
  }
  return createdBookings;
}

export const handleRecurringEventBooking = handler;

export default defaultResponder(handler);
import type { NextApiRequest, NextApiResponse } from "next";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import handleInstantMeeting from "@calcom/features/instant-meeting/handleInstantMeeting";
import { checkRateLimitAndThrowError } from "@calcom/lib/checkRateLimitAndThrowError";
import getIP from "@calcom/lib/getIP";
import { defaultResponder } from "@calcom/lib/server";

async function handler(req: NextApiRequest & { userId?: number }, res: NextApiResponse) {
  const userIp = getIP(req);

  await checkRateLimitAndThrowError({
    rateLimitingType: "core",
    identifier: `instant.event-${userIp}`,
  });

  const session = await getServerSession({ req, res });
  req.userId = session?.user?.id || -1;
  const booking = await handleInstantMeeting(req);
  return booking;
}
export default defaultResponder(handler);
import type { NextApiRequest, NextApiResponse } from "next";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import handleNewBooking from "@calcom/features/bookings/lib/handleNewBooking";
import { checkRateLimitAndThrowError } from "@calcom/lib/checkRateLimitAndThrowError";
import getIP from "@calcom/lib/getIP";
import { defaultResponder } from "@calcom/lib/server";

async function handler(req: NextApiRequest & { userId?: number }, res: NextApiResponse) {
  const userIp = getIP(req);

  await checkRateLimitAndThrowError({
    rateLimitingType: "core",
    identifier: userIp,
  });

  const session = await getServerSession({ req, res });
  /* To mimic API behavior and comply with types */
  req.userId = session?.user?.id || -1;
  const booking = await handleNewBooking(req, {
    isNotAnApiCall: true,
  });
  return booking;
}

export default defaultResponder(handler);
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { AVATAR_FALLBACK } from "@calcom/lib/constants";
import prisma from "@calcom/prisma";

const querySchema = z.object({
  uuid: z.string().transform((objectKey) => objectKey.split(".")[0]),
});

const handleValidationError = (res: NextApiResponse, error: z.ZodError): void => {
  const errors = error.errors.map((err) => ({
    path: err.path.join("."),
    errorCode: `error.validation.${err.code}`,
  }));

  res.status(400).json({
    message: "VALIDATION_ERROR",
    errors,
  });
};

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const result = querySchema.safeParse(req.query);
  if (!result.success) {
    return handleValidationError(res, result.error);
  }

  const { uuid: objectKey } = result.data;

  let img;
  try {
    const { data } = await prisma.avatar.findUniqueOrThrow({
      where: {
        objectKey,
      },
      select: {
        data: true,
      },
    });
    img = data;
  } catch (e) {
    // If anything goes wrong or avatar is not found, use default avatar
    res.writeHead(302, {
      Location: AVATAR_FALLBACK,
    });

    res.end();

    return;
  }

  const decoded = img.toString().replace("data:image/png;base64,", "").replace("data:image/jpeg;base64,", "");
  const imageResp = Buffer.from(decoded, "base64");

  res.writeHead(200, {
    "Content-Type": "image/png",
    "Content-Length": imageResp.length,
    "Cache-Control": "max-age=86400",
  });

  res.end(imageResp);
}
import { google } from "googleapis";
import type { NextApiRequest, NextApiResponse } from "next";

import getAppKeysFromSlug from "@calcom/app-store/_utils/getAppKeysFromSlug";
import { WEBAPP_URL } from "@calcom/lib/constants";

const scopes = [
  "https://www.googleapis.com/auth/admin.directory.user.readonly",
  "https://www.googleapis.com/auth/admin.directory.customer.readonly",
];

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === "GET") {
    // Get appKeys from google-calendar
    const { client_id, client_secret } = await getAppKeysFromSlug("google-calendar");

    if (!client_id || typeof client_id !== "string")
      return res.status(400).json({ message: "Google client_id missing." });

    if (!client_secret || typeof client_secret !== "string")
      return res.status(400).json({ message: "Google client_secret missing." });

    // use differnt callback to normal calendar connection
    const redirect_uri = `${WEBAPP_URL}/api/teams/googleworkspace/callback`;

    const oAuth2Client = new google.auth.OAuth2(client_id, client_secret, redirect_uri);

    const authUrl = oAuth2Client.generateAuthUrl({
      access_type: "offline",
      scope: scopes,

      prompt: "consent",
      state: JSON.stringify({ teamId: req.query.teamId }),
    });

    res.status(200).json({ url: authUrl });
  }
}
import { google } from "googleapis";
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import getAppKeysFromSlug from "@calcom/app-store/_utils/getAppKeysFromSlug";
import { throwIfNotHaveAdminAccessToTeam } from "@calcom/app-store/_utils/throwIfNotHaveAdminAccessToTeam";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { WEBAPP_URL } from "@calcom/lib/constants";
import { getSafeRedirectUrl } from "@calcom/lib/getSafeRedirectUrl";
import prisma from "@calcom/prisma";

const stateSchema = z.object({
  teamId: z.string(),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const session = await getServerSession({ req, res });

  if (!session?.user?.id) {
    return res.status(401).json({ message: "You must be logged in to do this" });
  }

  const { code, state } = req.query;
  const parsedState = stateSchema.parse(JSON.parse(state as string));
  const { teamId } = parsedState;
  await throwIfNotHaveAdminAccessToTeam({ teamId: Number(teamId) ?? null, userId: session.user.id });
  if (code && typeof code !== "string") {
    res.status(400).json({ message: "`code` must be a string" });

    return;
  }

  const { client_id, client_secret } = await getAppKeysFromSlug("google-calendar");

  if (!client_id || typeof client_id !== "string")
    return res.status(400).json({ message: "Google client_id missing." });
  if (!client_secret || typeof client_secret !== "string")
    return res.status(400).json({ message: "Google client_secret missing." });

  const redirect_uri = `${WEBAPP_URL}/api/teams/googleworkspace/callback`;
  const oAuth2Client = new google.auth.OAuth2(client_id, client_secret, redirect_uri);

  if (!code) {
    throw new Error("No code provided");
  }

  const credentials = await oAuth2Client.getToken(code);

  await prisma.credential.create({
    data: {
      type: "google_workspace_directory",
      key: credentials.res?.data,
      userId: session.user.id,
    },
  });

  if (!teamId) {
    res.redirect(getSafeRedirectUrl(`${WEBAPP_URL}/settings`) ?? `${WEBAPP_URL}/teams`);
  }

  res.redirect(
    getSafeRedirectUrl(`${WEBAPP_URL}/settings/teams/${teamId}/members?inviteModal=true&bulk=true`) ??
      `${WEBAPP_URL}/teams`
  );
}
import type { NextApiRequest, NextApiResponse } from "next";
import type Stripe from "stripe";
import { z } from "zod";

import stripe from "@calcom/features/ee/payments/server/stripe";
import { HttpError } from "@calcom/lib/http-error";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";
import prisma from "@calcom/prisma";
import { MembershipRole } from "@calcom/prisma/enums";
import { _MembershipModel as Membership, _TeamModel as Team } from "@calcom/prisma/zod";

const querySchema = z.object({
  session_id: z.string().min(1),
});

const checkoutSessionMetadataSchema = z.object({
  pendingPaymentTeamId: z.string().transform(Number),
  ownerId: z.string().transform(Number),
});

type CheckoutSessionMetadata = z.infer<typeof checkoutSessionMetadataSchema>;

export const schemaTeamReadPublic = Team.omit({});

export const schemaMembershipPublic = Membership.merge(z.object({ team: Team }).partial());

async function handler(req: NextApiRequest, res: NextApiResponse) {
  const checkoutSession = await getCheckoutSession(req);
  validateCheckoutSession(checkoutSession);
  const checkoutSessionSubscription = getCheckoutSessionSubscription(checkoutSession);
  const checkoutSessionMetadata = getCheckoutSessionMetadata(checkoutSession);

  const finalizedTeam = await prisma.team.update({
    where: { id: checkoutSessionMetadata.pendingPaymentTeamId },
    data: {
      pendingPayment: false,
      members: {
        create: {
          userId: checkoutSessionMetadata.ownerId as number,
          role: MembershipRole.OWNER,
          accepted: true,
        },
      },
      metadata: {
        paymentId: checkoutSession.id,
        subscriptionId: checkoutSessionSubscription.id || null,
        subscriptionItemId: checkoutSessionSubscription.items.data[0].id || null,
      },
    },
    include: { members: true },
  });

  const response = JSON.stringify(
    {
      message: `Team created successfully. We also made user with ID=${checkoutSessionMetadata.ownerId} the owner of this team.`,
      team: schemaTeamReadPublic.parse(finalizedTeam),
      owner: schemaMembershipPublic.parse(finalizedTeam.members[0]),
    },
    null,
    2
  );

  return res.status(200).send(response);
}

async function getCheckoutSession(req: NextApiRequest) {
  const { session_id } = querySchema.parse(req.query);

  const checkoutSession = await stripe.checkout.sessions.retrieve(session_id, {
    expand: ["subscription"],
  });
  if (!checkoutSession) throw new HttpError({ statusCode: 404, message: "Checkout session not found" });

  return checkoutSession;
}

function validateCheckoutSession(checkoutSession: Stripe.Response<Stripe.Checkout.Session>) {
  if (checkoutSession.payment_status !== "paid")
    throw new HttpError({ statusCode: 402, message: "Payment required" });
}

function getCheckoutSessionSubscription(checkoutSession: Stripe.Response<Stripe.Checkout.Session>) {
  if (!checkoutSession.subscription) {
    throw new HttpError({
      statusCode: 400,
      message: "Can't publish team/org without subscription",
    });
  }

  return checkoutSession.subscription as Stripe.Subscription;
}

function getCheckoutSessionMetadata(
  checkoutSession: Stripe.Response<Stripe.Checkout.Session>
): CheckoutSessionMetadata {
  const parseCheckoutSessionMetadata = checkoutSessionMetadataSchema.safeParse(checkoutSession.metadata);

  if (!parseCheckoutSessionMetadata.success) {
    throw new HttpError({
      statusCode: 400,
      message: `Incorrect metadata in checkout session. Error: ${parseCheckoutSessionMetadata.error}`,
    });
  }

  const checkoutSessionMetadata = parseCheckoutSessionMetadata.data;

  return checkoutSessionMetadata;
}

export default defaultHandler({
  GET: Promise.resolve({ default: defaultResponder(handler) }),
});
import type { NextApiRequest, NextApiResponse } from "next";
import type Stripe from "stripe";
import { z } from "zod";

import stripe from "@calcom/features/ee/payments/server/stripe";
import { HttpError } from "@calcom/lib/http-error";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";
import prisma from "@calcom/prisma";
import { MembershipRole } from "@calcom/prisma/enums";

const querySchema = z.object({
  session_id: z.string().min(1),
});

const checkoutSessionMetadataSchema = z.object({
  teamName: z.string(),
  teamSlug: z.string(),
  userId: z.string().transform(Number),
});

const generateRandomString = () => {
  return Math.random().toString(36).substring(2, 10);
};

async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { session_id } = querySchema.parse(req.query);

  const checkoutSession = await stripe.checkout.sessions.retrieve(session_id, {
    expand: ["subscription"],
  });
  if (!checkoutSession) throw new HttpError({ statusCode: 404, message: "Checkout session not found" });

  const subscription = checkoutSession.subscription as Stripe.Subscription;

  if (checkoutSession.payment_status !== "paid")
    throw new HttpError({ statusCode: 402, message: "Payment required" });

  // Let's query to ensure that the team metadata carried over from the checkout session.
  const parseCheckoutSessionMetadata = checkoutSessionMetadataSchema.safeParse(checkoutSession.metadata);

  if (!parseCheckoutSessionMetadata.success) {
    console.error(
      "Team metadata not found in checkout session",
      parseCheckoutSessionMetadata.error,
      checkoutSession.id
    );
  }

  if (!checkoutSession.metadata?.userId) {
    throw new HttpError({
      statusCode: 400,
      message: "Can't publish team/org without userId",
    });
  }

  const checkoutSessionMetadata = parseCheckoutSessionMetadata.success
    ? parseCheckoutSessionMetadata.data
    : {
        teamName: checkoutSession?.metadata?.teamName ?? generateRandomString(),
        teamSlug: checkoutSession?.metadata?.teamSlug ?? generateRandomString(),
        userId: checkoutSession.metadata.userId,
      };

  const team = await prisma.team.create({
    data: {
      name: checkoutSessionMetadata.teamName,
      slug: checkoutSessionMetadata.teamSlug,
      members: {
        create: {
          userId: checkoutSessionMetadata.userId as number,
          role: MembershipRole.OWNER,
          accepted: true,
        },
      },
      metadata: {
        paymentId: checkoutSession.id,
        subscriptionId: subscription.id || null,
        subscriptionItemId: subscription.items.data[0].id || null,
      },
    },
  });

  // Sync Services: Close.com
  // closeComUpdateTeam(prevTeam, team);

  // redirect to team screen
  res.redirect(302, `/settings/teams/${team.id}/onboard-members?event=team_created`);
}

export default defaultHandler({
  GET: Promise.resolve({ default: defaultResponder(handler) }),
});

export { default } from "@calcom/features/ee/teams/api/upgrade";
import type { NextApiRequest, NextApiResponse } from "next";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { FUTURE_ROUTES_OVERRIDE_COOKIE_NAME as COOKIE_NAME } from "@calcom/lib/constants";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";

async function handler(req: NextApiRequest, res: NextApiResponse): Promise<void> {
  const session = await getServerSession({ req, res });

  if (!session || !session.user || !session.user.email) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }

  let redirectUrl = "/";

  // We take you back where you came from if possible
  if (typeof req.headers["referer"] === "string") redirectUrl = req.headers["referer"];

  /* Only admins can opt-in to future routes for now */
  if (session.user.role !== "ADMIN") {
    res.redirect(redirectUrl);

    return;
  }

  // If has the cookie, Opt-out of V2
  if (COOKIE_NAME in req.cookies && req.cookies[COOKIE_NAME] === "1") {
    res.setHeader("Set-Cookie", `${COOKIE_NAME}=0; Max-Age=0; Path=/`);
  } else {
    /* Opt-int to V2 */
    res.setHeader("Set-Cookie", `${COOKIE_NAME}=1; Path=/`);
  }

  res.redirect(redirectUrl);
}

export default defaultHandler({
  GET: Promise.resolve({ default: defaultResponder(handler) }),
});
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { getCalendarCredentials, getConnectedCalendars } from "@calcom/core/CalendarManager";
import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import notEmpty from "@calcom/lib/notEmpty";
import prisma from "@calcom/prisma";
import { credentialForCalendarServiceSelect } from "@calcom/prisma/selects/credential";

const selectedCalendarSelectSchema = z.object({
  integration: z.string(),
  externalId: z.string(),
  credentialId: z.number().optional(),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const session = await getServerSession({ req, res });

  if (!session?.user?.id) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }

  const userWithCredentials = await prisma.user.findUnique({
    where: {
      id: session.user.id,
    },
    select: {
      credentials: {
        select: credentialForCalendarServiceSelect,
      },
      timeZone: true,
      id: true,
      selectedCalendars: true,
    },
  });
  if (!userWithCredentials) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }
  const { credentials, ...user } = userWithCredentials;

  if (req.method === "POST") {
    const { integration, externalId, credentialId } = selectedCalendarSelectSchema.parse(req.body);
    await prisma.selectedCalendar.upsert({
      where: {
        userId_integration_externalId: {
          userId: user.id,
          integration,
          externalId,
        },
      },
      create: {
        userId: user.id,
        integration,
        externalId,
        credentialId,
      },
      // already exists
      update: {},
    });
    res.status(200).json({ message: "Calendar Selection Saved" });
  }

  if (req.method === "DELETE") {
    const { integration, externalId } = selectedCalendarSelectSchema.parse(req.query);
    await prisma.selectedCalendar.delete({
      where: {
        userId_integration_externalId: {
          userId: user.id,
          externalId,
          integration,
        },
      },
    });

    res.status(200).json({ message: "Calendar Selection Saved" });
  }

  if (req.method === "GET") {
    const selectedCalendarIds = await prisma.selectedCalendar.findMany({
      where: {
        userId: user.id,
      },
      select: {
        externalId: true,
      },
    });

    // get user's credentials + their connected integrations
    const calendarCredentials = getCalendarCredentials(credentials);
    // get all the connected integrations' calendars (from third party)
    const { connectedCalendars } = await getConnectedCalendars(calendarCredentials, user.selectedCalendars);

    const calendars = connectedCalendars.flatMap((c) => c.calendars).filter(notEmpty);

    const selectableCalendars = calendars.map((cal) => {
      return { selected: selectedCalendarIds.findIndex((s) => s.externalId === cal.externalId) > -1, ...cal };
    });
    res.status(200).json(selectableCalendars);
  }
}
import type { NextApiRequest, NextApiResponse } from "next";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import handleCancelBooking from "@calcom/features/bookings/lib/handleCancelBooking";
import { defaultResponder, defaultHandler } from "@calcom/lib/server";

async function handler(req: NextApiRequest & { userId?: number }, res: NextApiResponse) {
  const session = await getServerSession({ req, res });
  /* To mimic API behavior and comply with types */
  req.userId = session?.user?.id || -1;
  return await handleCancelBooking(req);
}

export default defaultHandler({
  DELETE: Promise.resolve({ default: defaultResponder(handler) }),
  POST: Promise.resolve({ default: defaultResponder(handler) }),
});
import type { NextApiRequest, NextApiResponse } from "next";
import * as pjson from "package.json";

type Response = {
  version: string;
};

export default async function handler(req: NextApiRequest, res: NextApiResponse<Response>): Promise<void> {
  return res.status(200).json({ version: pjson.version });
}
import { createHmac } from "crypto";
import type { NextApiRequest, NextApiResponse } from "next";
import getRawBody from "raw-body";
import z from "zod";

import { default as webPrisma } from "@calcom/prisma";

export const config = {
  api: {
    bodyParser: false,
  },
};

const helpscoutRequestBodySchema = z.object({
  customer: z.object({
    email: z.string().email(),
  }),
});

/**
 * API for Helpscout to retrieve key information about a user from a ticket
 * Note: HelpScout expects a JSON with a `html` prop to show its content as HTML
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== "POST") return res.status(405).json({ message: "Method not allowed" });

  const hsSignature = req.headers["x-helpscout-signature"];
  if (!hsSignature) return res.status(400).end();

  if (!process.env.CALENDSO_ENCRYPTION_KEY) return res.status(500).end();

  const rawBody = await getRawBody(req);
  const parsedBody = helpscoutRequestBodySchema.safeParse(JSON.parse(rawBody.toString()));

  if (!parsedBody.success) return res.status(400).end();

  const calculatedSig = createHmac("sha1", process.env.CALENDSO_ENCRYPTION_KEY)
    .update(rawBody)
    .digest("base64");

  if (req.headers["x-helpscout-signature"] !== calculatedSig) return res.status(400).end();

  const user = await webPrisma.user.findFirst({
    where: {
      email: parsedBody.data.customer.email,
    },
    select: {
      username: true,
      id: true,
      createdDate: true,
    },
  });

  if (!user) return res.status(200).json({ html: "User not found" });

  const lastBooking = await webPrisma.attendee.findFirst({
    where: {
      email: parsedBody.data.customer.email,
    },
    select: {
      booking: {
        select: {
          createdAt: true,
        },
      },
    },
    orderBy: {
      booking: {
        createdAt: "desc",
      },
    },
  });

  return res.status(200).json({
    html: `
      <ul>
        <li><b>Username:</b>&nbsp;${user.username}</li>
        <li><b>Last booking:</b>&nbsp;${
          lastBooking && lastBooking.booking
            ? new Date(lastBooking.booking.createdAt).toLocaleDateString("en-US")
            : "No info"
        }</li>
        <li><b>Account created:</b>&nbsp;${new Date(user.createdDate).toLocaleDateString("en-US")}</li>
      </ul>
    `,
  });
}
import type { NextApiRequest, NextApiResponse } from "next";

import { getServerSession } from "@calcom/features/auth/lib/getServerSession";
import { performance } from "@calcom/lib/server/perfObserver";

let isCold = true;

export default async function handler(req: NextApiRequest, res: NextApiResponse): Promise<void> {
  const prePrismaDate = performance.now();
  const prisma = (await import("@calcom/prisma")).default;
  const preSessionDate = performance.now();
  const session = await getServerSession({ req, res });
  if (!session) return res.status(409).json({ message: "Unauthorized" });
  const preUserDate = performance.now();
  const user = await prisma.user.findUnique({ where: { id: session.user.id } });
  if (!user) return res.status(404).json({ message: "No user found" });
  const lastUpdate = performance.now();

  res.setHeader("x-is-cold", isCold.toString());
  isCold = false;

  return res.status(200).json({
    message: `Hello ${user.name}`,
    prePrismaDate,
    prismaDuration: `Prisma took ${preSessionDate - prePrismaDate}ms`,
    preSessionDate,
    sessionDuration: `Session took ${preUserDate - preSessionDate}ms`,
    preUserDate,
    userDuration: `User took ${lastUpdate - preUserDate}ms`,
    lastUpdate,
    wasCold: isCold,
  });
}
import type { Prisma } from "@prisma/client";
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import dayjs from "@calcom/dayjs";
import { sendMonthlyDigestEmails } from "@calcom/emails/email-manager";
import { EventsInsights } from "@calcom/features/insights/server/events";
import { getTranslation } from "@calcom/lib/server";
import prisma from "@calcom/prisma";

const querySchema = z.object({
  page: z.coerce.number().min(0).optional().default(0),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const apiKey = req.headers.authorization || req.query.apiKey;

  if (process.env.CRON_API_KEY !== apiKey) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }

  if (req.method !== "POST") {
    res.status(405).json({ message: "Invalid method" });

    return;
  }

  const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
  const pageSize = 90; // Adjust this value based on the total number of teams and the available processing time
  let { page: pageNumber } = querySchema.parse(req.query);

  const firstDateOfMonth = new Date();
  firstDateOfMonth.setDate(1);

  while (true) {
    const teams = await prisma.team.findMany({
      where: {
        slug: {
          not: null,
        },
        createdAt: {
          // created before or on the first day of this month
          lte: firstDateOfMonth,
        },
      },
      select: {
        id: true,
        createdAt: true,
        members: true,
        name: true,
      },
      skip: pageNumber * pageSize,
      take: pageSize,
    });

    if (teams.length === 0) {
      break;
    }

    for (const team of teams) {
      const EventData: {
        Created: number;
        Completed: number;
        Rescheduled: number;
        Cancelled: number;
        mostBookedEvents: {
          eventTypeId?: number | null;
          eventTypeName?: string | null;
          count?: number | null;
        }[];
        membersWithMostBookings: {
          userId: number | null;
          user: {
            id: number;
            name: string | null;
            email: string;
            avatar: string | null;
            username: string | null;
          };
          count: number;
        }[];
        admin: { email: string; name: string };
        team: {
          name: string;
          id: number;
        };
      } = {
        Created: 0,
        Completed: 0,
        Rescheduled: 0,
        Cancelled: 0,
        mostBookedEvents: [],
        membersWithMostBookings: [],
        admin: { email: "", name: "" },
        team: { name: team.name, id: team.id },
      };

      const userIdsFromTeams = team.members.map((u) => u.userId);

      // Booking Events
      const whereConditional: Prisma.BookingTimeStatusWhereInput = {
        OR: [
          {
            teamId: team.id,
          },
          {
            userId: {
              in: userIdsFromTeams,
            },
            teamId: null,
          },
        ],
      };

      const promisesResult = await Promise.all([
        EventsInsights.getCreatedEventsInTimeRange(
          {
            start: dayjs(firstDateOfMonth),
            end: dayjs(new Date()),
          },
          whereConditional
        ),
        EventsInsights.getCompletedEventsInTimeRange(
          {
            start: dayjs(firstDateOfMonth),
            end: dayjs(new Date()),
          },
          whereConditional
        ),
        EventsInsights.getRescheduledEventsInTimeRange(
          {
            start: dayjs(firstDateOfMonth),
            end: dayjs(new Date()),
          },
          whereConditional
        ),
        EventsInsights.getCancelledEventsInTimeRange(
          {
            start: dayjs(firstDateOfMonth),
            end: dayjs(new Date()),
          },
          whereConditional
        ),
      ]);

      EventData["Created"] = promisesResult[0];
      EventData["Completed"] = promisesResult[1];
      EventData["Rescheduled"] = promisesResult[2];
      EventData["Cancelled"] = promisesResult[3];

      // Most Booked Event Type
      const bookingWhere: Prisma.BookingTimeStatusWhereInput = {
        createdAt: {
          gte: dayjs(firstDateOfMonth).startOf("day").toDate(),
          lte: dayjs(new Date()).endOf("day").toDate(),
        },
        OR: [
          {
            teamId: team.id,
          },
          {
            userId: {
              in: userIdsFromTeams,
            },
            teamId: null,
          },
        ],
      };

      const bookingsFromSelected = await prisma.bookingTimeStatus.groupBy({
        by: ["eventTypeId"],
        where: bookingWhere,
        _count: {
          id: true,
        },
        orderBy: {
          _count: {
            id: "desc",
          },
        },
        take: 10,
      });

      const eventTypeIds = bookingsFromSelected
        .filter((booking) => typeof booking.eventTypeId === "number")
        .map((booking) => booking.eventTypeId);

      const eventTypeWhereConditional: Prisma.EventTypeWhereInput = {
        id: {
          in: eventTypeIds as number[],
        },
      };

      const eventTypesFrom = await prisma.eventType.findMany({
        select: {
          id: true,
          title: true,
          teamId: true,
          userId: true,
          slug: true,
          users: {
            select: {
              username: true,
            },
          },
          team: {
            select: {
              slug: true,
            },
          },
        },
        where: eventTypeWhereConditional,
      });

      const eventTypeHashMap: Map<
        number,
        Prisma.EventTypeGetPayload<{
          select: {
            id: true;
            title: true;
            teamId: true;
            userId: true;
            slug: true;
            users: {
              select: {
                username: true;
              };
            };
            team: {
              select: {
                slug: true;
              };
            };
          };
        }>
      > = new Map();
      eventTypesFrom.forEach((eventType) => {
        eventTypeHashMap.set(eventType.id, eventType);
      });

      EventData["mostBookedEvents"] = bookingsFromSelected.map((booking) => {
        const eventTypeSelected = eventTypeHashMap.get(booking.eventTypeId ?? 0);

        if (!eventTypeSelected) {
          return {};
        }

        let eventSlug = "";

        if (eventTypeSelected.userId) {
          eventSlug = `${eventTypeSelected?.users[0]?.username}/${eventTypeSelected?.slug}`;
        }
        if (eventTypeSelected?.team && eventTypeSelected?.team?.slug) {
          eventSlug = `${eventTypeSelected.team.slug}/${eventTypeSelected.slug}`;
        }
        return {
          eventTypeId: booking.eventTypeId,
          eventTypeName: eventSlug,
          count: booking._count.id,
        };
      });

      // Most booked members
      const bookingsFromTeam = await prisma.bookingTimeStatus.groupBy({
        by: ["userId"],
        where: bookingWhere,
        _count: {
          id: true,
        },
        orderBy: {
          _count: {
            id: "desc",
          },
        },
        take: 10,
      });

      const userIds = bookingsFromTeam
        .filter((booking) => typeof booking.userId === "number")
        .map((booking) => booking.userId);

      if (userIds.length === 0) {
        EventData["membersWithMostBookings"] = [];
      } else {
        const teamUsers = await prisma.user.findMany({
          where: {
            id: {
              in: userIds as number[],
            },
          },
          select: { id: true, name: true, email: true, avatar: true, username: true },
        });

        const userHashMap = new Map();
        teamUsers.forEach((user) => {
          userHashMap.set(user.id, user);
        });

        EventData["membersWithMostBookings"] = bookingsFromTeam.map((booking) => {
          return {
            userId: booking.userId,
            user: userHashMap.get(booking.userId),
            count: booking._count.id,
          };
        });
      }

      // Send mail to all Owners and Admins
      const mailReceivers = team?.members?.filter(
        (member) => member.role === "OWNER" || member.role === "ADMIN"
      );

      const mailsToSend = mailReceivers.map(async (receiver) => {
        const owner = await prisma.user.findUnique({
          where: {
            id: receiver?.userId,
          },
        });

        if (owner) {
          const t = await getTranslation(owner?.locale ?? "en", "common");

          // Only send email if user has allowed to receive monthly digest emails
          if (owner.receiveMonthlyDigestEmail) {
            await sendMonthlyDigestEmails({
              ...EventData,
              admin: { email: owner?.email ?? "", name: owner?.name ?? "" },
              language: t,
            });
          }
        }
      });

      await Promise.all(mailsToSend);

      await delay(100); // Adjust the delay as needed to avoid rate limiting
    }

    pageNumber++;
  }
  res.json({ ok: true });
}
export { default } from "@calcom/features/ee/workflows/api/scheduleEmailReminders";

export { default } from "@calcom/features/ee/workflows/api/scheduleSMSReminders";

export { default } from "@calcom/features/ee/workflows/api/scheduleWhatsappReminders";

export { default } from "@calcom/features/webhooks/lib/cron";
import type { NextApiRequest, NextApiResponse } from "next";

import dayjs from "@calcom/dayjs";
import { sendOrganizerRequestReminderEmail } from "@calcom/emails";
import { getCalEventResponses } from "@calcom/features/bookings/lib/getCalEventResponses";
import { isPrismaObjOrUndefined, parseRecurringEvent } from "@calcom/lib";
import { getTranslation } from "@calcom/lib/server/i18n";
import prisma, { bookingMinimalSelect } from "@calcom/prisma";
import { BookingStatus, ReminderType } from "@calcom/prisma/enums";
import type { CalendarEvent } from "@calcom/types/Calendar";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const apiKey = req.headers.authorization || req.query.apiKey;
  if (process.env.CRON_API_KEY !== apiKey) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }
  if (req.method !== "POST") {
    res.status(405).json({ message: "Invalid method" });

    return;
  }

  const reminderIntervalMinutes = [48 * 60, 24 * 60, 3 * 60];
  let notificationsSent = 0;
  for (const interval of reminderIntervalMinutes) {
    const bookings = await prisma.booking.findMany({
      where: {
        status: BookingStatus.PENDING,
        createdAt: {
          lte: dayjs().add(-interval, "minutes").toDate(),
        },
        // Only send reminders if the event hasn't finished
        endTime: { gte: new Date() },
        OR: [
          // no payment required
          {
            payment: { none: {} },
          },
          // paid but awaiting approval
          {
            payment: { some: {} },
            paid: true,
          },
        ],
      },
      select: {
        ...bookingMinimalSelect,
        location: true,
        user: {
          select: {
            id: true,
            email: true,
            name: true,
            username: true,
            locale: true,
            timeZone: true,
            destinationCalendar: true,
          },
        },
        eventType: {
          select: {
            recurringEvent: true,
            bookingFields: true,
          },
        },
        responses: true,
        uid: true,
        destinationCalendar: true,
      },
    });

    const reminders = await prisma.reminderMail.findMany({
      where: {
        reminderType: ReminderType.PENDING_BOOKING_CONFIRMATION,
        referenceId: {
          in: bookings.map((b) => b.id),
        },
        elapsedMinutes: {
          gte: interval,
        },
      },
    });

    for (const booking of bookings.filter((b) => !reminders.some((r) => r.referenceId == b.id))) {
      const { user } = booking;
      const name = user?.name || user?.username;
      if (!user || !name || !user.timeZone) {
        console.error(`Booking ${booking.id} is missing required properties for booking reminder`, { user });

        continue;
      }

      const tOrganizer = await getTranslation(user.locale ?? "en", "common");

      const attendeesListPromises = booking.attendees.map(async (attendee) => {
        return {
          name: attendee.name,
          email: attendee.email,
          timeZone: attendee.timeZone,
          language: {
            translate: await getTranslation(attendee.locale ?? "en", "common"),
            locale: attendee.locale ?? "en",
          },
        };
      });

      const attendeesList = await Promise.all(attendeesListPromises);
      const selectedDestinationCalendar = booking.destinationCalendar || user.destinationCalendar;
      const evt: CalendarEvent = {
        type: booking.title,
        title: booking.title,
        description: booking.description || undefined,
        customInputs: isPrismaObjOrUndefined(booking.customInputs),
        ...getCalEventResponses({
          bookingFields: booking.eventType?.bookingFields ?? null,
          booking,
        }),
        location: booking.location ?? "",
        startTime: booking.startTime.toISOString(),
        endTime: booking.endTime.toISOString(),
        organizer: {
          id: user.id,
          email: user.email,
          name,
          timeZone: user.timeZone,
          language: { translate: tOrganizer, locale: user.locale ?? "en" },
        },
        attendees: attendeesList,
        uid: booking.uid,
        recurringEvent: parseRecurringEvent(booking.eventType?.recurringEvent),
        destinationCalendar: selectedDestinationCalendar ? [selectedDestinationCalendar] : [],
      };

      await sendOrganizerRequestReminderEmail(evt);

      await prisma.reminderMail.create({
        data: {
          referenceId: booking.id,
          reminderType: ReminderType.PENDING_BOOKING_CONFIRMATION,
          elapsedMinutes: interval,
        },
      });
      notificationsSent++;
    }
  }
  res.status(200).json({ notificationsSent });
}
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { updateQuantitySubscriptionFromStripe } from "@calcom/features/ee/teams/lib/payments";
import prisma from "@calcom/prisma";

const querySchema = z.object({
  page: z.coerce.number().min(0).optional().default(0),
});

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const apiKey = req.headers.authorization || req.query.apiKey;
  if (process.env.CRON_API_KEY !== apiKey) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }
  if (req.method !== "POST") {
    res.status(405).json({ message: "Invalid method" });

    return;
  }

  const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
  const pageSize = 90; // Adjust this value based on the total number of teams and the available processing time
  let { page: pageNumber } = querySchema.parse(req.query);

  while (true) {
    const teams = await prisma.team.findMany({
      where: {
        slug: {
          not: null,
        },
      },
      select: {
        id: true,
      },
      skip: pageNumber * pageSize,
      take: pageSize,
    });

    if (teams.length === 0) {
      break;
    }

    for (const team of teams) {
      await updateQuantitySubscriptionFromStripe(team.id);
      await delay(100); // Adjust the delay as needed to avoid rate limiting
    }

    pageNumber++;
  }

  res.json({ ok: true });
}
import type { NextApiRequest, NextApiResponse } from "next";

import prisma from "@calcom/prisma";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const deleted = await prisma.calendarCache.deleteMany({
    where: {
      // Delete all cache entries that expired before now
      expiresAt: {
        lte: new Date(Date.now()),
      },
    },
  });

  res.json({ ok: true, count: deleted.count });
}
import type { NextApiRequest, NextApiResponse } from "next";

import { getAppWithMetadata } from "@calcom/app-store/_appRegistry";
import logger from "@calcom/lib/logger";
import { prisma } from "@calcom/prisma";
import type { AppCategories, Prisma } from "@calcom/prisma/client";

const isDryRun = process.env.CRON_ENABLE_APP_SYNC !== "true";

const log = logger.getSubLogger({
  prefix: ["[api/cron/syncAppMeta]", ...(isDryRun ? ["(dry-run)"] : [])],
});

/**
 * syncAppMeta makes sure any app metadata that has been replicated into the database
 * remains synchronized with any changes made to the app config files.
 */
export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const apiKey = req.headers.authorization || req.query.apiKey;
  if (process.env.CRON_API_KEY !== apiKey) {
    res.status(401).json({ message: "Not authenticated" });

    return;
  }
  if (req.method !== "POST") {
    res.status(405).json({ message: "Invalid method" });

    return;
  }

  log.info(`🧐 Checking DB apps are in-sync with app metadata`);

  const dbApps = await prisma.app.findMany();

  for await (const dbApp of dbApps) {
    const app = await getAppWithMetadata(dbApp);

    const updates: Prisma.AppUpdateManyMutationInput = {};

    if (!app) {
      log.warn(`💀 App ${dbApp.slug} (${dbApp.dirName}) no longer exists.`);
      continue;
    }

    // Check for any changes in the app categories (tolerates changes in ordering)
    if (
      dbApp.categories.length !== app.categories.length ||
      !dbApp.categories.every((category) => app.categories.includes(category))
    ) {
      updates["categories"] = app.categories as AppCategories[];
    }

    if (dbApp.dirName !== (app.dirName ?? app.slug)) {
      updates["dirName"] = app.dirName ?? app.slug;
    }

    if (Object.keys(updates).length > 0) {
      log.info(`🔨 Updating app ${dbApp.slug} with ${Object.keys(updates).join(", ")}`);
      if (!isDryRun) {
        await prisma.app.update({
          where: { slug: dbApp.slug },
          data: updates,
        });
      }
    } else {
      log.info(`✅ App ${dbApp.slug} is up-to-date and correct`);
    }
  }

  res.json({ ok: true });
}
import type { NextApiRequest, NextApiResponse } from "next";
import { z } from "zod";

import { symmetricDecrypt } from "@calcom/lib/crypto";
import { defaultResponder } from "@calcom/lib/server";
import prisma from "@calcom/prisma";
import { UserPermissionRole } from "@calcom/prisma/enums";
import { TRPCError } from "@calcom/trpc/server";
import { createContext } from "@calcom/trpc/server/createContext";
import { bookingsRouter } from "@calcom/trpc/server/routers/viewer/bookings/_router";

enum DirectAction {
  ACCEPT = "accept",
  REJECT = "reject",
}

const querySchema = z.object({
  action: z.nativeEnum(DirectAction),
  token: z.string(),
  reason: z.string().optional(),
});

const decryptedSchema = z.object({
  bookingUid: z.string(),
  userId: z.number().int(),
});

async function handler(req: NextApiRequest, res: NextApiResponse<Response>) {
  const { action, token, reason } = querySchema.parse(req.query);
  const { bookingUid, userId } = decryptedSchema.parse(
    JSON.parse(symmetricDecrypt(decodeURIComponent(token), process.env.CALENDSO_ENCRYPTION_KEY || ""))
  );

  const booking = await prisma.booking.findUniqueOrThrow({
    where: { uid: bookingUid },
  });

  const user = await prisma.user.findUniqueOrThrow({
    where: { id: userId },
  });

  /** We shape the session as required by tRPC router */
  async function sessionGetter() {
    return {
      user: {
        id: userId,
        username: "" /* Not used in this context */,
        role: UserPermissionRole.USER,
      },
      hasValidLicense: true,
      expires: "" /* Not used in this context */,
    };
  }

  try {
    /** @see https://trpc.io/docs/server-side-calls */
    const ctx = await createContext({ req, res }, sessionGetter);

    const caller = bookingsRouter.createCaller({
      ...ctx,
      req,
      res,
      user: { ...user, locale: user?.locale ?? "en" },
    });
    await caller.confirm({
      bookingId: booking.id,
      recurringEventId: booking.recurringEventId || undefined,
      confirmed: action === DirectAction.ACCEPT,
      reason,
    });
  } catch (e) {
    let message = "Error confirming booking";

    if (e instanceof TRPCError) message = (e as TRPCError).message;
    res.redirect(`/booking/${bookingUid}?error=${encodeURIComponent(message)}`);

    return;
  }

  res.redirect(`/booking/${bookingUid}`);
}

export default defaultResponder(handler);
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import { env } from "../env.mjs";
import type { Booking } from "../types/booking";
import { BOOKING_STATUS } from "../types/booking";

/**
 * Fetches bookings for a user by date range.
 */
const fetchBookings = async ({
  apiKey,
  userId,
  from,
  to,
}: {
  apiKey: string;
  userId: number;
  from: string;
  to: string;
}): Promise<Booking[] | { error: string }> => {
  const params = {
    apiKey,
    userId: userId.toString(),
    dateFrom: from,
    dateTo: to,
  };

  const urlParams = new URLSearchParams(params);

  const url = `${env.BACKEND_URL}/bookings?${urlParams.toString()}`;

  const response = await fetch(url);

  if (response.status === 401) throw new Error("Unauthorized");

  const data = await response.json();

  if (response.status !== 200) {
    return { error: data.message };
  }

  const bookings: Booking[] = data.bookings
    .filter((booking: Booking) => {
      const notCancelled = booking.status !== BOOKING_STATUS.CANCELLED;

      return notCancelled;
    })
    .map(({ endTime, eventTypeId, id, startTime, status, title }: Booking) => ({
      endTime,
      eventTypeId,
      id,
      startTime,
      status,
      title,
    }));

  return bookings;
};

const getBookingsTool = (apiKey: string, userId: number) => {
  return new DynamicStructuredTool({
    description: "Get bookings for the primary user between two dates.",
    func: async ({ from, to }) => {
      return JSON.stringify(await fetchBookings({ apiKey, userId, from, to }));
    },
    name: "getBookings",
    schema: z.object({
      from: z.string().describe("ISO 8601 datetime string"),
      to: z.string().describe("ISO 8601 datetime string"),
    }),
  });
};

export default getBookingsTool;
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import { env } from "../env.mjs";
import type { Availability } from "../types/availability";

/**
 * Fetches availability for a user by date range and event type.
 */
export const fetchAvailability = async ({
  apiKey,
  userId,
  dateFrom,
  dateTo,
}: {
  apiKey: string;
  userId: number;
  dateFrom: string;
  dateTo: string;
}): Promise<Partial<Availability> | { error: string }> => {
  const params: { [k: string]: string } = {
    apiKey,
    userId: userId.toString(),
    dateFrom,
    dateTo,
  };

  const urlParams = new URLSearchParams(params);

  const url = `${env.BACKEND_URL}/availability?${urlParams.toString()}`;

  const response = await fetch(url);

  if (response.status === 401) throw new Error("Unauthorized");

  const data = await response.json();

  if (response.status !== 200) {
    return { error: data.message };
  }

  return {
    busy: data.busy,
    dateRanges: data.dateRanges,
    timeZone: data.timeZone,
    workingHours: data.workingHours,
  };
};

const getAvailabilityTool = (apiKey: string) => {
  return new DynamicStructuredTool({
    description: "Get availability of users within range.",
    func: async ({ userIds, dateFrom, dateTo }) => {
      return JSON.stringify(
        await Promise.all(
          userIds.map(
            async (userId) =>
              await fetchAvailability({
                userId: userId,
                apiKey,
                dateFrom,
                dateTo,
              })
          )
        )
      );
    },
    name: "getAvailability",
    schema: z.object({
      userIds: z.array(z.number()).describe("The users to fetch availability for."),
      dateFrom: z.string(),
      dateTo: z.string(),
    }),
  });
};

export default getAvailabilityTool;
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import { env } from "~/src/env.mjs";
import type { User, UserList } from "~/src/types/user";
import sendEmail from "~/src/utils/sendEmail";

export const sendBookingEmail = async ({
  user,
  agentEmail,
  subject,
  to,
  message,
  eventTypeSlug,
  slots,
  date,
}: {
  apiKey: string;
  user: User;
  users: UserList;
  agentEmail: string;
  subject: string;
  to: string;
  message: string;
  eventTypeSlug: string;
  slots?: {
    time: string;
    text: string;
  }[];
  date: {
    date: string;
    text: string;
  };
}) => {
  // const url = `${env.FRONTEND_URL}/${user.username}/${eventTypeSlug}?date=${date}`;
  const timeUrls = slots?.map(({ time, text }) => {
    return {
      url: `${env.FRONTEND_URL}/${user.username}/${eventTypeSlug}?slot=${time}`,
      text,
    };
  });

  const dateUrl = {
    url: `${env.FRONTEND_URL}/${user.username}/${eventTypeSlug}?date=${date.date}`,
    text: date.text,
  };

  await sendEmail({
    subject,
    to,
    cc: user.email,
    from: agentEmail,
    text: message
      .split("[[[Slots]]]")
      .join(timeUrls?.map(({ url, text }) => `${text}: ${url}`).join("\n"))
      .split("[[[Link]]]")
      .join(`${dateUrl.text}: ${dateUrl.url}`),
    html: message
      .split("\n")
      .join("<br>")
      .split("[[[Slots]]]")
      .join(timeUrls?.map(({ url, text }) => `<a href="${url}">${text}</a>`).join("<br>"))
      .split("[[[Link]]]")
      .join(`<a href="${dateUrl.url}">${dateUrl.text}</a>`),
  });

  return "Booking link sent";
};

const sendBookingEmailTool = (apiKey: string, user: User, users: UserList, agentEmail: string) => {
  return new DynamicStructuredTool({
    description:
      "Send a booking link via email. Useful for scheduling with non cal users. Be confident, suggesting a good date/time with a fallback to a link to select a date/time.",
    func: async ({ message, subject, to, eventTypeSlug, slots, date }) => {
      return JSON.stringify(
        await sendBookingEmail({
          apiKey,
          user,
          users,
          agentEmail,
          subject,
          to,
          message,
          eventTypeSlug,
          slots,
          date,
        })
      );
    },
    name: "sendBookingEmail",

    schema: z.object({
      message: z
        .string()
        .describe(
          "A polite and professional email with an intro and signature at the end. Specify you are the AI booking assistant of the primary user. Use [[[Slots]]] and a fallback [[[Link]]] to inject good times and 'see all times' into messages"
        ),
      subject: z.string(),
      to: z
        .string()
        .describe("email address to send the booking link to. Primary user is automatically CC'd"),
      eventTypeSlug: z.string().describe("the slug of the event type to book"),
      slots: z
        .array(
          z.object({
            time: z.string().describe("YYYY-MM-DDTHH:mm in UTC"),
            text: z.string().describe("minimum readable label. Ex. 4pm."),
          })
        )
        .optional()
        .describe("Time slots the external user can click"),
      date: z
        .object({
          date: z.string().describe("YYYY-MM-DD"),
          text: z.string().describe('"See all times" or similar'),
        })
        .describe(
          "A booking link that allows the external user to select a date / time. Should be a fallback to time slots"
        ),
    }),
  });
};

export default sendBookingEmailTool;
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import { env } from "../env.mjs";

/**
 * Cancels a booking for a user by ID with reason.
 */
const cancelBooking = async ({
  apiKey,
  id,
  reason,
}: {
  apiKey: string;
  id: string;
  reason: string;
}): Promise<string | { error: string }> => {
  const params = {
    apiKey,
  };

  const urlParams = new URLSearchParams(params);

  const url = `${env.BACKEND_URL}/bookings/${id}/cancel?${urlParams.toString()}`;

  const response = await fetch(url, {
    body: JSON.stringify({ reason }),
    headers: {
      "Content-Type": "application/json",
    },
    method: "DELETE",
  });

  // Let GPT handle this. This will happen when wrong booking id is used.
  // if (response.status === 401) throw new Error("Unauthorized");

  const data = await response.json();

  if (response.status !== 200) {
    return { error: data.message };
  }

  return "Booking cancelled";
};

const cancelBookingTool = (apiKey: string) => {
  return new DynamicStructuredTool({
    description: "Cancel a booking",
    func: async ({ id, reason }) => {
      return JSON.stringify(
        await cancelBooking({
          apiKey,
          id,
          reason,
        })
      );
    },
    name: "cancelBooking",
    schema: z.object({
      id: z.string(),
      reason: z.string(),
    }),
  });
};

export default cancelBookingTool;
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import type { UserList } from "~/src/types/user";

import { env } from "../env.mjs";

/**
 * Creates a booking for a user by event type, times, and timezone.
 */
const createBooking = async ({
  apiKey,
  userId,
  users,
  eventTypeId,
  start,
  end,
  timeZone,
  language,
  invite,
}: {
  apiKey: string;
  userId: number;
  users: UserList;
  eventTypeId: number;
  start: string;
  end: string;
  timeZone: string;
  language: string;
  invite: number;
  title?: string;
  status?: string;
}): Promise<string | Error | { error: string }> => {
  const params = {
    apiKey,
    userId: userId.toString(),
  };

  const urlParams = new URLSearchParams(params);

  const url = `${env.BACKEND_URL}/bookings?${urlParams.toString()}`;

  const user = users.find((u) => u.id === invite);

  if (!user) {
    return { error: `User with id ${invite} not found to invite` };
  }

  const responses = {
    id: invite.toString(),
    name: user.username,
    email: user.email,
  };

  const response = await fetch(url, {
    body: JSON.stringify({
      end,
      eventTypeId,
      language,
      metadata: {},
      responses,
      start,
      timeZone,
    }),
    headers: {
      "Content-Type": "application/json",
    },
    method: "POST",
  });

  // Let GPT handle this. This will happen when wrong event type id is used.
  // if (response.status === 401) throw new Error("Unauthorized");

  const data = await response.json();

  if (response.status !== 200) {
    return {
      error: data.message,
    };
  }

  return "Booking created";
};

const createBookingTool = (apiKey: string, userId: number, users: UserList) => {
  return new DynamicStructuredTool({
    description: "Creates a booking on the primary user's calendar.",
    func: async ({ eventTypeId, start, end, timeZone, language, invite, title, status }) => {
      return JSON.stringify(
        await createBooking({
          apiKey,
          userId,
          users,
          end,
          eventTypeId,
          language,
          invite,
          start,
          status,
          timeZone,
          title,
        })
      );
    },
    name: "createBooking",
    schema: z.object({
      end: z
        .string()
        .describe("This should correspond to the event type's length, unless otherwise specified."),
      eventTypeId: z.number(),
      language: z.string(),
      invite: z.number().describe("External user id to invite."),
      start: z.string(),
      status: z.string().optional().describe("ACCEPTED, PENDING, CANCELLED or REJECTED"),
      timeZone: z.string(),
      title: z.string().optional(),
    }),
  });
};

export default createBookingTool;
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import { env } from "../env.mjs";
import type { EventType } from "../types/eventType";

/**
 * Fetches event types by user ID.
 */
export const fetchEventTypes = async ({ apiKey, userId }: { apiKey: string; userId?: number }) => {
  const params: Record<string, string> = {
    apiKey,
  };

  if (userId) {
    params["userId"] = userId.toString();
  }

  const urlParams = new URLSearchParams(params);

  const url = `${env.BACKEND_URL}/event-types?${urlParams.toString()}`;

  const response = await fetch(url);

  if (response.status === 401) throw new Error("Unauthorized");

  const data = await response.json();

  if (response.status !== 200) {
    return { error: data.message };
  }

  return data.event_types.map((eventType: EventType) => ({
    id: eventType.id,
    slug: eventType.slug,
    length: eventType.length,
    title: eventType.title,
  }));
};

const getEventTypesTool = (apiKey: string) => {
  return new DynamicStructuredTool({
    description: "Get a user's event type IDs. Usually necessary to book a meeting.",
    func: async ({ userId }) => {
      return JSON.stringify(
        await fetchEventTypes({
          apiKey,
          userId,
        })
      );
    },
    name: "getEventTypes",
    schema: z.object({
      userId: z.number().optional().describe("The user ID. Defaults to the primary user's ID."),
    }),
  });
};

export default getEventTypesTool;
import { DynamicStructuredTool } from "langchain/tools";
import { z } from "zod";

import { env } from "../env.mjs";

/**
 * Edits a booking for a user by booking ID with new times, title, description, or status.
 */
const editBooking = async ({
  apiKey,
  userId,
  id,
  startTime, // In the docs it says start, but it's startTime: https://cal.com/docs/enterprise-features/api/api-reference/bookings#edit-an-existing-booking.
  endTime, // Same here: it says end but it's endTime.
  title,
  description,
  status,
}: {
  apiKey: string;
  userId: number;
  id: string;
  startTime?: string;
  endTime?: string;
  title?: string;
  description?: string;
  status?: string;
}): Promise<string | { error: string }> => {
  const params = {
    apiKey,
    userId: userId.toString(),
  };
  const urlParams = new URLSearchParams(params);

  const url = `${env.BACKEND_URL}/bookings/${id}?${urlParams.toString()}`;

  const response = await fetch(url, {
    body: JSON.stringify({ description, endTime, startTime, status, title }),
    headers: {
      "Content-Type": "application/json",
    },
    method: "PATCH",
  });

  // Let GPT handle this. This will happen when wrong booking id is used.
  // if (response.status === 401) throw new Error("Unauthorized");

  const data = await response.json();

  if (response.status !== 200) {
    return { error: data.message };
  }

  return "Booking edited";
};

const editBookingTool = (apiKey: string, userId: number) => {
  return new DynamicStructuredTool({
    description: "Edit a booking",
    func: async ({ description, endTime, id, startTime, status, title }) => {
      return JSON.stringify(
        await editBooking({
          apiKey,
          userId,
          description,
          endTime,
          id,
          startTime,
          status,
          title,
        })
      );
    },
    name: "editBooking",
    schema: z.object({
      description: z.string().optional(),
      endTime: z.string().optional(),
      id: z.string(),
      startTime: z.string().optional(),
      status: z.string().optional(),
      title: z.string().optional(),
    }),
  });
};

export default editBookingTool;

export type Availability = {
  busy: {
    start: string;
    end: string;
    title?: string;
  }[];
  timeZone: string;
  dateRanges: {
    start: string;
    end: string;
  }[];
  workingHours: {
    days: number[];
    startTime: number;
    endTime: number;
    userId: number;
  }[];
  dateOverrides: {
    date: string;
    startTime: number;
    endTime: number;
    userId: number;
  };
  currentSeats: number;
};

export type EventType = {
  id: number;
  title: string;
  length: number;
  metadata: object;
  slug: string;
  hosts: {
    userId: number;
    isFixed: boolean;
  }[];
  hidden: boolean;
  // ...
};

export type WorkingHours = {
  days: number[];
  startTime: number;
  endTime: number;
};

export enum BOOKING_STATUS {
  ACCEPTED = "ACCEPTED",
  PENDING = "PENDING",
  CANCELLED = "CANCELLED",
  REJECTED = "REJECTED",
}

export type Booking = {
  id: number;
  userId: number;
  description: string | null;
  eventTypeId: number;
  uid: string;
  title: string;
  startTime: string;
  endTime: string;
  attendees: { email: string; name: string; timeZone: string; locale: string }[] | null;
  user: { email: string; name: string; timeZone: string; locale: string }[] | null;
  payment: { id: number; success: boolean; paymentOption: string }[];
  metadata: object | null;
  status: BOOKING_STATUS;
  responses: { email: string; name: string; location: string } | null;
};
import type { EventType } from "./eventType";
import type { WorkingHours } from "./workingHours";

export type User = {
  id: number;
  email: string;
  username: string;
  timeZone: string;
  eventTypes: EventType[];
  workingHours: WorkingHours[];
};

export type UserList = {
  id?: number;
  email?: string;
  username?: string;
  type: "fromUsername" | "fromEmail";
}[];
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

import agent from "../../../utils/agent";
import sendEmail from "../../../utils/sendEmail";
import { verifyParseKey } from "../../../utils/verifyParseKey";

// Allow agent loop to run for up to 5 minutes
export const maxDuration = 300;

/**
 * Launches a LangChain agent to process an incoming email,
 * then sends the response to the user.
 */
export const POST = async (request: NextRequest) => {
  const verified = verifyParseKey(request.url);

  if (!verified) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  const json = await request.json();

  const { apiKey, userId, message, subject, user, users, replyTo: agentEmail } = json;

  if ((!message && !subject) || !user) {
    return new NextResponse("Missing fields", { status: 400 });
  }

  try {
    const response = await agent(`${subject}\n\n${message}`, { ...user }, users, apiKey, userId, agentEmail);

    // Send response to user
    await sendEmail({
      subject: `Re: ${subject}`,
      text: response.replace(/(?:\r\n|\r|\n)/g, "\n"),
      to: user.email,
      from: agentEmail,
    });

    return new NextResponse("ok");
  } catch (error) {
    await sendEmail({
      subject: `Re: ${subject}`,
      text: "Thanks for using Cal.ai! We're experiencing high demand and can't currently process your request. Please try again later.",
      to: user.email,
      from: agentEmail,
    });

    return new NextResponse(
      (error as Error).message || "Something went wrong. Please try again or reach out for help.",
      { status: 500 }
    );
  }
};
import type { NextRequest } from "next/server";

import prisma from "@calcom/prisma";

import { env } from "../../../env.mjs";
import sendEmail from "../../../utils/sendEmail";

export const POST = async (request: NextRequest) => {
  const { userId } = await request.json();

  const user = await prisma.user.findUnique({
    select: {
      email: true,
      name: true,
      username: true,
    },
    where: {
      id: userId,
    },
  });

  if (!user) {
    return new Response("User not found", { status: 404 });
  }

  await sendEmail({
    subject: "Welcome to Cal AI",
    to: user.email,
    from: `${user.username}@${env.SENDER_DOMAIN}`,
    text: `Hi ${
      user.name || `@${user.username}`
    },\n\nI'm Cal AI, your personal booking assistant! I'll be here, 24/7 to help manage your busy schedule and find times to meet with the people you care about.\n\nHere are some things you can ask me:\n\n- "Book a meeting with @someone" (The @ symbol lets you tag Cal.com users)\n- "What meetings do I have today?" (I'll show you your schedule)\n- "Find a time for coffee with someone@gmail.com" (I'll intro and send them some good times)\n\nI'm still learning, so if you have any feedback, please tweet it to @calcom!\n\nRemember, you can always reach me here, at ${
      user.username
    }@${
      env.SENDER_DOMAIN
    }.\n\nLooking forward to working together (:\n\n- Cal AI, Your personal booking assistant`,
    html: `Hi ${
      user.name || `@${user.username}`
    },<br><br>I'm Cal AI, your personal booking assistant! I'll be here, 24/7 to help manage your busy schedule and find times to meet with the people you care about.<br><br>Here are some things you can ask me:<br><br>- "Book a meeting with @someone" (The @ symbol lets you tag Cal.com users)<br>- "What meetings do I have today?" (I'll show you your schedule)<br>- "Find a time for coffee with someone@gmail.com" (I'll intro and send them some good times)<br><br>I'm still learning, so if you have any feedback, please send it to <a href="https://twitter.com/calcom">@calcom</a> on X!<br><br>Remember, you can always reach me here, at ${
      user.username
    }@${env.SENDER_DOMAIN}.<br><br>Looking forward to working together (:<br><br>- Cal AI`,
  });
  return new Response("OK", { status: 200 });
};
import type { ParsedMail, Source } from "mailparser";
import { simpleParser } from "mailparser";
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

import { checkRateLimitAndThrowError } from "@calcom/lib/checkRateLimitAndThrowError";
import prisma from "@calcom/prisma";

import { env } from "../../../env.mjs";
import { fetchAvailability } from "../../../tools/getAvailability";
import { fetchEventTypes } from "../../../tools/getEventTypes";
import { extractUsers } from "../../../utils/extractUsers";
import getHostFromHeaders from "../../../utils/host";
import now from "../../../utils/now";
import sendEmail from "../../../utils/sendEmail";
import { verifyParseKey } from "../../../utils/verifyParseKey";

// Allow receive loop to run for up to 30 seconds
// Why so long? the rate determining API call (getAvailability, getEventTypes) can take up to 15 seconds at peak times so we give it a little extra time to complete.
export const maxDuration = 30;

/**
 * Verifies email signature and app authorization,
 * then hands off to booking agent.
 */
export const POST = async (request: NextRequest) => {
  const verified = verifyParseKey(request.url);

  if (!verified) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  const formData = await request.formData();
  const body = Object.fromEntries(formData);
  const envelope = JSON.parse(body.envelope as string);

  const aiEmail = envelope.to[0];
  const subject = body.subject || "";

  try {
    await checkRateLimitAndThrowError({
      identifier: `ai:email:${envelope.from}`,
      rateLimitingType: "ai",
    });
  } catch (error) {
    await sendEmail({
      subject: `Re: ${subject}`,
      text: "Thanks for using Cal.ai! You've reached your daily limit. Please try again tomorrow.",
      to: envelope.from,
      from: aiEmail,
    });

    return new NextResponse("Exceeded rate limit", { status: 200 }); // Don't return 429 to avoid triggering retry logic in SendGrid
  }

  // Parse email from mixed MIME type
  const parsed: ParsedMail = await simpleParser(body.email as Source);

  if (!parsed.text && !parsed.subject) {
    await sendEmail({
      subject: `Re: ${subject}`,
      text: "Thanks for using Cal.ai! It looks like you forgot to include a message. Please try again.",
      to: envelope.from,
      from: aiEmail,
    });

    return new NextResponse("Email missing text and subject", { status: 400 });
  }

  const user = await prisma.user.findUnique({
    select: {
      email: true,
      id: true,
      username: true,
      timeZone: true,
      credentials: {
        select: {
          appId: true,
          key: true,
        },
      },
    },
    where: { email: envelope.from },
  });

  // body.dkim looks like {@domain-com.22222222.gappssmtp.com : pass}
  const signature = (body.dkim as string).includes(" : pass");

  // User is not a cal.com user or is using an unverified email.
  if (!signature || !user) {
    await sendEmail({
      html: `Thanks for your interest in Cal.ai! To get started, Make sure you have a <a href="https://cal.com/signup" target="_blank">cal.com</a> account with this email address and then install Cal.ai here: <a href="https://go.cal.com/ai" target="_blank">go.cal.com/ai</a>.`,
      subject: `Re: ${subject}`,
      text: `Thanks for your interest in Cal.ai! To get started, Make sure you have a cal.com account with this email address. You can sign up for an account at: https://cal.com/signup`,
      to: envelope.from,
      from: aiEmail,
    });

    return new NextResponse("ok");
  }

  const credential = user.credentials.find((c) => c.appId === env.APP_ID)?.key;

  // User has not installed the app from the app store. Direct them to install it.
  if (!(credential as { apiKey: string })?.apiKey) {
    const url = env.APP_URL;

    await sendEmail({
      html: `Thanks for using Cal.ai! To get started, the app must be installed. <a href=${url} target="_blank">Click this link</a> to install it.`,
      subject: `Re: ${subject}`,
      text: `Thanks for using Cal.ai! To get started, the app must be installed. Click this link to install the Cal.ai app: ${url}`,
      to: envelope.from,
      from: aiEmail,
    });

    return new NextResponse("ok");
  }

  const { apiKey } = credential as { apiKey: string };

  // Pre-fetch data relevant to most bookings.
  const [eventTypes, availability, users] = await Promise.all([
    fetchEventTypes({
      apiKey,
    }),
    fetchAvailability({
      apiKey,
      userId: user.id,
      dateFrom: now(user.timeZone),
      dateTo: now(user.timeZone),
    }),
    extractUsers(`${parsed.text} ${parsed.subject}`),
  ]);

  if ("error" in availability) {
    await sendEmail({
      subject: `Re: ${subject}`,
      text: "Sorry, there was an error fetching your availability. Please try again.",
      to: user.email,
      from: aiEmail,
    });
    console.error(availability.error);

    return new NextResponse("Error fetching availability. Please try again.", { status: 400 });
  }

  if ("error" in eventTypes) {
    await sendEmail({
      subject: `Re: ${subject}`,
      text: "Sorry, there was an error fetching your event types. Please try again.",
      to: user.email,
      from: aiEmail,
    });
    console.error(eventTypes.error);

    return new NextResponse("Error fetching event types. Please try again.", { status: 400 });
  }

  const { workingHours } = availability;

  const appHost = getHostFromHeaders(request.headers);

  // Hand off to long-running agent endpoint to handle the email. (don't await)
  fetch(`${appHost}/api/agent?parseKey=${env.PARSE_KEY}`, {
    body: JSON.stringify({
      apiKey,
      userId: user.id,
      message: parsed.text || "",
      subject: parsed.subject || "",
      replyTo: aiEmail,
      user: {
        email: user.email,
        eventTypes,
        username: user.username,
        timeZone: user.timeZone,
        workingHours,
      },
      users,
    }),
    headers: {
      "Content-Type": "application/json",
    },
    method: "POST",
  });

  await new Promise((r) => setTimeout(r, 1000));

  return new NextResponse("ok");
};
import type { NextRequest } from "next/server";

import { env } from "../env.mjs";

/**
 * Verifies that the request contains the correct parse key.
 * env.PARSE_KEY must be configured as a query param in the sendgrid inbound parse settings.
 */
export const verifyParseKey = (url: NextRequest["url"]) => {
  const verified = new URL(url).searchParams.get("parseKey") === env.PARSE_KEY;

  return verified;
};
import prisma from "@calcom/prisma";

import type { UserList } from "../types/user";

/*
 * Extracts usernames (@Example) and emails (hi@example.com) from a string
 */
export const extractUsers = async (text: string) => {
  const usernames = text
    .match(/(?<![a-zA-Z0-9_.])@[a-zA-Z0-9_]+/g)
    ?.map((username) => username.slice(1).toLowerCase());
  const emails = text
    .match(/[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+/g)
    ?.map((email) => email.toLowerCase());

  const dbUsersFromUsernames = usernames
    ? await prisma.user.findMany({
        select: {
          id: true,
          username: true,
          email: true,
        },
        where: {
          username: {
            in: usernames,
          },
        },
      })
    : [];

  const usersFromUsernames = usernames
    ? usernames.map((username) => {
        const user = dbUsersFromUsernames.find((u) => u.username === username);

        return user
          ? {
              username,
              id: user.id,
              email: user.email,
              type: "fromUsername",
            }
          : {
              username,
              id: null,
              email: null,
              type: "fromUsername",
            };
      })
    : [];

  const dbUsersFromEmails = emails
    ? await prisma.user.findMany({
        select: {
          id: true,
          email: true,
          username: true,
        },
        where: {
          email: {
            in: emails,
          },
        },
      })
    : [];

  const usersFromEmails = emails
    ? emails.map((email) => {
        const user = dbUsersFromEmails.find((u) => u.email === email);

        return user
          ? {
              email,
              id: user.id,
              username: user.username,
              type: "fromEmail",
            }
          : {
              email,
              id: null,
              username: null,
              type: "fromEmail",
            };
      })
    : [];

  return [...usersFromUsernames, ...usersFromEmails] as UserList;
};
import { initializeAgentExecutorWithOptions } from "langchain/agents";
import { ChatOpenAI } from "langchain/chat_models/openai";

import { env } from "../env.mjs";
import createBookingIfAvailable from "../tools/createBooking";
import deleteBooking from "../tools/deleteBooking";
import getAvailability from "../tools/getAvailability";
import getBookings from "../tools/getBookings";
import sendBookingEmail from "../tools/sendBookingEmail";
import updateBooking from "../tools/updateBooking";
import type { EventType } from "../types/eventType";
import type { User, UserList } from "../types/user";
import type { WorkingHours } from "../types/workingHours";
import now from "./now";

const gptModel = "gpt-4-0613";

/**
 * Core of the Cal.ai booking agent: a LangChain Agent Executor.
 * Uses a toolchain to book meetings, list available slots, etc.
 * Uses OpenAI functions to better enforce JSON-parsable output from the LLM.
 */
const agent = async (
  input: string,
  user: User,
  users: UserList,
  apiKey: string,
  userId: number,
  agentEmail: string
) => {
  const tools = [
    // getEventTypes(apiKey),
    getAvailability(apiKey),
    getBookings(apiKey, userId),
    createBookingIfAvailable(apiKey, userId, users),
    updateBooking(apiKey, userId),
    deleteBooking(apiKey),
    sendBookingEmail(apiKey, user, users, agentEmail),
  ];

  const model = new ChatOpenAI({
    modelName: gptModel,
    openAIApiKey: env.OPENAI_API_KEY,
    temperature: 0,
  });

  /**
   * Initialize the agent executor with arguments.
   */
  const executor = await initializeAgentExecutorWithOptions(tools, model, {
    agentArgs: {
      prefix: `You are Cal.ai - a bleeding edge scheduling assistant that interfaces via email.
Make sure your final answers are definitive, complete and well formatted.
Sometimes, tools return errors. In this case, try to handle the error intelligently or ask the user for more information.
Tools will always handle times in UTC, but times sent to users should be formatted per that user's timezone.
In responses to users, always summarize necessary context and open the door to follow ups. For example "I have booked your chat with @username for 3pm on Wednesday, December 20th, 2023 EST. Please let me know if you need to reschedule."
If you can't find a referenced user, ask the user for their email or @username. Make sure to specify that usernames require the @username format. Users don't know other users' userIds.

The primary user's id is: ${userId}
The primary user's username is: ${user.username}
The current time in the primary user's timezone is: ${now(user.timeZone, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
      })}
The primary user's time zone is: ${user.timeZone}
The primary user's event types are: ${user.eventTypes
        .map((e: EventType) => `ID: ${e.id}, Slug: ${e.slug}, Title: ${e.title}, Length: ${e.length};`)
        .join("\n")}
The primary user's working hours are: ${user.workingHours
        .map(
          (w: WorkingHours) =>
            `Days: ${w.days.join(", ")}, Start Time (minutes in UTC): ${
              w.startTime
            }, End Time (minutes in UTC): ${w.endTime};`
        )
        .join("\n")}
${
  users.length
    ? `The email references the following @usernames and emails: ${users
        .map(
          (u) =>
            `${
              (u.id ? `, id: ${u.id}` : "id: (non user)") +
              (u.username
                ? u.type === "fromUsername"
                  ? `, username: @${u.username}`
                  : ", username: REDACTED"
                : ", (no username)") +
              (u.email
                ? u.type === "fromEmail"
                  ? `, email: ${u.email}`
                  : ", email: REDACTED"
                : ", (no email)")
            };`
        )
        .join("\n")}`
    : ""
}
            `,
    },
    agentType: "openai-functions",
    returnIntermediateSteps: env.NODE_ENV === "development",
    verbose: env.NODE_ENV === "development",
  });

  const result = await executor.call({ input });
  const { output } = result;

  return output;
};

export default agent;

export const context = { apiKey: "", userId: "" };
import mail from "@sendgrid/mail";

const sendgridAPIKey = process.env.SENDGRID_API_KEY as string;

/**
 * Simply send an email by address, subject, and body.
 */
const send = async ({
  subject,
  to,
  cc,
  from,
  text,
  html,
}: {
  subject: string;
  to: string | string[];
  cc?: string | string[];
  from: string;
  text: string;
  html?: string;
}): Promise<boolean> => {
  mail.setApiKey(sendgridAPIKey);

  const msg = {
    to,
    cc,
    from: {
      email: from,
      name: "Cal.ai",
    },
    text,
    html,
    subject,
  };

  const res = await mail.send(msg);
  const success = !!res;

  return success;
};

export default send;

export default function now(timeZone: string, options: Intl.DateTimeFormatOptions = {}) {
  return new Date().toLocaleString("en-US", {
    timeZone,
    ...options,
  });
}
import type { NextRequest } from "next/server";

const getHostFromHeaders = (headers: NextRequest["headers"]): string => {
  return `https://${headers.get("host")}`;
};

export default getHostFromHeaders;
import type { Request, Response } from "express";
import type { NextApiRequest, NextApiResponse } from "next";
import { createMocks } from "node-mocks-http";
import { describe, vi, it, expect, afterEach } from "vitest";

import { addRequestId } from "../../../lib/helpers/addRequestid";

type CustomNextApiRequest = NextApiRequest & Request;
type CustomNextApiResponse = NextApiResponse & Response;

afterEach(() => {
  vi.resetAllMocks();
});

describe("Adds a request ID", () => {
  it("Should attach a request ID to the request", async () => {
    const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
      method: "POST",
      body: {},
    });

    const middleware = {
      fn: addRequestId,
    };

    const serverNext = vi.fn((next: void) => Promise.resolve(next));

    const middlewareSpy = vi.spyOn(middleware, "fn");

    await middleware.fn(req, res, serverNext);

    expect(middlewareSpy).toBeCalled();
    expect(res.statusCode).toBe(200);
    expect(res.getHeader("Calcom-Response-ID")).toBeDefined();
  });
});
import type { Request, Response } from "express";
import type { NextApiRequest, NextApiResponse } from "next";
import { createMocks } from "node-mocks-http";
import { describe, vi, it, expect, afterEach } from "vitest";

import { httpMethod } from "../../../lib/helpers/httpMethods";

type CustomNextApiRequest = NextApiRequest & Request;
type CustomNextApiResponse = NextApiResponse & Response;

afterEach(() => {
  vi.resetAllMocks();
});

describe("HTTP Methods function only allows the correct HTTP Methods", () => {
  it("Should allow the passed in Method", async () => {
    const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
      method: "POST",
      body: {},
    });

    const middleware = {
      fn: httpMethod("POST"),
    };

    const serverNext = vi.fn((next: void) => Promise.resolve(next));

    const middlewareSpy = vi.spyOn(middleware, "fn");

    await middleware.fn(req, res, serverNext);

    expect(middlewareSpy).toBeCalled();
    expect(res.statusCode).toBe(200);
  });
  it("Should allow the passed in Method", async () => {
    const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
      method: "POST",
      body: {},
    });

    const middleware = {
      fn: httpMethod("GET"),
    };

    const serverNext = vi.fn((next: void) => Promise.resolve(next));

    const middlewareSpy = vi.spyOn(middleware, "fn");

    await middleware.fn(req, res, serverNext);

    expect(middlewareSpy).toBeCalled();
    expect(res.statusCode).toBe(405);
  });
});
import type { Request, Response } from "express";
import type { NextApiRequest, NextApiResponse } from "next";
import { createMocks } from "node-mocks-http";
import { describe, vi, it, expect, afterEach } from "vitest";

import checkLicense from "@calcom/features/ee/common/server/checkLicense";

import { isAdminGuard } from "~/lib/utils/isAdmin";

import { verifyApiKey } from "../../../lib/helpers/verifyApiKey";

type CustomNextApiRequest = NextApiRequest & Request;
type CustomNextApiResponse = NextApiResponse & Response;

afterEach(() => {
  vi.resetAllMocks();
});

vi.mock("@calcom/features/ee/common/server/checkLicense", () => {
  return {
    default: vi.fn(),
  };
});

vi.mock("~/lib/utils/isAdmin", () => {
  return {
    isAdminGuard: vi.fn(),
  };
});

describe("Verify API key", () => {
  it("It should throw an error if the api key is not valid", async () => {
    const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
      method: "POST",
      body: {},
    });

    const middleware = {
      fn: verifyApiKey,
    };

    vi.mocked(checkLicense).mockResolvedValue(false);
    vi.mocked(isAdminGuard).mockResolvedValue(false);

    const serverNext = vi.fn((next: void) => Promise.resolve(next));

    const middlewareSpy = vi.spyOn(middleware, "fn");

    await middleware.fn(req, res, serverNext);

    expect(middlewareSpy).toBeCalled();
    expect(res.statusCode).toBe(401);
  });
  it("It should thow an error if no api key is provided", async () => {
    const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
      method: "POST",
      body: {},
    });

    const middleware = {
      fn: verifyApiKey,
    };

    vi.mocked(checkLicense).mockResolvedValue(true);
    vi.mocked(isAdminGuard).mockResolvedValue(false);

    const serverNext = vi.fn((next: void) => Promise.resolve(next));

    const middlewareSpy = vi.spyOn(middleware, "fn");

    await middleware.fn(req, res, serverNext);

    expect(middlewareSpy).toBeCalled();
    expect(res.statusCode).toBe(401);
  });
});
import { describe, vi, it, expect, afterEach } from "vitest";

import { middlewareOrder } from "../../../lib/helpers/withMiddleware";

afterEach(() => {
  vi.resetAllMocks();
});

// Not sure if there is much point testing this order is actually applied via an integration test:
// It is tested internally https://github.com/htunnicliff/next-api-middleware/blob/368b12aa30e79f4bd7cfe7aacc18da263cc3de2f/lib/label.spec.ts#L62
describe("API - withMiddleware test", () => {
  it("Custom prisma should be before verifyApiKey", async () => {
    const customPrismaClientIndex = middlewareOrder.indexOf("customPrismaClient");

    const verifyApiKeyIndex = middlewareOrder.indexOf("verifyApiKey");
    expect(customPrismaClientIndex).toBeLessThan(verifyApiKeyIndex);
  });
});
// TODO: Fix tests (These test were never running due to the vitest workspace config)
import prismaMock from "../../../../../tests/libs/__mocks__/prisma";

import type { Request, Response } from "express";
import type { NextApiRequest, NextApiResponse } from "next";
import { createMocks } from "node-mocks-http";
import { describe, expect, test, vi } from "vitest";

import dayjs from "@calcom/dayjs";
import sendPayload from "@calcom/features/webhooks/lib/sendPayload";
import { ErrorCode } from "@calcom/lib/errorCodes";
import { buildBooking, buildEventType, buildWebhook } from "@calcom/lib/test/builder";
import prisma from "@calcom/prisma";

import handler from "../../../pages/api/bookings/_post";

type CustomNextApiRequest = NextApiRequest & Request;
type CustomNextApiResponse = NextApiResponse & Response;
vi.mock("@calcom/features/webhooks/lib/sendPayload");
vi.mock("@calcom/lib/server/i18n", () => {
  return {
    getTranslation: (key: string) => key,
  };
});

describe.skipIf(true)("POST /api/bookings", () => {
  describe("Errors", () => {
    test("Missing required data", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "POST",
        body: {},
      });

      await handler(req, res);

      expect(res.statusCode).toBe(400);
      expect(JSON.parse(res._getData())).toEqual(
        expect.objectContaining({
          message:
            "invalid_type in 'eventTypeId': Required; invalid_type in 'title': Required; invalid_type in 'startTime': Required; invalid_type in 'startTime': Required; invalid_type in 'endTime': Required; invalid_type in 'endTime': Required",
        })
      );
    });

    test("Invalid eventTypeId", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "POST",
        body: {
          title: "test",
          eventTypeId: 2,
          startTime: dayjs().toDate(),
          endTime: dayjs().add(1, "day").toDate(),
        },
        prisma,
      });

      prismaMock.eventType.findUnique.mockResolvedValue(null);

      await handler(req, res);

      expect(res._getStatusCode()).toBe(400);
      expect(JSON.parse(res._getData())).toEqual(
        expect.objectContaining({
          message:
            "'invalid_type' in 'email': Required; 'invalid_type' in 'end': Required; 'invalid_type' in 'location': Required; 'invalid_type' in 'name': Required; 'invalid_type' in 'start': Required; 'invalid_type' in 'timeZone': Required; 'invalid_type' in 'language': Required; 'invalid_type' in 'customInputs': Required; 'invalid_type' in 'metadata': Required",
        })
      );
    });

    test("Missing recurringCount", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "POST",
        body: {
          title: "test",
          eventTypeId: 2,
          startTime: dayjs().toDate(),
          endTime: dayjs().add(1, "day").toDate(),
        },
        prisma,
      });

      prismaMock.eventType.findUnique.mockResolvedValue(
        buildEventType({ recurringEvent: { freq: 2, count: 12, interval: 1 } })
      );

      await handler(req, res);

      expect(res._getStatusCode()).toBe(400);
      expect(JSON.parse(res._getData())).toEqual(
        expect.objectContaining({
          message:
            "'invalid_type' in 'email': Required; 'invalid_type' in 'end': Required; 'invalid_type' in 'location': Required; 'invalid_type' in 'name': Required; 'invalid_type' in 'start': Required; 'invalid_type' in 'timeZone': Required; 'invalid_type' in 'language': Required; 'invalid_type' in 'customInputs': Required; 'invalid_type' in 'metadata': Required",
        })
      );
    });

    test("Invalid recurringCount", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "POST",
        body: {
          title: "test",
          eventTypeId: 2,
          startTime: dayjs().toDate(),
          endTime: dayjs().add(1, "day").toDate(),
          recurringCount: 15,
        },
        prisma,
      });

      prismaMock.eventType.findUnique.mockResolvedValue(
        buildEventType({ recurringEvent: { freq: 2, count: 12, interval: 1 } })
      );

      await handler(req, res);

      expect(res._getStatusCode()).toBe(400);
      expect(JSON.parse(res._getData())).toEqual(
        expect.objectContaining({
          message:
            "'invalid_type' in 'email': Required; 'invalid_type' in 'end': Required; 'invalid_type' in 'location': Required; 'invalid_type' in 'name': Required; 'invalid_type' in 'start': Required; 'invalid_type' in 'timeZone': Required; 'invalid_type' in 'language': Required; 'invalid_type' in 'customInputs': Required; 'invalid_type' in 'metadata': Required",
        })
      );
    });

    test("No available users", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "POST",
        body: {
          name: "test",
          start: dayjs().format(),
          end: dayjs().add(1, "day").format(),
          eventTypeId: 2,
          email: "test@example.com",
          location: "Cal.com Video",
          timeZone: "America/Montevideo",
          language: "en",
          customInputs: [],
          metadata: {},
          userId: 4,
        },
        prisma,
      });

      prismaMock.eventType.findUniqueOrThrow.mockResolvedValue(buildEventType());

      await handler(req, res);
      console.log({ statusCode: res._getStatusCode(), data: JSON.parse(res._getData()) });

      expect(res._getStatusCode()).toBe(500);
      expect(JSON.parse(res._getData())).toEqual(
        expect.objectContaining({
          message: ErrorCode.NoAvailableUsersFound,
        })
      );
    });
  });

  describe("Success", () => {
    describe("Regular event-type", () => {
      test("Creates one single booking", async () => {
        const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
          method: "POST",
          body: {
            name: "test",
            start: dayjs().format(),
            end: dayjs().add(1, "day").format(),
            eventTypeId: 2,
            email: "test@example.com",
            location: "Cal.com Video",
            timeZone: "America/Montevideo",
            language: "en",
            customInputs: [],
            metadata: {},
            userId: 4,
          },
          prisma,
        });

        prismaMock.eventType.findUniqueOrThrow.mockResolvedValue(buildEventType());
        prismaMock.booking.findMany.mockResolvedValue([]);

        await handler(req, res);
        console.log({ statusCode: res._getStatusCode(), data: JSON.parse(res._getData()) });

        expect(prismaMock.booking.create).toHaveBeenCalledTimes(1);
      });
    });

    describe("Recurring event-type", () => {
      test("Creates multiple bookings", async () => {
        const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
          method: "POST",
          body: {
            title: "test",
            eventTypeId: 2,
            startTime: dayjs().toDate(),
            endTime: dayjs().add(1, "day").toDate(),
            recurringCount: 12,
          },
          prisma,
        });

        prismaMock.eventType.findUnique.mockResolvedValue(
          buildEventType({ recurringEvent: { freq: 2, count: 12, interval: 1 } })
        );

        Array.from(Array(12).keys()).map(async () => {
          prismaMock.booking.create.mockResolvedValue(buildBooking());
        });

        prismaMock.webhook.findMany.mockResolvedValue([]);

        await handler(req, res);

        const data = JSON.parse(res._getData());

        expect(prismaMock.booking.create).toHaveBeenCalledTimes(12);
        expect(res._getStatusCode()).toBe(201);
        expect(data.message).toEqual("Bookings created successfully.");
        expect(data.bookings.length).toEqual(12);
      });
    });
    test("Notifies multiple bookings", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "POST",
        body: {
          title: "test",
          eventTypeId: 2,
          startTime: dayjs().toDate(),
          endTime: dayjs().add(1, "day").toDate(),
          recurringCount: 12,
        },
        prisma,
      });

      prismaMock.eventType.findUnique.mockResolvedValue(
        buildEventType({ recurringEvent: { freq: 2, count: 12, interval: 1 } })
      );

      const createdAt = new Date();
      Array.from(Array(12).keys()).map(async () => {
        prismaMock.booking.create.mockResolvedValue(buildBooking({ createdAt }));
      });

      const mockedWebhooks = [
        buildWebhook({
          subscriberUrl: "http://mockedURL1.com",
          createdAt,
          eventTypeId: 1,
          secret: "secret1",
        }),
        buildWebhook({
          subscriberUrl: "http://mockedURL2.com",
          createdAt,
          eventTypeId: 2,
          secret: "secret2",
        }),
      ];
      prismaMock.webhook.findMany.mockResolvedValue(mockedWebhooks);

      await handler(req, res);
      const data = JSON.parse(res._getData());

      expect(sendPayload).toHaveBeenCalledTimes(24);
      expect(data.message).toEqual("Bookings created successfully.");
      expect(data.bookings.length).toEqual(12);
    });
  });
});
import type { Session } from "next-auth";
import type { NextApiRequest as BaseNextApiRequest } from "next/types";

import type { PrismaClient } from "@calcom/prisma";

export type * from "next/types";

export declare module "next" {
  interface NextApiRequest extends BaseNextApiRequest {
    session?: Session | null;

    userId: number;
    method: string;
    prisma: PrismaClient;
    // session: { user: { id: number } };
    // query: Partial<{ [key: string]: string | string[] }>;
    isAdmin: boolean;
    isCustomPrisma: boolean;
    pagination: { take: number; skip: number };
  }
}
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
});
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
export {};
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
});
import type { NextApiRequest } from "next";

import { UserPermissionRole } from "@calcom/prisma/enums";

export const isAdminGuard = async (req: NextApiRequest) => {
  const { userId, prisma } = req;
  const user = await prisma.user.findUnique({ where: { id: userId } });
  return user?.role === UserPermissionRole.ADMIN;
};
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";

export function extractUserIdsFromQuery({ isAdmin, query }: NextApiRequest) {
  /** Guard: Only admins can query other users */
  if (!isAdmin) {
    throw new HttpError({ statusCode: 401, message: "ADMIN required" });
  }
  const { userId: userIdOrUserIds } = schemaQuerySingleOrMultipleUserIds.parse(query);
  return Array.isArray(userIdOrUserIds) ? userIdOrUserIds : [userIdOrUserIds];
}
export const stringifyISODate = (date: Date | undefined): string => {
  return `${date?.toISOString()}`;
};
// TODO: create a function that takes an object and returns a stringified version of dates of it.
export function isValidBase64Image(input: string): boolean {
  const regex = /^data:image\/[^;]+;base64,(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
  return regex.test(input);
}
import { _PaymentModel as Payment } from "@calcom/prisma/zod";

// FIXME: Payment seems a delicate endpoint, do we need to remove anything here?
export const schemaPaymentBodyParams = Payment.omit({ id: true });

export const schemaPaymentPublic = Payment.omit({ externalId: true });
import { z } from "zod";

import { _DestinationCalendarModel as DestinationCalendar } from "@calcom/prisma/zod";

export const schemaDestinationCalendarBaseBodyParams = DestinationCalendar.pick({
  integration: true,
  externalId: true,
  eventTypeId: true,
  bookingId: true,
  userId: true,
}).partial();

const schemaDestinationCalendarCreateParams = z
  .object({
    integration: z.string(),
    externalId: z.string(),
    eventTypeId: z.number().optional(),
    bookingId: z.number().optional(),
    userId: z.number().optional(),
  })
  .strict();

export const schemaDestinationCalendarCreateBodyParams = schemaDestinationCalendarBaseBodyParams.merge(
  schemaDestinationCalendarCreateParams
);

const schemaDestinationCalendarEditParams = z
  .object({
    integration: z.string().optional(),
    externalId: z.string().optional(),
    eventTypeId: z.number().optional(),
    bookingId: z.number().optional(),
    userId: z.number().optional(),
  })
  .strict();

export const schemaDestinationCalendarEditBodyParams = schemaDestinationCalendarBaseBodyParams.merge(
  schemaDestinationCalendarEditParams
);

export const schemaDestinationCalendarReadPublic = DestinationCalendar.pick({
  id: true,
  integration: true,
  externalId: true,
  eventTypeId: true,
  bookingId: true,
  userId: true,
});
import { z } from "zod";

import { MembershipRole } from "@calcom/prisma/enums";
import { _MembershipModel as Membership, _TeamModel } from "@calcom/prisma/zod";
import { stringOrNumber } from "@calcom/prisma/zod-utils";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

export const schemaMembershipBaseBodyParams = Membership.omit({});

const schemaMembershipRequiredParams = z.object({
  teamId: z.number(),
});

export const membershipCreateBodySchema = Membership.omit({ id: true })
  .partial({
    accepted: true,
    role: true,
    disableImpersonation: true,
  })
  .transform((v) => ({
    accepted: false,
    role: MembershipRole.MEMBER,
    disableImpersonation: false,
    ...v,
  }));

export const membershipEditBodySchema = Membership.omit({
  /** To avoid complication, let's avoid updating these, instead you can delete and create a new invite */
  teamId: true,
  userId: true,
  id: true,
})
  .partial({
    accepted: true,
    role: true,
    disableImpersonation: true,
  })
  .strict();

export const schemaMembershipBodyParams = schemaMembershipBaseBodyParams.merge(
  schemaMembershipRequiredParams
);

export const schemaMembershipPublic = Membership.merge(z.object({ team: _TeamModel }).partial());

/** We extract userId and teamId from compound ID string */
export const membershipIdSchema = schemaQueryIdAsString
  // So we can query additional team data in memberships
  .merge(z.object({ teamId: z.union([stringOrNumber, z.array(stringOrNumber)]) }).partial())
  .transform((v, ctx) => {
    const [userIdStr, teamIdStr] = v.id.split("_");

    const userIdInt = schemaQueryIdParseInt.safeParse({ id: userIdStr });

    const teamIdInt = schemaQueryIdParseInt.safeParse({ id: teamIdStr });

    if (!userIdInt.success) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, message: "userId is not a number" });
      return z.NEVER;
    }
    if (!teamIdInt.success) {
      ctx.addIssue({ code: z.ZodIssueCode.custom, message: "teamId is not a number " });
      return z.NEVER;
    }
    return {
      userId: userIdInt.data.id,
      teamId: teamIdInt.data.id,
    };
  });
import { z } from "zod";

import { _AvailabilityModel as Availability, _ScheduleModel as Schedule } from "@calcom/prisma/zod";
import { denullishShape } from "@calcom/prisma/zod-utils";

export const schemaAvailabilityBaseBodyParams = /** We make all these properties required */ denullishShape(
  Availability.pick({
    /** We need to pass the schedule where this availability belongs to */
    scheduleId: true,
  })
);

export const schemaAvailabilityReadPublic = Availability.pick({
  id: true,
  startTime: true,
  endTime: true,
  date: true,
  scheduleId: true,
  days: true,
  // eventTypeId: true /** @deprecated */,
  // userId: true /** @deprecated */,
}).merge(z.object({ success: z.boolean().optional(), Schedule: Schedule.partial() }).partial());

const schemaAvailabilityCreateParams = z
  .object({
    startTime: z.date().or(z.string()),
    endTime: z.date().or(z.string()),
    days: z.array(z.number()).optional(),
    date: z.date().or(z.string()).optional(),
  })
  .strict();

const schemaAvailabilityEditParams = z
  .object({
    startTime: z.date().or(z.string()).optional(),
    endTime: z.date().or(z.string()).optional(),
    days: z.array(z.number()).optional(),
    date: z.date().or(z.string()).optional(),
  })
  .strict();

export const schemaAvailabilityEditBodyParams = schemaAvailabilityEditParams;

export const schemaAvailabilityCreateBodyParams = schemaAvailabilityBaseBodyParams.merge(
  schemaAvailabilityCreateParams
);

export const schemaAvailabilityReadBodyParams = z
  .object({
    userId: z.union([z.number(), z.array(z.number())]),
  })
  .partial();

export const schemaSingleAvailabilityReadBodyParams = z.object({
  userId: z.number(),
});
import { z } from "zod";

import dayjs from "@calcom/dayjs";
import { _ScheduleModel as Schedule, _AvailabilityModel as Availability } from "@calcom/prisma/zod";

import { timeZone } from "./shared/timeZone";

const schemaScheduleBaseBodyParams = Schedule.omit({ id: true, timeZone: true }).partial();

export const schemaSingleScheduleBodyParams = schemaScheduleBaseBodyParams.merge(
  z.object({ userId: z.number().optional(), timeZone: timeZone.optional() })
);

export const schemaCreateScheduleBodyParams = schemaScheduleBaseBodyParams.merge(
  z.object({ userId: z.number().optional(), name: z.string(), timeZone })
);

export const schemaSchedulePublic = z
  .object({ id: z.number() })
  .merge(Schedule)
  .merge(
    z.object({
      availability: z
        .array(
          Availability.pick({
            id: true,
            eventTypeId: true,
            date: true,
            days: true,
            startTime: true,
            endTime: true,
          })
        )
        .transform((v) =>
          v.map((item) => ({
            ...item,
            startTime: dayjs.utc(item.startTime).format("HH:mm:ss"),
            endTime: dayjs.utc(item.endTime).format("HH:mm:ss"),
          }))
        )
        .optional(),
    })
  );
import { z } from "zod";

import { _AttendeeModel as Attendee } from "@calcom/prisma/zod";

import { timeZone } from "~/lib/validations/shared/timeZone";

export const schemaAttendeeBaseBodyParams = Attendee.pick({
  bookingId: true,
  email: true,
  name: true,
  timeZone: true,
});

const schemaAttendeeCreateParams = z
  .object({
    bookingId: z.number().int(),
    email: z.string().email(),
    name: z.string(),
    timeZone: timeZone,
  })
  .strict();

const schemaAttendeeEditParams = z
  .object({
    name: z.string().optional(),
    email: z.string().email().optional(),
    timeZone: timeZone.optional(),
  })
  .strict();

export const schemaAttendeeEditBodyParams = schemaAttendeeBaseBodyParams.merge(schemaAttendeeEditParams);

export const schemaAttendeeCreateBodyParams = schemaAttendeeBaseBodyParams.merge(schemaAttendeeCreateParams);

export const schemaAttendeeReadPublic = Attendee.pick({
  id: true,
  bookingId: true,
  name: true,
  email: true,
  timeZone: true,
});
import tzdata from "tzdata";
import * as z from "zod";

// @note: This is a custom validation that checks if the timezone is valid and exists in the tzdb library
export const timeZone = z.string().refine((tz: string) => Object.keys(tzdata.zones).includes(tz), {
  message: `Expected one of the following: ${Object.keys(tzdata.zones).join(", ")}`,
});
import { z } from "zod";

// Helper schema for JSON fields
type Literal = boolean | number | string;
type Json = Literal | { [key: string]: Json } | Json[];

const literalSchema = z.union([z.string(), z.number(), z.boolean()]);

export const jsonSchema: z.ZodSchema<Json> = z.lazy(() =>
  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])
);
import { withValidation } from "next-validations";
import { z } from "zod";

import { baseApiParams } from "./baseApiParams";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
export const schemaQueryIdParseInt = baseApiParams.extend({
  id: z.coerce.number(),
});

export const withValidQueryIdTransformParseInt = withValidation({
  schema: schemaQueryIdParseInt,
  type: "Zod",
  mode: "query",
});
import { withValidation } from "next-validations";
import { z } from "zod";

import { stringOrNumber } from "@calcom/prisma/zod-utils";

import { baseApiParams } from "./baseApiParams";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
export const schemaQueryUserId = baseApiParams.extend({
  userId: stringOrNumber,
});

export const schemaQuerySingleOrMultipleUserIds = z.object({
  userId: z.union([stringOrNumber, z.array(stringOrNumber)]),
});

export const schemaQuerySingleOrMultipleTeamIds = z.object({
  teamId: z.union([stringOrNumber, z.array(stringOrNumber)]),
});

export const withValidQueryUserId = withValidation({
  schema: schemaQueryUserId,
  type: "Zod",
  mode: "query",
});
import { withValidation } from "next-validations";
import { z } from "zod";

import { baseApiParams } from "./baseApiParams";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
export const schemaQueryAttendeeEmail = baseApiParams.extend({
  attendeeEmail: z.string().email(),
});

export const schemaQuerySingleOrMultipleAttendeeEmails = z.object({
  attendeeEmail: z.union([z.string().email(), z.array(z.string().email())]).optional(),
});

export const withValidQueryAttendeeEmail = withValidation({
  schema: schemaQueryAttendeeEmail,
  type: "Zod",
  mode: "query",
});
import { withValidation } from "next-validations";
import { z } from "zod";

import { baseApiParams } from "./baseApiParams";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
export const schemaQueryTeamId = baseApiParams
  .extend({
    teamId: z
      .string()
      .regex(/^\d+$/)
      .transform((id) => parseInt(id)),
  })
  .strict();

export const withValidQueryTeamId = withValidation({
  schema: schemaQueryTeamId,
  type: "Zod",
  mode: "query",
});
import { withValidation } from "next-validations";
import { z } from "zod";

import { baseApiParams } from "./baseApiParams";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
export const schemaQueryUserEmail = baseApiParams.extend({
  email: z.string().email(),
});

export const schemaQuerySingleOrMultipleUserEmails = z.object({
  email: z.union([z.string().email(), z.array(z.string().email())]),
});

export const withValidQueryUserEmail = withValidation({
  schema: schemaQueryUserEmail,
  type: "Zod",
  mode: "query",
});
import { withValidation } from "next-validations";
import { z } from "zod";

import { baseApiParams } from "./baseApiParams";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
/** Used for UUID style id queries */
export const schemaQueryIdAsString = baseApiParams
  .extend({
    id: z.string(),
  })
  .strict();

export const withValidQueryIdString = withValidation({
  schema: schemaQueryIdAsString,
  type: "Zod",
  mode: "query",
});
import { z } from "zod";

// Extracted out as utility function so can be reused
// at different endpoints that require this validation.
export const baseApiParams = z.object({
  // since we added apiKey as query param this is required by next-validations helper
  // for query params to work properly and not fail.
  apiKey: z.string().optional(),
  // version required for supporting  /v1/ redirect to query in api as *?version=1
  version: z.string().optional(),
});
import { z } from "zod";

import { _TeamModel as Team } from "@calcom/prisma/zod";

export const schemaTeamBaseBodyParams = Team.omit({ id: true, createdAt: true }).partial({
  hideBranding: true,
  metadata: true,
  pendingPayment: true,
});

const schemaTeamRequiredParams = z.object({
  name: z.string().max(255),
});

export const schemaTeamBodyParams = schemaTeamBaseBodyParams.merge(schemaTeamRequiredParams).strict();

export const schemaTeamUpdateBodyParams = schemaTeamBodyParams.partial();

const schemaOwnerId = z.object({
  ownerId: z.number().optional(),
});

export const schemaTeamCreateBodyParams = schemaTeamBodyParams.merge(schemaOwnerId).strict();

export const schemaTeamReadPublic = Team.omit({});

export const schemaTeamsReadPublic = z.array(schemaTeamReadPublic);
import { _BookingReferenceModel as BookingReference } from "@calcom/prisma/zod";
import { denullishShape } from "@calcom/prisma/zod-utils";

export const schemaBookingReferenceBaseBodyParams = BookingReference.pick({
  type: true,
  bookingId: true,
  uid: true,
  meetingId: true,
  meetingPassword: true,
  meetingUrl: true,
  deleted: true,
}).partial();

export const schemaBookingReferenceReadPublic = BookingReference.pick({
  id: true,
  type: true,
  bookingId: true,
  uid: true,
  meetingId: true,
  meetingPassword: true,
  meetingUrl: true,
  deleted: true,
});

export const schemaBookingCreateBodyParams = BookingReference.omit({ id: true, bookingId: true })
  .merge(denullishShape(BookingReference.pick({ bookingId: true })))
  .strict();

export const schemaBookingEditBodyParams = schemaBookingCreateBodyParams.partial();
import { z } from "zod";

import { _BookingModel as Booking, _AttendeeModel, _UserModel, _PaymentModel } from "@calcom/prisma/zod";
import { extendedBookingCreateBody, iso8601 } from "@calcom/prisma/zod-utils";

import { schemaQueryUserId } from "./shared/queryUserId";

const schemaBookingBaseBodyParams = Booking.pick({
  uid: true,
  userId: true,
  eventTypeId: true,
  title: true,
  description: true,
  startTime: true,
  endTime: true,
  status: true,
}).partial();

export const schemaBookingCreateBodyParams = extendedBookingCreateBody.merge(schemaQueryUserId.partial());

export const schemaBookingGetParams = z.object({
  dateFrom: iso8601.optional(),
  dateTo: iso8601.optional(),
});

const schemaBookingEditParams = z
  .object({
    title: z.string().optional(),
    startTime: iso8601.optional(),
    endTime: iso8601.optional(),
    // Not supporting responses in edit as that might require re-triggering emails
    // responses
  })
  .strict();

export const schemaBookingEditBodyParams = schemaBookingBaseBodyParams
  .merge(schemaBookingEditParams)
  .omit({ uid: true });

export const schemaBookingReadPublic = Booking.extend({
  attendees: z
    .array(
      _AttendeeModel.pick({
        email: true,
        name: true,
        timeZone: true,
        locale: true,
      })
    )
    .optional(),
  user: _UserModel
    .pick({
      email: true,
      name: true,
      timeZone: true,
      locale: true,
    })
    .optional(),
  payment: z
    .array(
      _PaymentModel.pick({
        id: true,
        success: true,
        paymentOption: true,
      })
    )
    .optional(),
  responses: z.record(z.any()).nullable(),
}).pick({
  id: true,
  userId: true,
  description: true,
  eventTypeId: true,
  uid: true,
  title: true,
  startTime: true,
  endTime: true,
  timeZone: true,
  attendees: true,
  user: true,
  payment: true,
  metadata: true,
  status: true,
  responses: true,
});
import { _EventTypeCustomInputModel as EventTypeCustomInput } from "@calcom/prisma/zod";

export const schemaEventTypeCustomInputBaseBodyParams = EventTypeCustomInput.omit({
  id: true,
});

export const schemaEventTypeCustomInputPublic = EventTypeCustomInput.omit({});

export const schemaEventTypeCustomInputBodyParams = schemaEventTypeCustomInputBaseBodyParams.strict();

export const schemaEventTypeCustomInputEditBodyParams = schemaEventTypeCustomInputBaseBodyParams
  .partial()
  .strict();
import { z } from "zod";

import { WEBHOOK_TRIGGER_EVENTS } from "@calcom/features/webhooks/lib/constants";
import { _WebhookModel as Webhook } from "@calcom/prisma/zod";

const schemaWebhookBaseBodyParams = Webhook.pick({
  userId: true,
  eventTypeId: true,
  eventTriggers: true,
  active: true,
  subscriberUrl: true,
  payloadTemplate: true,
});

export const schemaWebhookCreateParams = z
  .object({
    // subscriberUrl: z.string().url(),
    // eventTriggers: z.enum(WEBHOOK_TRIGGER_EVENTS).array(),
    // active: z.boolean(),
    payloadTemplate: z.string().optional().nullable(),
    eventTypeId: z.number().optional(),
    userId: z.number().optional(),
    secret: z.string().optional().nullable(),
    // API shouldn't mess with Apps webhooks yet (ie. Zapier)
    // appId: z.string().optional().nullable(),
  })
  .strict();

export const schemaWebhookCreateBodyParams = schemaWebhookBaseBodyParams.merge(schemaWebhookCreateParams);

export const schemaWebhookEditBodyParams = schemaWebhookBaseBodyParams
  .merge(
    z.object({
      eventTriggers: z.enum(WEBHOOK_TRIGGER_EVENTS).array().optional(),
      secret: z.string().optional().nullable(),
    })
  )
  .partial()
  .strict();

export const schemaWebhookReadPublic = Webhook.pick({
  id: true,
  userId: true,
  eventTypeId: true,
  payloadTemplate: true,
  eventTriggers: true,
  // FIXME: We have some invalid urls saved in the DB
  // subscriberUrl: true,
  /** @todo: find out how to properly add back and validate those. */
  // eventType: true,
  // app: true,
  appId: true,
}).merge(
  z.object({
    subscriberUrl: z.string(),
  })
);
import { z } from "zod";

import { _ApiKeyModel as ApiKey } from "@calcom/prisma/zod";

export const apiKeyCreateBodySchema = ApiKey.pick({
  note: true,
  expiresAt: true,
  userId: true,
})
  .partial({ userId: true })
  .merge(z.object({ neverExpires: z.boolean().optional() }))
  .strict();

export const apiKeyEditBodySchema = ApiKey.pick({
  note: true,
})
  .partial()
  .strict();

export const apiKeyPublicSchema = ApiKey.pick({
  id: true,
  userId: true,
  note: true,
  createdAt: true,
  expiresAt: true,
  lastUsedAt: true,
  /** We might never want to expose these. Leaving this a as reminder. */
  // hashedKey: true,
});
import { z } from "zod";

import slugify from "@calcom/lib/slugify";
import { _EventTypeModel as EventType, _HostModel } from "@calcom/prisma/zod";
import { customInputSchema, eventTypeBookingFields } from "@calcom/prisma/zod-utils";

import { Frequency } from "~/lib/types";

import { jsonSchema } from "./shared/jsonSchema";
import { schemaQueryUserId } from "./shared/queryUserId";
import { timeZone } from "./shared/timeZone";

const recurringEventInputSchema = z.object({
  dtstart: z.string().optional(),
  interval: z.number().int().optional(),
  count: z.number().int().optional(),
  freq: z.nativeEnum(Frequency).optional(),
  until: z.string().optional(),
  tzid: timeZone.optional(),
});

const hostSchema = _HostModel.pick({
  isFixed: true,
  userId: true,
});

export const childrenSchema = z.object({
  id: z.number().int(),
  userId: z.number().int(),
});

export const schemaEventTypeBaseBodyParams = EventType.pick({
  title: true,
  description: true,
  slug: true,
  length: true,
  hidden: true,
  position: true,
  eventName: true,
  timeZone: true,
  schedulingType: true,
  // START Limit future bookings
  periodType: true,
  periodStartDate: true,
  periodEndDate: true,
  periodDays: true,
  periodCountCalendarDays: true,
  // END Limit future bookings
  requiresConfirmation: true,
  disableGuests: true,
  hideCalendarNotes: true,
  minimumBookingNotice: true,
  parentId: true,
  beforeEventBuffer: true,
  afterEventBuffer: true,
  teamId: true,
  price: true,
  currency: true,
  slotInterval: true,
  successRedirectUrl: true,
  locations: true,
  bookingLimits: true,
  onlyShowFirstAvailableSlot: true,
  durationLimits: true,
  assignAllTeamMembers: true,
})
  .merge(
    z.object({
      children: z.array(childrenSchema).optional().default([]),
      hosts: z.array(hostSchema).optional().default([]),
    })
  )
  .partial()
  .strict();

const schemaEventTypeCreateParams = z
  .object({
    title: z.string(),
    slug: z.string().transform((s) => slugify(s)),
    description: z.string().optional().nullable(),
    length: z.number().int(),
    metadata: z.any().optional(),
    recurringEvent: recurringEventInputSchema.optional(),
    seatsPerTimeSlot: z.number().optional(),
    seatsShowAttendees: z.boolean().optional(),
    seatsShowAvailabilityCount: z.boolean().optional(),
    bookingFields: eventTypeBookingFields.optional(),
    scheduleId: z.number().optional(),
    parentId: z.number().optional(),
  })
  .strict();

export const schemaEventTypeCreateBodyParams = schemaEventTypeBaseBodyParams
  .merge(schemaEventTypeCreateParams)
  .merge(schemaQueryUserId.partial());

const schemaEventTypeEditParams = z
  .object({
    title: z.string().optional(),
    slug: z
      .string()
      .transform((s) => slugify(s))
      .optional(),
    length: z.number().int().optional(),
    seatsPerTimeSlot: z.number().optional(),
    seatsShowAttendees: z.boolean().optional(),
    seatsShowAvailabilityCount: z.boolean().optional(),
    bookingFields: eventTypeBookingFields.optional(),
    scheduleId: z.number().optional(),
  })
  .strict();

export const schemaEventTypeEditBodyParams = schemaEventTypeBaseBodyParams.merge(schemaEventTypeEditParams);

export const schemaEventTypeReadPublic = EventType.pick({
  id: true,
  title: true,
  slug: true,
  length: true,
  hidden: true,
  position: true,
  userId: true,
  teamId: true,
  scheduleId: true,
  eventName: true,
  timeZone: true,
  periodType: true,
  periodStartDate: true,
  periodEndDate: true,
  periodDays: true,
  periodCountCalendarDays: true,
  requiresConfirmation: true,
  recurringEvent: true,
  disableGuests: true,
  hideCalendarNotes: true,
  minimumBookingNotice: true,
  beforeEventBuffer: true,
  afterEventBuffer: true,
  schedulingType: true,
  price: true,
  currency: true,
  slotInterval: true,
  parentId: true,
  successRedirectUrl: true,
  description: true,
  locations: true,
  metadata: true,
  seatsPerTimeSlot: true,
  seatsShowAttendees: true,
  seatsShowAvailabilityCount: true,
  bookingFields: true,
  bookingLimits: true,
  onlyShowFirstAvailableSlot: true,
  durationLimits: true,
}).merge(
  z.object({
    children: z.array(childrenSchema).optional().default([]),
    hosts: z.array(hostSchema).optional().default([]),
    locations: z
      .array(
        z.object({
          link: z.string().optional(),
          address: z.string().optional(),
          hostPhoneNumber: z.string().optional(),
          type: z.any().optional(),
        })
      )
      .nullable(),
    metadata: jsonSchema.nullable(),
    customInputs: customInputSchema.array().optional(),
    link: z.string().optional(),
    bookingFields: eventTypeBookingFields.optional().nullable(),
  })
);
import { z } from "zod";

import { checkUsername } from "@calcom/lib/server/checkUsername";
import { _UserModel as User } from "@calcom/prisma/zod";
import { iso8601 } from "@calcom/prisma/zod-utils";

import { isValidBase64Image } from "~/lib/utils/isValidBase64Image";
import { timeZone } from "~/lib/validations/shared/timeZone";

// @note: These are the ONLY values allowed as weekStart. So user don't introduce bad data.
enum weekdays {
  MONDAY = "Monday",
  TUESDAY = "Tuesday",
  WEDNESDAY = "Wednesday",
  THURSDAY = "Thursday",
  FRIDAY = "Friday",
  SATURDAY = "Saturday",
  SUNDAY = "Sunday",
}

// @note: extracted from apps/web/next-i18next.config.js, update if new locales.
enum locales {
  EN = "en",
  FR = "fr",
  IT = "it",
  RU = "ru",
  ES = "es",
  DE = "de",
  PT = "pt",
  RO = "ro",
  NL = "nl",
  PT_BR = "pt-BR",
  // ES_419 = "es-419", // Disabled until Crowdin reaches at least 80% completion
  KO = "ko",
  JA = "ja",
  PL = "pl",
  AR = "ar",
  IW = "iw",
  ZH_CN = "zh-CN",
  ZH_TW = "zh-TW",
  CS = "cs",
  SR = "sr",
  SV = "sv",
  VI = "vi",
}
enum theme {
  DARK = "dark",
  LIGHT = "light",
}

enum timeFormat {
  TWELVE = 12,
  TWENTY_FOUR = 24,
}

const usernameSchema = z
  .string()
  .transform((v) => v.toLowerCase())
  // .refine(() => {})
  .superRefine(async (val, ctx) => {
    if (val) {
      const result = await checkUsername(val);
      if (!result.available) ctx.addIssue({ code: z.ZodIssueCode.custom, message: "already_in_use_error" });
      if (result.premium) ctx.addIssue({ code: z.ZodIssueCode.custom, message: "premium_username" });
    }
  });

// @note: These are the values that are editable via PATCH method on the user Model
export const schemaUserBaseBodyParams = User.pick({
  name: true,
  email: true,
  username: true,
  bio: true,
  timeZone: true,
  weekStart: true,
  theme: true,
  defaultScheduleId: true,
  locale: true,
  hideBranding: true,
  timeFormat: true,
  brandColor: true,
  darkBrandColor: true,
  allowDynamicBooking: true,
  away: true,
  role: true,
  // @note: disallowing avatar changes via API for now. We can add it later if needed. User should upload image via UI.
  // avatar: true,
}).partial();
// @note: partial() is used to allow for the user to edit only the fields they want to edit making all optional,
// if want to make any required do it in the schemaRequiredParams

// Here we can both require or not (adding optional or nullish) and also rewrite validations for any value
// for example making weekStart only accept weekdays as input
const schemaUserEditParams = z.object({
  email: z.string().email().toLowerCase(),
  username: usernameSchema,
  weekStart: z.nativeEnum(weekdays).optional(),
  brandColor: z.string().min(4).max(9).regex(/^#/).optional(),
  darkBrandColor: z.string().min(4).max(9).regex(/^#/).optional(),
  hideBranding: z.boolean().optional(),
  timeZone: timeZone.optional(),
  theme: z.nativeEnum(theme).optional().nullable(),
  timeFormat: z.nativeEnum(timeFormat).optional(),
  defaultScheduleId: z
    .number()
    .refine((id: number) => id > 0)
    .optional()
    .nullable(),
  locale: z.nativeEnum(locales).optional().nullable(),
  avatar: z.string().refine(isValidBase64Image).optional(),
});

// @note: These are the values that are editable via PATCH method on the user Model,
// merging both BaseBodyParams with RequiredParams, and omiting whatever we want at the end.

const schemaUserCreateParams = z.object({
  email: z.string().email().toLowerCase(),
  username: usernameSchema,
  weekStart: z.nativeEnum(weekdays).optional(),
  brandColor: z.string().min(4).max(9).regex(/^#/).optional(),
  darkBrandColor: z.string().min(4).max(9).regex(/^#/).optional(),
  hideBranding: z.boolean().optional(),
  timeZone: timeZone.optional(),
  theme: z.nativeEnum(theme).optional().nullable(),
  timeFormat: z.nativeEnum(timeFormat).optional(),
  defaultScheduleId: z
    .number()
    .refine((id: number) => id > 0)
    .optional()
    .nullable(),
  locale: z.nativeEnum(locales).optional(),
  createdDate: iso8601.optional(),
  avatar: z.string().refine(isValidBase64Image).optional(),
});

// @note: These are the values that are editable via PATCH method on the user Model,
// merging both BaseBodyParams with RequiredParams, and omiting whatever we want at the end.
export const schemaUserEditBodyParams = schemaUserBaseBodyParams
  .merge(schemaUserEditParams)
  .omit({})
  .partial()
  .strict();

export const schemaUserCreateBodyParams = schemaUserBaseBodyParams
  .merge(schemaUserCreateParams)
  .omit({})
  .strict();

// @note: These are the values that are always returned when reading a user
export const schemaUserReadPublic = User.pick({
  id: true,
  username: true,
  name: true,
  email: true,
  emailVerified: true,
  bio: true,
  avatar: true,
  timeZone: true,
  weekStart: true,
  endTime: true,
  bufferTime: true,
  theme: true,
  defaultScheduleId: true,
  locale: true,
  timeFormat: true,
  hideBranding: true,
  brandColor: true,
  darkBrandColor: true,
  allowDynamicBooking: true,
  away: true,
  createdDate: true,
  verified: true,
  invitedTo: true,
  role: true,
});

export const schemaUsersReadPublic = z.array(schemaUserReadPublic);
import { z } from "zod";

import { _ReminderMailModel as ReminderMail } from "@calcom/prisma/zod";

export const schemaReminderMailBaseBodyParams = ReminderMail.omit({ id: true }).partial();

export const schemaReminderMailPublic = ReminderMail.omit({});

const schemaReminderMailRequiredParams = z.object({
  referenceId: z.number().int(),
  reminderType: z.enum(["PENDING_BOOKING_CONFIRMATION"]),
  elapsedMinutes: z.number().int(),
});

export const schemaReminderMailBodyParams = schemaReminderMailBaseBodyParams.merge(
  schemaReminderMailRequiredParams
);
import z from "zod";

import { _SelectedCalendarModel as SelectedCalendar } from "@calcom/prisma/zod";

import { schemaQueryIdAsString } from "./shared/queryIdString";
import { schemaQueryIdParseInt } from "./shared/queryIdTransformParseInt";

export const schemaSelectedCalendarBaseBodyParams = SelectedCalendar;

export const schemaSelectedCalendarPublic = SelectedCalendar.omit({});

export const schemaSelectedCalendarBodyParams = schemaSelectedCalendarBaseBodyParams.partial({
  userId: true,
});

export const schemaSelectedCalendarUpdateBodyParams = schemaSelectedCalendarBaseBodyParams.partial();

export const selectedCalendarIdSchema = schemaQueryIdAsString.transform((v, ctx) => {
  /** We can assume the first part is the userId since it's an integer */
  const [userIdStr, ...rest] = v.id.split("_");
  /** We can assume that the remainder is both the integration type and external id combined */
  const integration_externalId = rest.join("_");
  /**
   * Since we only handle calendars here we can split by `_calendar_` and re add it later on.
   * This handle special cases like `google_calendar_c_blabla@group.calendar.google.com` and
   * `hubspot_other_calendar`.
   **/
  const [_integration, externalId] = integration_externalId.split("_calendar_");
  const userIdInt = schemaQueryIdParseInt.safeParse({ id: userIdStr });
  if (!userIdInt.success) {
    ctx.addIssue({ code: z.ZodIssueCode.custom, message: "userId is not a number" });

    return z.NEVER;
  }
  if (!_integration) {
    ctx.addIssue({ code: z.ZodIssueCode.custom, message: "Missing integration" });

    return z.NEVER;
  }
  if (!externalId) {
    ctx.addIssue({ code: z.ZodIssueCode.custom, message: "Missing externalId" });

    return z.NEVER;
  }
  return {
    userId: userIdInt.data.id,
    /** We re-add the split `_calendar` string */
    integration: `${_integration}_calendar`,
    externalId,
  };
});
import type { EventLocationType } from "@calcom/app-store/locations";
import type {
  Attendee,
  Availability,
  Booking,
  BookingReference,
  Credential,
  DestinationCalendar,
  EventType,
  EventTypeCustomInput,
  Membership,
  Payment,
  ReminderMail,
  Schedule,
  SelectedCalendar,
  Team,
  User,
  Webhook,
} from "@calcom/prisma/client";

// Base response, used for all responses
export type BaseResponse = {
  message?: string;
  error?: Error;
};

// User
export type UserResponse = BaseResponse & {
  user?: Partial<User>;
};

export type UsersResponse = BaseResponse & {
  users?: Partial<User>[];
};

// Team
export type TeamResponse = BaseResponse & {
  team?: Partial<Team>;
  owner?: Partial<Membership>;
};

export type TeamsResponse = BaseResponse & {
  teams?: Partial<Team>[];
};

// SelectedCalendar
export type SelectedCalendarResponse = BaseResponse & {
  selected_calendar?: Partial<SelectedCalendar>;
};

export type SelectedCalendarsResponse = BaseResponse & {
  selected_calendars?: Partial<SelectedCalendar>[];
};

// Attendee
export type AttendeeResponse = BaseResponse & {
  attendee?: Partial<Attendee>;
};
// Grouping attendees in booking arrays for now,
// later might remove endpoint and move to booking endpoint altogether.
export type AttendeesResponse = BaseResponse & {
  attendees?: Partial<Attendee>[];
};

// Availability
export type AvailabilityResponse = BaseResponse & {
  availability?: Partial<Availability>;
};

export type AvailabilitiesResponse = BaseResponse & {
  availabilities?: Partial<Availability>[];
};

// BookingReference
export type BookingReferenceResponse = BaseResponse & {
  booking_reference?: Partial<BookingReference>;
};

export type BookingReferencesResponse = BaseResponse & {
  booking_references?: Partial<BookingReference>[];
};

// Booking
export type BookingResponse = BaseResponse & {
  booking?: Partial<Booking>;
};

export type BookingsResponse = BaseResponse & {
  bookings?: Partial<Booking>[];
};

// Credential
export type CredentialResponse = BaseResponse & {
  credential?: Partial<Credential>;
};

export type CredentialsResponse = BaseResponse & {
  credentials?: Partial<Credential>[];
};

// DestinationCalendar
export type DestinationCalendarResponse = BaseResponse & {
  destination_calendar?: Partial<DestinationCalendar>;
};

export type DestinationCalendarsResponse = BaseResponse & {
  destination_calendars?: Partial<DestinationCalendar>[];
};

// Membership
export type MembershipResponse = BaseResponse & {
  membership?: Partial<Membership>;
};

export type MembershipsResponse = BaseResponse & {
  memberships?: Partial<Membership>[];
};

// EventTypeCustomInput
export type EventTypeCustomInputResponse = BaseResponse & {
  event_type_custom_input?: Partial<EventTypeCustomInput>;
};

export type EventTypeCustomInputsResponse = BaseResponse & {
  event_type_custom_inputs?: Partial<EventTypeCustomInput>[];
};
// From rrule https://jakubroztocil.github.io/rrule freq
export enum Frequency {
  "YEARLY",
  "MONTHLY",
  "WEEKLY",
  "DAILY",
  "HOURLY",
  "MINUTELY",
  "SECONDLY",
}
interface EventTypeExtended extends Omit<EventType, "recurringEvent" | "locations"> {
  recurringEvent: {
    dtstart?: Date | undefined;
    interval?: number | undefined;
    count?: number | undefined;
    freq?: Frequency | undefined;
    until?: Date | undefined;
    tzid?: string | undefined;
  } | null;
  locations:
    | {
        link?: string | undefined;
        address?: string | undefined;
        hostPhoneNumber?: string | undefined;
        type: EventLocationType;
      }[]
    | null
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    | any;
}

// EventType
export type EventTypeResponse = BaseResponse & {
  event_type?: Partial<EventType | EventTypeExtended>;
};

export type EventTypesResponse = BaseResponse & {
  event_types?: Partial<EventType | EventTypeExtended>[];
};

// Payment
export type PaymentResponse = BaseResponse & {
  payment?: Partial<Payment>;
};

export type PaymentsResponse = BaseResponse & {
  payments?: Partial<Payment>[];
};

// Schedule
export type ScheduleResponse = BaseResponse & {
  schedule?: Partial<Schedule>;
};

export type SchedulesResponse = BaseResponse & {
  schedules?: Partial<Schedule>[];
};

// Webhook
export type WebhookResponse = BaseResponse & {
  webhook?: Partial<Webhook> | null;
};

export type WebhooksResponse = BaseResponse & {
  webhooks?: Partial<Webhook>[];
};

// ReminderMail
export type ReminderMailResponse = BaseResponse & {
  reminder_mail?: Partial<ReminderMail>;
};

export type ReminderMailsResponse = BaseResponse & {
  reminder_mails?: Partial<ReminderMail>[];
};

export const PRISMA_CLIENT_CACHING_TIME = 1000 * 60 * 60 * 24; // one day in ms
import type { NextMiddleware } from "next-api-middleware";

export const extendRequest: NextMiddleware = async (req, res, next) => {
  req.pagination = {
    take: 100,
    skip: 0,
  };
  await next();
};
import { nanoid } from "nanoid";
import type { NextMiddleware } from "next-api-middleware";

export const addRequestId: NextMiddleware = async (_req, res, next) => {
  // Apply header with unique ID to every request
  res.setHeader("Calcom-Response-ID", nanoid());
  // Add all headers here instead of next.config.js as it is throwing error( Cannot set headers after they are sent to the client) for OPTIONS method
  // It is known to happen only in Dev Mode.
  res.setHeader("Access-Control-Allow-Credentials", "true");
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "GET, OPTIONS, PATCH, DELETE, POST, PUT");
  res.setHeader(
    "Access-Control-Allow-Headers",
    "X-CSRF-Token, X-Requested-With, Accept, Accept-Version, Content-Length, Content-MD5, Content-Type, Date, X-Api-Version, Content-Type, api_key, Authorization"
  );

  // Ensure all OPTIONS request are automatically successful. Headers are already set above.
  if (_req.method === "OPTIONS") {
    res.status(200).end();

    return;
  }
  // Let remaining middleware and API route execute
  await next();
};

export default function parseJSONSafely(str: string) {
  try {
    return JSON.parse(str);
  } catch (e) {
    console.error((e as Error).message);

    if ((e as Error).message.includes("Unexpected token")) {
      return {
        success: false,
        message: `Invalid JSON in the body: ${(e as Error).message}`,
      };
    }
    return {};
  }
}
import type { NextMiddleware } from "next-api-middleware";

export const httpMethod = (allowedHttpMethod: "GET" | "POST" | "PATCH" | "DELETE"): NextMiddleware => {
  return async function (req, res, next) {
    if (req.method === allowedHttpMethod || req.method == "OPTIONS") {
      await next();
    } else {
      res.status(405).json({ message: `Only ${allowedHttpMethod} Method allowed` });
      res.end();
    }
  };
};
// Made this so we can support several HTTP Methods in one route and use it there.
// Could be further extracted into a third function or refactored into one.
// that checks if it's just a string or an array and apply the correct logic to both cases.
export const httpMethods = (allowedHttpMethod: string[]): NextMiddleware => {
  return async function (req, res, next) {
    if (allowedHttpMethod.some((method) => method === req.method || req.method == "OPTIONS")) {
      await next();
    } else {
      res.status(405).json({ message: `Only ${allowedHttpMethod} Method allowed` });
      res.end();
    }
  };
};

export const HTTP_POST = httpMethod("POST");

export const HTTP_GET = httpMethod("GET");

export const HTTP_PATCH = httpMethod("PATCH");

export const HTTP_DELETE = httpMethod("DELETE");

export const HTTP_GET_DELETE_PATCH = httpMethods(["GET", "DELETE", "PATCH"]);

export const HTTP_GET_OR_POST = httpMethods(["GET", "POST"]);
import type { NextMiddleware } from "next-api-middleware";

import { checkRateLimitAndThrowError } from "@calcom/lib/checkRateLimitAndThrowError";
import { API_KEY_RATE_LIMIT } from "@calcom/lib/rateLimit";

export const rateLimitApiKey: NextMiddleware = async (req, res, next) => {
  if (!req.query.apiKey) return res.status(401).json({ message: "No apiKey provided" });

  // TODO: Add a way to add trusted api keys
  await checkRateLimitAndThrowError({
    identifier: req.query.apiKey as string,
    rateLimitingType: "api",
    onRateLimiterResponse: (response) => {
      res.setHeader("X-RateLimit-Limit", API_KEY_RATE_LIMIT);
      res.setHeader("X-RateLimit-Remaining", response.remaining);
      res.setHeader("X-RateLimit-Reset", response.reset);
    },
  });

  await next();
};
import type { NextMiddleware } from "next-api-middleware";

import { CONSOLE_URL } from "@calcom/lib/constants";
import { customPrisma } from "@calcom/prisma";

const LOCAL_CONSOLE_URL = process.env.NEXT_PUBLIC_CONSOLE_URL || CONSOLE_URL;

// This replaces the prisma client for the custom one if the key is valid
export const customPrismaClient: NextMiddleware = async (req, res, next) => {
  const {
    query: { key },
  } = req;
  // If no custom api Id is provided, attach to request the regular cal.com prisma client.
  if (!key) {
    req.prisma = customPrisma();
    await next();

    return;
  }

  // If we have a key, we check if the deployment matching the key, has a databaseUrl value set.
  const databaseUrl = await fetch(`${LOCAL_CONSOLE_URL}/api/deployments/database?key=${key}`)
    .then((res) => res.json())
    .then((res) => res.databaseUrl);

  if (!databaseUrl) {
    res.status(400).json({ error: "no databaseUrl set up at your instance yet" });

    return;
  }
  req.prisma = customPrisma({ datasources: { db: { url: databaseUrl } } });
  /* @note:
    In order to skip verifyApiKey for customPrisma requests, 
    we pass isAdmin true, and userId 0, if we detect them later, 
    we skip verifyApiKey logic and pass onto next middleware instead.
     */
  req.isAdmin = true;
  req.isCustomPrisma = true;
  // We don't need the key from here and on. Prevents unrecognized key errors.
  delete req.query.key;
  await next();
  await req.prisma.$disconnect();
  // @ts-expect-error testing
  delete req.prisma;
};
import * as Sentry from "@sentry/nextjs";
import type { NextMiddleware } from "next-api-middleware";

import { redactError } from "@calcom/lib/redactError";

export const captureErrors: NextMiddleware = async (_req, res, next) => {
  try {
    // Catch any errors that are thrown in remaining
    // middleware and the API route handler
    await next();
  } catch (error) {
    Sentry.captureException(error);

    const redactedError = redactError(error);

    if (redactedError instanceof Error) {
      res.status(400).json({ message: redactedError.message, error: redactedError });
      return;
    }
    res.status(400).json({ message: "Something went wrong", error });
  }
};
import type { NextMiddleware } from "next-api-middleware";
import z from "zod";

const withPage = z.object({
  page: z.coerce.number().min(1).optional().default(1),
  take: z.coerce.number().min(1).optional().default(10),
});

export const withPagination: NextMiddleware = async (req, _, next) => {
  const { page, take } = withPage.parse(req.query);
  const skip = (page - 1) * take;
  req.pagination = {
    take,
    skip,
  };
  await next();
};
import type { NextMiddleware } from "next-api-middleware";

import { hashAPIKey } from "@calcom/features/ee/api-keys/lib/apiKeys";
import checkLicense from "@calcom/features/ee/common/server/checkLicense";
import { IS_PRODUCTION } from "@calcom/lib/constants";

import { isAdminGuard } from "../utils/isAdmin";

// Used to check if the apiKey is not expired, could be extracted if reused. but not for now.
export const dateNotInPast = function (date: Date) {
  const now = new Date();
  if (now.setHours(0, 0, 0, 0) > date.setHours(0, 0, 0, 0)) {
    return true;
  }
};

// This verifies the apiKey and sets the user if it is valid.
export const verifyApiKey: NextMiddleware = async (req, res, next) => {
  const { prisma, isCustomPrisma, isAdmin } = req;
  const hasValidLicense = await checkLicense(prisma);
  if (!hasValidLicense && IS_PRODUCTION)
    return res.status(401).json({ error: "Invalid or missing CALCOM_LICENSE_KEY environment variable" });
  // If the user is an admin and using a license key (from customPrisma), skip the apiKey check.
  if (isCustomPrisma && isAdmin) {
    await next();

    return;
  }
  // Check if the apiKey query param is provided.
  if (!req.query.apiKey) return res.status(401).json({ message: "No apiKey provided" });
  // remove the prefix from the user provided api_key. If no env set default to "cal_"
  const strippedApiKey = `${req.query.apiKey}`.replace(process.env.API_KEY_PREFIX || "cal_", "");
  // Hash the key again before matching against the database records.
  const hashedKey = hashAPIKey(strippedApiKey);
  // Check if the hashed api key exists in database.
  const apiKey = await prisma.apiKey.findUnique({ where: { hashedKey } });
  // If cannot find any api key. Throw a 401 Unauthorized.
  if (!apiKey) return res.status(401).json({ error: "Your apiKey is not valid" });
  if (apiKey.expiresAt && dateNotInPast(apiKey.expiresAt)) {
    return res.status(401).json({ error: "This apiKey is expired" });
  }
  if (!apiKey.userId) return res.status(404).json({ error: "No user found for this apiKey" });
  // save the user id in the request for later use
  req.userId = apiKey.userId;
  // save the isAdmin boolean here for later use
  req.isAdmin = await isAdminGuard(req);
  req.isCustomPrisma = false;
  await next();
};
import { label } from "next-api-middleware";

import { addRequestId } from "./addRequestid";
import { captureErrors } from "./captureErrors";
import { customPrismaClient } from "./customPrisma";
import { extendRequest } from "./extendRequest";
import {
  HTTP_POST,
  HTTP_DELETE,
  HTTP_PATCH,
  HTTP_GET,
  HTTP_GET_OR_POST,
  HTTP_GET_DELETE_PATCH,
} from "./httpMethods";
import { rateLimitApiKey } from "./rateLimitApiKey";
import { verifyApiKey } from "./verifyApiKey";
import { withPagination } from "./withPagination";

const middleware = {
  HTTP_GET_OR_POST,
  HTTP_GET_DELETE_PATCH,
  HTTP_GET,
  HTTP_PATCH,
  HTTP_POST,
  HTTP_DELETE,
  addRequestId,
  verifyApiKey,
  rateLimitApiKey,
  customPrismaClient,
  extendRequest,
  pagination: withPagination,
  captureErrors,
};

type Middleware = keyof typeof middleware;

const middlewareOrder =
  // The order here, determines the order of execution
  [
    "extendRequest",
    "captureErrors",
    // - Put customPrismaClient before verifyApiKey always.
    "customPrismaClient",
    "verifyApiKey",
    "rateLimitApiKey",
    "addRequestId",
  ] as Middleware[]; // <-- Provide a list of middleware to call automatically

const withMiddleware = label(middleware, middlewareOrder);

export { withMiddleware, middleware, middlewareOrder };
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import {
  schemaAvailabilityCreateBodyParams,
  schemaAvailabilityReadPublic,
} from "~/lib/validations/availability";

/**
 * @swagger
 * /availabilities:
 *   post:
 *     operationId: addAvailability
 *     summary: Creates a new availability
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     requestBody:
 *       description: Edit an existing availability related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *              - scheduleId
 *              - startTime
 *              - endTime
 *             properties:
 *               days:
 *                 type: array
 *                 description: Array of integers depicting weekdays
 *                 items:
 *                   type: integer
 *                   enum: [0, 1, 2, 3, 4, 5]
 *               scheduleId:
 *                 type: integer
 *                 description: ID of schedule this availability is associated with
 *               startTime:
 *                 type: string
 *                 description: Start time of the availability
 *               endTime:
 *                 type: string
 *                 description: End time of the availability
 *           examples:
 *              availability:
 *                summary: An example of availability
 *                value:
 *                  scheduleId: 123
 *                  days: [1,2,3,5]
 *                  startTime: 1970-01-01T17:00:00.000Z
 *                  endTime: 1970-01-01T17:00:00.000Z
 *
 *
 *     tags:
 *     - availabilities
 *     externalDocs:
 *        url: https://docs.cal.com/availability
 *     responses:
 *       201:
 *         description: OK, availability created
 *       400:
 *        description: Bad request. Availability body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { prisma } = req;
  const data = schemaAvailabilityCreateBodyParams.parse(req.body);
  await checkPermissions(req);
  const availability = await prisma.availability.create({
    data,
    include: { Schedule: { select: { userId: true } } },
  });
  req.statusCode = 201;
  return {
    availability: schemaAvailabilityReadPublic.parse(availability),
    message: "Availability created successfully",
  };
}

async function checkPermissions(req: NextApiRequest) {
  const { userId, prisma, isAdmin } = req;
  if (isAdmin) return;
  const data = schemaAvailabilityCreateBodyParams.parse(req.body);
  const schedule = await prisma.schedule.findFirst({
    where: { userId, id: data.scheduleId },
  });
  if (!schedule)
    throw new HttpError({ statusCode: 401, message: "You can't add availabilities to this schedule" });
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /availabilities/{id}:
 *   delete:
 *     operationId: removeAvailabilityById
 *     summary: Remove an existing availability
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the availability to delete
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: integer
 *        description: Your API key
 *     tags:
 *     - availabilities
 *     externalDocs:
 *        url: https://docs.cal.com/availability
 *     responses:
 *       201:
 *         description: OK, availability removed successfully
 *       400:
 *        description: Bad request. Availability id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  await prisma.availability.delete({ where: { id } });
  return { message: `Availability with id: ${id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, prisma, isAdmin, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  /** Admins can skip the ownership verification */
  if (isAdmin) return;
  /**
   * There's a caveat here. If the availability exists but the user doesn't own it,
   * the user will see a 404 error which may or not be the desired behavior.
   */
  await prisma.availability.findFirstOrThrow({
    where: { id, Schedule: { userId } },
  });
}

export default authMiddleware;
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import {
  schemaAvailabilityEditBodyParams,
  schemaAvailabilityReadPublic,
} from "~/lib/validations/availability";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /availabilities/{id}:
 *   patch:
 *     operationId: editAvailabilityById
 *     summary: Edit an existing availability
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         description: Your API key
 *         schema:
 *           type: integer
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: ID of the availability to edit
 *     requestBody:
 *       description: Edit an existing availability related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               days:
 *                 type: array
 *                 description: Array of integers depicting weekdays
 *                 items:
 *                   type: integer
 *                   enum: [0, 1, 2, 3, 4, 5]
 *               scheduleId:
 *                 type: integer
 *                 description: ID of schedule this availability is associated with
 *               startTime:
 *                 type: string
 *                 description: Start time of the availability
 *               endTime:
 *                 type: string
 *                 description: End time of the availability
 *           examples:
 *              availability:
 *                summary: An example of availability
 *                value:
 *                  scheduleId: 123
 *                  days: [1,2,3,5]
 *                  startTime: 1970-01-01T17:00:00.000Z
 *                  endTime: 1970-01-01T17:00:00.000Z
 *
 *     tags:
 *     - availabilities
 *     externalDocs:
 *        url: https://docs.cal.com/availability
 *     responses:
 *       201:
 *         description: OK, availability edited successfully
 *       400:
 *        description: Bad request. Availability body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, body } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = schemaAvailabilityEditBodyParams.parse(body);
  const availability = await prisma.availability.update({
    where: { id },
    data,
    include: { Schedule: { select: { userId: true } } },
  });
  return { availability: schemaAvailabilityReadPublic.parse(availability) };
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaAvailabilityReadPublic } from "~/lib/validations/availability";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /availabilities/{id}:
 *   get:
 *     operationId: getAvailabilityById
 *     summary: Find an availability
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the availability to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: integer
 *         description: Your API key
 *     tags:
 *     - availabilities
 *     externalDocs:
 *        url: https://docs.cal.com/availability
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid
 *       404:
 *        description: Availability not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const availability = await prisma.availability.findUnique({
    where: { id },
    include: { Schedule: { select: { userId: true } } },
  });
  return { availability: schemaAvailabilityReadPublic.parse(availability) };
}

export default defaultResponder(getHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaAttendeeCreateBodyParams, schemaAttendeeReadPublic } from "~/lib/validations/attendee";

/**
 * @swagger
 * /attendees:
 *   post:
 *     operationId: addAttendee
 *     summary: Creates a new attendee
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     requestBody:
 *       description: Create a new attendee related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - bookingId
 *               - name
 *               - email
 *               - timeZone
 *             properties:
 *               bookingId:
 *                 type: number
 *               email:
 *                 type: string
 *                 format: email
 *               name:
 *                 type: string
 *               timeZone:
 *                 type: string
 *     tags:
 *     - attendees
 *     responses:
 *       201:
 *         description: OK, attendee created
 *       400:
 *        description: Bad request. Attendee body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const body = schemaAttendeeCreateBodyParams.parse(req.body);

  if (!isAdmin) {
    const userBooking = await prisma.booking.findFirst({
      where: { userId, id: body.bookingId },
      select: { id: true },
    });
    // Here we make sure to only return attendee's of the user's own bookings.
    if (!userBooking) throw new HttpError({ statusCode: 403, message: "Forbidden" });
  }

  const data = await prisma.attendee.create({
    data: {
      email: body.email,
      name: body.name,
      timeZone: body.timeZone,
      booking: { connect: { id: body.bookingId } },
    },
  });

  return {
    attendee: schemaAttendeeReadPublic.parse(data),
    message: "Attendee created successfully",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /attendees/{id}:
 *   delete:
 *     operationId: removeAttendeeById
 *     summary: Remove an existing attendee
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the attendee to delete
 *     tags:
 *     - attendees
 *     responses:
 *       201:
 *         description: OK, attendee removed successfully
 *       400:
 *        description: Bad request. Attendee id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  await prisma.attendee.delete({ where: { id } });
  return { message: `Attendee with id: ${id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const query = schemaQueryIdParseInt.parse(req.query);
  // @note: Here we make sure to only return attendee's of the user's own bookings if the user is not an admin.
  if (isAdmin) return;
  // Find all user bookings, including attendees
  const attendee = await prisma.attendee.findFirst({
    where: { id: query.id, booking: { userId } },
  });
  // Flatten and merge all the attendees in one array
  if (!attendee) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { NextApiRequest } from "next";
import type { z } from "zod";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaAttendeeEditBodyParams, schemaAttendeeReadPublic } from "~/lib/validations/attendee";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /attendees/{id}:
 *   patch:
 *     operationId: editAttendeeById
 *     summary: Edit an existing attendee
 *     requestBody:
 *       description: Edit an existing attendee related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *               name:
 *                 type: string
 *               timeZone:
 *                 type: string
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the attendee to get
 *     tags:
 *     - attendees
 *     responses:
 *       201:
 *         description: OK, attendee edited successfully
 *       400:
 *        description: Bad request. Attendee body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */

export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, body } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = schemaAttendeeEditBodyParams.parse(body);
  await checkPermissions(req, data);
  const attendee = await prisma.attendee.update({ where: { id }, data });
  return { attendee: schemaAttendeeReadPublic.parse(attendee) };
}

async function checkPermissions(req: NextApiRequest, body: z.infer<typeof schemaAttendeeEditBodyParams>) {
  const { isAdmin, prisma } = req;
  if (isAdmin) return;
  const { userId } = req;
  const { bookingId } = body;
  if (bookingId) {
    // Ensure that the booking the attendee is being added to belongs to the user
    const booking = await prisma.booking.findFirst({ where: { id: bookingId, userId } });

    if (!booking) throw new HttpError({ statusCode: 403, message: "You don't have access to the booking" });
  }
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaAttendeeReadPublic } from "~/lib/validations/attendee";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /attendees/{id}:
 *   get:
 *     operationId: getAttendeeById
 *     summary: Find an attendee
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the attendee to get
 *     tags:
 *     - attendees
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Attendee was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const attendee = await prisma.attendee.findUnique({ where: { id } });
  return { attendee: schemaAttendeeReadPublic.parse(attendee) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaAttendeeReadPublic } from "~/lib/validations/attendee";

/**
 * @swagger
 * /attendees:
 *   get:
 *     operationId: listAttendees
 *     summary: Find all attendees
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *     - attendees
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No attendees were found
 */
async function handler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const args: Prisma.AttendeeFindManyArgs = isAdmin ? {} : { where: { booking: { userId } } };
  const data = await prisma.attendee.findMany(args);
  const attendees = data.map((attendee) => schemaAttendeeReadPublic.parse(attendee));
  if (!attendees) throw new HttpError({ statusCode: 404, message: "No attendees were found" });
  return { attendees };
}

export default defaultResponder(handler);
import type { NextApiRequest, NextApiResponse } from "next";

import { withMiddleware } from "~/lib/helpers/withMiddleware";
import type { PaymentResponse } from "~/lib/types";
import { schemaPaymentPublic } from "~/lib/validations/payment";
import {
  schemaQueryIdParseInt,
  withValidQueryIdTransformParseInt,
} from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /payments/{id}:
 *   get:
 *     summary: Find a payment
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the payment to get
 *     tags:
 *     - payments
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Payment was not found
 */
export async function paymentById(
  { method, query, userId, prisma }: NextApiRequest,
  res: NextApiResponse<PaymentResponse>
) {
  const safeQuery = schemaQueryIdParseInt.safeParse(query);
  if (safeQuery.success && method === "GET") {
    const userWithBookings = await prisma.user.findUnique({
      where: { id: userId },
      include: { bookings: true },
    });
    await prisma.payment
      .findUnique({ where: { id: safeQuery.data.id } })
      .then((data) => schemaPaymentPublic.parse(data))
      .then((payment) => {
        if (!userWithBookings?.bookings.map((b) => b.id).includes(payment.bookingId)) {
          res.status(401).json({ message: "Unauthorized" });
        } else {
          res.status(200).json({ payment });
        }
      })
      .catch((error: Error) =>
        res.status(404).json({
          message: `Payment with id: ${safeQuery.data.id} not found`,
          error,
        })
      );
  }
}
export default withMiddleware("HTTP_GET")(withValidQueryIdTransformParseInt(paymentById));
import type { NextApiRequest, NextApiResponse } from "next";

import { withMiddleware } from "~/lib/helpers/withMiddleware";
import type { PaymentsResponse } from "~/lib/types";
import { schemaPaymentPublic } from "~/lib/validations/payment";

/**
 * @swagger
 * /payments:
 *   get:
 *     summary: Find all payments
 *     tags:
 *     - payments
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No payments were found
 */
async function allPayments({ userId, prisma }: NextApiRequest, res: NextApiResponse<PaymentsResponse>) {
  const userWithBookings = await prisma.user.findUnique({
    where: { id: userId },
    include: { bookings: true },
  });
  if (!userWithBookings) throw new Error("No user found");
  const bookings = userWithBookings.bookings;
  const bookingIds = bookings.map((booking) => booking.id);
  const data = await prisma.payment.findMany({ where: { bookingId: { in: bookingIds } } });
  const payments = data.map((payment) => schemaPaymentPublic.parse(payment));

  if (payments) res.status(200).json({ payments });
  else
    (error: Error) =>
      res.status(404).json({
        message: "No Payments were found",
        error,
      });
}
// NO POST FOR PAYMENTS FOR NOW
export default withMiddleware("HTTP_GET")(allPayments);
import type { NextApiRequest } from "next";

import handleNewBooking from "@calcom/features/bookings/lib/handleNewBooking";
import { defaultResponder } from "@calcom/lib/server";

/**
 * @swagger
 * /bookings:
 *   post:
 *     summary: Creates a new booking
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     operationId: addBooking
 *     requestBody:
 *       description: Create a new booking related to one of your event-types
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - eventTypeId
 *               - start
 *               - responses
 *               - timeZone
 *               - language
 *               - metadata
 *             properties:
 *               eventTypeId:
 *                 type: integer
 *                 description: 'ID of the event type to book'
 *               start:
 *                 type: string
 *                 format: date-time
 *                 description: 'Start time of the Event'
 *               end:
 *                 type: string
 *                 format: date-time
 *                 description: 'End time of the Event'
 *               responses:
 *                 type: object
 *                 required:
 *                    - name
 *                    - email
 *                    - location
 *                 properties:
 *                    name:
 *                      type: string
 *                      description: 'Attendee full name'
 *                    email:
 *                      type: string
 *                      format: email
 *                      description: 'Attendee email address'
 *                    location:
 *                      type: object
 *                      properties:
 *                        optionValue:
 *                          type: string
 *                          description: 'Option value for the location'
 *                        value:
 *                          type: string
 *                          description: 'The meeting URL, Phone number or Address'
 *                      description: 'Meeting location'
 *               metadata:
 *                 type: object
 *                 properties: {}
 *                 description: 'Any metadata associated with the booking'
 *               timeZone:
 *                 type: string
 *                 description: 'TimeZone of the Attendee'
 *               language:
 *                 type: string
 *                 description: 'Language of the Attendee'
 *               title:
 *                 type: string
 *                 description: 'Booking event title'
 *               recurringEventId:
 *                 type: integer
 *                 description: 'Recurring event ID if the event is recurring'
 *               description:
 *                 type: string
 *                 description: 'Event description'
 *               status:
 *                 type: string
 *                 description: 'Acceptable values one of ["ACCEPTED", "PENDING", "CANCELLED", "REJECTED"]'
 *               seatsPerTimeSlot:
 *                 type: integer
 *                 description: 'The number of seats for each time slot'
 *               seatsShowAttendees:
 *                 type: boolean
 *                 description: 'Share Attendee information in seats'
 *               seatsShowAvailabilityCount:
 *                 type: boolean
 *                 description: 'Show the number of available seats'
 *               smsReminderNumber:
 *                 type: number
 *                 description: 'SMS reminder number'
 *           examples:
 *             New Booking example:
 *               value:
 *                 {
 *                   "eventTypeId": 2323232,
 *                   "start": "2023-05-24T13:00:00.000Z",
 *                   "end": "2023-05-24T13:30:00.000Z",
 *                   "responses":{
 *                     "name": "Hello Hello",
 *                     "email": "hello@gmail.com",
 *                     "metadata": {},
 *                     "location": "Calcom HQ",
 *                   },
 *                   "timeZone": "Europe/London",
 *                   "language": "en",
 *                   "title": "Debugging between Syed Ali Shahbaz and Hello Hello",
 *                   "description": null,
 *                   "status": "PENDING",
 *                   "smsReminderNumber": null
 *                 }
 *
 *     tags:
 *       - bookings
 *     responses:
 *       200:
 *         description: Booking(s) created successfully.
 *         content:
 *           application/json:
 *             examples:
 *               booking created successfully example:
 *                 value:
 *                   {
 *                     "booking": {
 *                       "id": 91,
 *                       "userId": 5,
 *                       "description": "",
 *                       "eventTypeId": 7,
 *                       "uid": "bFJeNb2uX8ANpT3JL5EfXw",
 *                       "title": "60min between Pro Example and John Doe",
 *                       "startTime": "2023-05-25T09:30:00.000Z",
 *                       "endTime": "2023-05-25T10:30:00.000Z",
 *                       "attendees": [
 *                         {
 *                           "email": "john.doe@example.com",
 *                           "name": "John Doe",
 *                           "timeZone": "Asia/Kolkata",
 *                           "locale": "en"
 *                         }
 *                       ],
 *                       "user": {
 *                         "email": "pro@example.com",
 *                         "name": "Pro Example",
 *                         "timeZone": "Asia/Kolkata",
 *                         "locale": "en"
 *                       },
 *                       "payment": [
 *                         {
 *                           "id": 1,
 *                           "success": true,
 *                           "paymentOption": "ON_BOOKING"
 *                         }
 *                       ],
 *                       "metadata": {},
 *                       "status": "ACCEPTED",
 *                       "responses": {
 *                         "email": "john.doe@example.com",
 *                         "name": "John Doe",
 *                         "location": {
 *                           "optionValue": "",
 *                           "value": "inPerson"
 *                         }
 *                       }
 *                     }
 *                   }
 *       400:
 *         description: |
 *           Bad request
 *           <table>
 *             <tr>
 *               <td>Message</td>
 *               <td>Cause</td>
 *             </tr>
 *             <tr>
 *               <td>Booking body is invalid</td>
 *               <td>Missing property on booking entity.</td>
 *             </tr>
 *             <tr>
 *               <td>Invalid eventTypeId</td>
 *               <td>The provided eventTypeId does not exist.</td>
 *             </tr>
 *             <tr>
 *               <td>Missing recurringCount</td>
 *               <td>The eventType is recurring, and no recurringCount was passed.</td>
 *             </tr>
 *             <tr>
 *               <td>Invalid recurringCount</td>
 *               <td>The provided recurringCount is greater than the eventType recurring config</td>
 *             </tr>
 *           </table>
 *       401:
 *         description: Authorization information is missing or invalid.
 */
async function handler(req: NextApiRequest) {
  const { userId, isAdmin } = req;
  if (isAdmin) req.userId = req.body.userId || userId;

  return await handleNewBooking(req);
}

export default defaultResponder(handler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import handleCancelBooking from "@calcom/features/bookings/lib/handleCancelBooking";
import { defaultResponder } from "@calcom/lib/server";
import { schemaBookingCancelParams } from "@calcom/prisma/zod-utils";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /bookings/{id}/cancel:
 *   delete:
 *     summary: Booking cancellation
 *     operationId: cancelBookingById
 *
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the booking to cancel
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *      - in: query
 *        name: allRemainingBookings
 *        required: false
 *        schema:
 *          type: boolean
 *        description: Delete all remaining bookings
 *      - in: query
 *        name: cancellationReason
 *        required: false
 *        schema:
 *          type: string
 *        description: The reason for cancellation of the booking
 *     tags:
 *       - bookings
 *     responses:
 *       200:
 *         description: OK, booking cancelled successfully
 *       400:
 *        description: |
 *          Bad request
 *           <table>
 *             <tr>
 *               <td>Message</td>
 *               <td>Cause</td>
 *             </tr>
 *             <tr>
 *               <td>Booking not found</td>
 *               <td>The provided id didn't correspond to any existing booking.</td>
 *             </tr>
 *             <tr>
 *               <td>User not found</td>
 *               <td>The userId did not matched an existing user.</td>
 *             </tr>
 *           </table>
 *       404:
 *        description: User not found
 */
async function handler(req: NextApiRequest) {
  const { id, allRemainingBookings, cancellationReason } = schemaQueryIdParseInt
    .merge(schemaBookingCancelParams.pick({ allRemainingBookings: true, cancellationReason: true }))
    .parse({
      ...req.query,
      allRemainingBookings: req.query.allRemainingBookings === "true",
    });
  // Normalizing for universal handler
  req.body = { id, allRemainingBookings, cancellationReason };
  return await handleCancelBooking(req);
}

export default defaultResponder(handler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, prisma, isAdmin, query } = req;
  if (isAdmin) {
    return;
  }

  const { id } = schemaQueryIdParseInt.parse(query);
  const userWithBookingsAndTeamIds = await prisma.user.findUnique({
    where: { id: userId },
    include: {
      bookings: true,
      teams: {
        select: {
          teamId: true,
        },
      },
    },
  });

  if (!userWithBookingsAndTeamIds) throw new HttpError({ statusCode: 404, message: "User not found" });

  const userBookingIds = userWithBookingsAndTeamIds.bookings.map((booking) => booking.id);

  if (!userBookingIds.includes(id)) {
    const teamBookings = await prisma.booking.findUnique({
      where: {
        id: id,
        eventType: {
          team: {
            id: {
              in: userWithBookingsAndTeamIds.teams.map((team) => team.teamId),
            },
          },
        },
      },
    });

    if (!teamBookings) {
      throw new HttpError({ statusCode: 401, message: "You are not authorized" });
    }
  }
}

export default authMiddleware;
import type { NextApiRequest } from "next";
import type { z } from "zod";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaBookingEditBodyParams, schemaBookingReadPublic } from "~/lib/validations/booking";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /bookings/{id}:
 *   patch:
 *     summary: Edit an existing booking
 *     operationId: editBookingById
 *     requestBody:
 *       description: Edit an existing booking related to one of your event-types
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               title:
 *                 type: string
 *                 description: 'Booking event title'
 *               start:
 *                 type: string
 *                 format: date-time
 *                 description: 'Start time of the Event'
 *               end:
 *                 type: string
 *                 format: date-time
 *                 description: 'End time of the Event'
 *               status:
 *                 type: string
 *                 description: 'Acceptable values one of ["ACCEPTED", "PENDING", "CANCELLED", "REJECTED"]'
 *               description:
 *                 type: string
 *                 description: 'Description of the meeting'
 *           examples:
 *             editBooking:
 *               value:
 *                 {
 *                   "title": "Debugging between Syed Ali Shahbaz and Hello Hello",
 *                   "start": "2023-05-24T13:00:00.000Z",
 *                   "end": "2023-05-24T13:30:00.000Z",
 *                   "status": "CANCELLED"
 *                 }
 *
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the booking to edit
 *     tags:
 *     - bookings
 *     responses:
 *       200:
 *         description: OK, booking edited successfully
 *         content:
 *           application/json:
 *             examples:
 *               bookings:
 *                 value:
 *                   {
 *                     "booking": {
 *                       "id": 11223344,
 *                       "userId": 182,
 *                       "description": null,
 *                       "eventTypeId": 2323232,
 *                       "uid": "stoSJtnh83PEL4rZmqdHe2",
 *                       "title": "Debugging between Syed Ali Shahbaz and Hello Hello",
 *                       "startTime": "2023-05-24T13:00:00.000Z",
 *                       "endTime": "2023-05-24T13:30:00.000Z",
 *                       "metadata": {},
 *                       "status": "CANCELLED",
 *                       "responses": {
 *                         "email": "john.doe@example.com",
 *                         "name": "John Doe",
 *                         "location": {
 *                           "optionValue": "",
 *                           "value": "inPerson"
 *                         }
 *                       }
 *                     }
 *                   }
 *       400:
 *        description: Bad request. Booking body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, body } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = schemaBookingEditBodyParams.parse(body);
  await checkPermissions(req, data);
  const booking = await prisma.booking.update({ where: { id }, data });
  return { booking: schemaBookingReadPublic.parse(booking) };
}

async function checkPermissions(req: NextApiRequest, body: z.infer<typeof schemaBookingEditBodyParams>) {
  const { isAdmin } = req;
  if (body.userId && !isAdmin) {
    // Organizer has to be a cal user and we can't allow a booking to be transfered to some other cal user's name
    throw new HttpError({
      statusCode: 403,
      message: "Only admin can change the organizer of a booking",
    });
  }
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(async (req: NextApiRequest, res: NextApiResponse) => {
  await authMiddleware(req);
  return defaultHandler({
    DELETE: import("./_delete"),
  })(req, res);
});
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaBookingReadPublic } from "~/lib/validations/booking";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /bookings/{id}:
 *   get:
 *     summary: Find a booking
 *     operationId: getBookingById
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the booking to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *     - bookings
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             schema:
 *               $ref: "#/components/schemas/Booking"
 *             examples:
 *               booking:
 *                 value:
 *                   {
 *                     "booking": {
 *                       "id": 91,
 *                       "userId": 5,
 *                       "description": "",
 *                       "eventTypeId": 7,
 *                       "uid": "bFJeNb2uX8ANpT3JL5EfXw",
 *                       "title": "60min between Pro Example and John Doe",
 *                       "startTime": "2023-05-25T09:30:00.000Z",
 *                       "endTime": "2023-05-25T10:30:00.000Z",
 *                       "attendees": [
 *                         {
 *                           "email": "john.doe@example.com",
 *                           "name": "John Doe",
 *                           "timeZone": "Asia/Kolkata",
 *                           "locale": "en"
 *                         }
 *                       ],
 *                       "user": {
 *                         "email": "pro@example.com",
 *                         "name": "Pro Example",
 *                         "timeZone": "Asia/Kolkata",
 *                         "locale": "en"
 *                       },
 *                       "payment": [
 *                         {
 *                           "id": 1,
 *                           "success": true,
 *                           "paymentOption": "ON_BOOKING"
 *                         }
 *                       ],
 *                       "metadata": {},
 *                       "status": "ACCEPTED",
 *                       "responses": {
 *                         "email": "john.doe@example.com",
 *                         "name": "John Doe",
 *                         "location": {
 *                           "optionValue": "",
 *                           "value": "inPerson"
 *                         }
 *                       }
 *                     }
 *                   }
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Booking was not found
 */

export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const booking = await prisma.booking.findUnique({
    where: { id },
    include: { attendees: true, user: true, payment: true },
  });
  return { booking: schemaBookingReadPublic.parse(booking) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaBookingGetParams, schemaBookingReadPublic } from "~/lib/validations/booking";
import { schemaQuerySingleOrMultipleAttendeeEmails } from "~/lib/validations/shared/queryAttendeeEmail";
import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";

/**
 * @swagger
 * /bookings:
 *   get:
 *     summary: Find all bookings
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *         example: 123456789abcdefgh
 *       - in: query
 *         name: userId
 *         required: false
 *         schema:
 *           oneOf:
 *            - type: integer
 *              example: 1
 *            - type: array
 *              items:
 *                type: integer
 *              example: [2, 3, 4]
 *       - in: query
 *         name: attendeeEmail
 *         required: false
 *         schema:
 *           oneOf:
 *            - type: string
 *              format: email
 *              example: john.doe@example.com
 *            - type: array
 *              items:
 *                type: string
 *                format: email
 *              example: [john.doe@example.com, jane.doe@example.com]
 *     operationId: listBookings
 *     tags:
 *     - bookings
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             schema:
 *               $ref: "#/components/schemas/ArrayOfBookings"
 *             examples:
 *               bookings:
 *                 value: [
 *                   {
 *                     "booking": {
 *                       "id": 91,
 *                       "userId": 5,
 *                       "description": "",
 *                       "eventTypeId": 7,
 *                       "uid": "bFJeNb2uX8ANpT3JL5EfXw",
 *                       "title": "60min between Pro Example and John Doe",
 *                       "startTime": "2023-05-25T09:30:00.000Z",
 *                       "endTime": "2023-05-25T10:30:00.000Z",
 *                       "attendees": [
 *                         {
 *                           "email": "john.doe@example.com",
 *                           "name": "John Doe",
 *                           "timeZone": "Asia/Kolkata",
 *                           "locale": "en"
 *                         }
 *                       ],
 *                       "user": {
 *                         "email": "pro@example.com",
 *                         "name": "Pro Example",
 *                         "timeZone": "Asia/Kolkata",
 *                         "locale": "en"
 *                       },
 *                       "payment": [
 *                         {
 *                           "id": 1,
 *                           "success": true,
 *                           "paymentOption": "ON_BOOKING"
 *                         }
 *                       ],
 *                       "metadata": {},
 *                       "status": "ACCEPTED",
 *                       "responses": {
 *                         "email": "john.doe@example.com",
 *                         "name": "John Doe",
 *                         "location": {
 *                           "optionValue": "",
 *                           "value": "inPerson"
 *                         }
 *                       }
 *                     }
 *                   }
 *                 ]
 *       401:
 *         description: Authorization information is missing or invalid.
 *       404:
 *         description: No bookings were found
 */

/**
 * Constructs the WHERE clause for Prisma booking findMany operation.
 *
 * @param userId - The ID of the user making the request. This is used to filter bookings where the user is either the host or an attendee.
 * @param attendeeEmails - An array of emails provided in the request for filtering bookings by attendee emails, used in case of Admin calls.
 * @param userIds - An array of user IDs to be included in the filter. Defaults to an empty array, and an array of user IDs in case of Admin call containing it.
 * @param userEmails - An array of user emails to be included in the filter if it is an Admin call and contains userId in query parameter. Defaults to an empty array.
 *
 * @returns An object that represents the WHERE clause for the findMany/findUnique operation.
 */
function buildWhereClause(
  userId: number | null,
  attendeeEmails: string[],
  userIds: number[] = [],
  userEmails: string[] = []
) {
  const filterByAttendeeEmails = attendeeEmails.length > 0;
  const userFilter = userIds.length > 0 ? { userId: { in: userIds } } : !!userId ? { userId } : {};
  let whereClause = {};
  if (filterByAttendeeEmails) {
    whereClause = {
      AND: [
        userFilter,
        {
          attendees: {
            some: {
              email: { in: attendeeEmails },
            },
          },
        },
      ],
    };
  } else {
    whereClause = {
      OR: [
        userFilter,
        {
          attendees: {
            some: {
              email: { in: userEmails },
            },
          },
        },
      ],
    };
  }

  return {
    ...whereClause,
  };
}

async function handler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;

  const { dateFrom, dateTo } = schemaBookingGetParams.parse(req.query);

  const args: Prisma.BookingFindManyArgs = {};
  args.include = {
    attendees: true,
    user: true,
    payment: true,
  };

  const queryFilterForAttendeeEmails = schemaQuerySingleOrMultipleAttendeeEmails.parse(req.query);
  const attendeeEmails = Array.isArray(queryFilterForAttendeeEmails.attendeeEmail)
    ? queryFilterForAttendeeEmails.attendeeEmail
    : typeof queryFilterForAttendeeEmails.attendeeEmail === "string"
    ? [queryFilterForAttendeeEmails.attendeeEmail]
    : [];
  const filterByAttendeeEmails = attendeeEmails.length > 0;

  /** Only admins can query other users */
  if (isAdmin) {
    if (req.query.userId) {
      const query = schemaQuerySingleOrMultipleUserIds.parse(req.query);
      const userIds = Array.isArray(query.userId) ? query.userId : [query.userId || userId];
      const users = await prisma.user.findMany({
        where: { id: { in: userIds } },
        select: { email: true },
      });
      const userEmails = users.map((u) => u.email);
      args.where = buildWhereClause(userId, attendeeEmails, userIds, userEmails);
    } else if (filterByAttendeeEmails) {
      args.where = buildWhereClause(null, attendeeEmails, [], []);
    }
  } else {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        email: true,
      },
    });

    if (!user) {
      throw new HttpError({ message: "User not found", statusCode: 500 });
    }
    args.where = buildWhereClause(userId, attendeeEmails, [], []);
  }

  if (dateFrom) {
    args.where = {
      ...args.where,
      startTime: { gte: dateFrom },
    };
  }
  if (dateTo) {
    args.where = {
      ...args.where,
      endTime: { lte: dateTo },
    };
  }

  const data = await prisma.booking.findMany(args);
  return { bookings: data.map((booking) => schemaBookingReadPublic.parse(booking)) };
}

export default defaultResponder(handler);
import type { NextApiRequest } from "next";
import type { z } from "zod";

import type { schemaEventTypeCreateBodyParams } from "~/lib/validations/event-type";

export default async function ensureOnlyMembersAsHosts(
  req: NextApiRequest,
  body: Pick<z.infer<typeof schemaEventTypeCreateBodyParams>, "hosts" | "teamId">
) {
  if (body.teamId && body.hosts && body.hosts.length > 0) {
    const teamMemberCount = await req.prisma.membership.count({
      where: {
        teamId: body.teamId,
        userId: { in: body.hosts.map((host) => host.userId) },
      },
    });

    if (teamMemberCount !== body.hosts.length) {
      throw new Error("You can only add members of the team to a team event type.");
    }
  }
}
import { CAL_URL } from "@calcom/lib/constants";

export default function getCalLink(eventType: {
  team?: { slug: string | null } | null;
  owner?: { username: string | null } | null;
  users?: { username: string | null }[];
  slug: string;
}) {
  return `${CAL_URL}/${
    eventType?.team
      ? `team/${eventType?.team?.slug}`
      : eventType?.owner
      ? eventType.owner.username
      : eventType?.users?.[0]?.username
  }/${eventType?.slug}`;
}
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

/**
 * Checks if a user, identified by the provided userId, has ownership (or admin rights) over
 * the team associated with the event type identified by the parentId.
 *
 * @param req - The current request
 *
 * @throws {HttpError} If the parent event type is not found,
 *                     if the parent event type doesn't belong to any team,
 *                     or if the user doesn't have ownership or admin rights to the associated team.
 */
export default async function checkParentEventOwnership(req: NextApiRequest) {
  const { userId, prisma, body } = req;
  /** These are already parsed upstream, we can assume they're good here. */
  const parentId = Number(body.parentId);
  const parentEventType = await prisma.eventType.findUnique({
    where: {
      id: parentId,
    },
    select: {
      teamId: true,
    },
  });

  if (!parentEventType) {
    throw new HttpError({
      statusCode: 404,
      message: "Parent event type not found.",
    });
  }

  if (!parentEventType.teamId) {
    throw new HttpError({
      statusCode: 400,
      message: "This event type is not capable of having children",
    });
  }

  const teamMember = await prisma.membership.findFirst({
    where: {
      teamId: parentEventType.teamId,
      userId: userId,
      OR: [{ role: "OWNER" }, { role: "ADMIN" }],
    },
  });

  if (!teamMember) {
    throw new HttpError({
      statusCode: 403,
      message: "User is not authorized to access the team to which the parent event type belongs.",
    });
  }
}
import type { NextApiRequest } from "next";
import type { z } from "zod";

import { HttpError } from "@calcom/lib/http-error";

import type { schemaEventTypeBaseBodyParams } from "~/lib/validations/event-type";

export default async function checkTeamEventEditPermission(
  req: NextApiRequest,
  body: Pick<z.infer<typeof schemaEventTypeBaseBodyParams>, "teamId">
) {
  const { prisma, userId } = req;
  if (body.teamId) {
    const membership = await prisma.membership.findFirst({
      where: {
        userId,
        teamId: body.teamId,
        accepted: true,
      },
    });

    if (!membership?.role || !["ADMIN", "OWNER"].includes(membership.role)) {
      throw new HttpError({
        statusCode: 401,
        message: "No permission to operate on event-type for this team",
      });
    }
  }
}
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

/**
 * Checks if a user, identified by the provided userId, is a member of the team associated
 * with the event type identified by the parentId.
 *
 * @param req - The current request
 *
 * @throws {HttpError} If the event type is not found,
 *                     if the event type doesn't belong to any team,
 *                     or if the user isn't a member of the associated team.
 */
export default async function checkUserMembership(req: NextApiRequest) {
  const { prisma, body } = req;
  /** These are already parsed upstream, we can assume they're good here. */
  const parentId = Number(body.parentId);
  const userId = Number(body.userId);
  const parentEventType = await prisma.eventType.findUnique({
    where: {
      id: parentId,
    },
    select: {
      teamId: true,
    },
  });

  if (!parentEventType) {
    throw new HttpError({
      statusCode: 404,
      message: "Event type not found.",
    });
  }

  if (!parentEventType.teamId) {
    throw new HttpError({
      statusCode: 400,
      message: "This event type is not capable of having children.",
    });
  }

  const teamMember = await prisma.membership.findFirst({
    where: {
      teamId: parentEventType.teamId,
      userId: userId,
      accepted: true,
    },
  });

  if (!teamMember) {
    throw new HttpError({
      statusCode: 400,
      message: "User is not a team member.",
    });
  }
}
import { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { MembershipRole } from "@calcom/prisma/client";

import { schemaEventTypeCreateBodyParams, schemaEventTypeReadPublic } from "~/lib/validations/event-type";
import { canUserAccessTeamWithRole } from "~/pages/api/teams/[teamId]/_auth-middleware";

import checkParentEventOwnership from "./_utils/checkParentEventOwnership";
import checkTeamEventEditPermission from "./_utils/checkTeamEventEditPermission";
import checkUserMembership from "./_utils/checkUserMembership";
import ensureOnlyMembersAsHosts from "./_utils/ensureOnlyMembersAsHosts";

/**
 * @swagger
 * /event-types:
 *   post:
 *     summary: Creates a new event type
 *     operationId: addEventType
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     requestBody:
 *       description: Create a new event-type related to your user or team
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - title
 *               - slug
 *               - length
 *               - metadata
 *             properties:
 *               length:
 *                 type: integer
 *                 description: Duration of the event type in minutes
 *               metadata:
 *                 type: object
 *                 description: Metadata relating to event type. Pass {} if empty
 *               title:
 *                 type: string
 *                 description: Title of the event type
 *               slug:
 *                 type: string
 *                 description: Unique slug for the event type
 *               hosts:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     userId:
 *                       type: number
 *                     isFixed:
 *                       type: boolean
 *                       description: Host MUST be available for any slot to be bookable.
 *               hidden:
 *                 type: boolean
 *                 description: If the event type should be hidden from your public booking page
 *               scheduleId:
 *                 type: number
 *                 description: The ID of the schedule for this event type
 *               position:
 *                 type: integer
 *                 description: The position of the event type on the public booking page
 *               teamId:
 *                 type: integer
 *                 description: Team ID if the event type should belong to a team
 *               periodType:
 *                 type: string
 *                 enum: [UNLIMITED, ROLLING, RANGE]
 *                 description: To decide how far into the future an invitee can book an event with you
 *               periodStartDate:
 *                 type: string
 *                 format: date-time
 *                 description: Start date of bookable period (Required if periodType is 'range')
 *               periodEndDate:
 *                 type: string
 *                 format: date-time
 *                 description: End date of bookable period (Required if periodType is 'range')
 *               periodDays:
 *                 type: integer
 *                 description: Number of bookable days (Required if periodType is rolling)
 *               periodCountCalendarDays:
 *                 type: boolean
 *                 description: If calendar days should be counted for period days
 *               requiresConfirmation:
 *                 type: boolean
 *                 description: If the event type should require your confirmation before completing the booking
 *               recurringEvent:
 *                 type: object
 *                 description: If the event should recur every week/month/year with the selected frequency
 *                 properties:
 *                   interval:
 *                     type: integer
 *                   count:
 *                     type: integer
 *                   freq:
 *                     type: integer
 *               disableGuests:
 *                 type: boolean
 *                 description: If the event type should disable adding guests to the booking
 *               hideCalendarNotes:
 *                 type: boolean
 *                 description: If the calendar notes should be hidden from the booking
 *               minimumBookingNotice:
 *                 type: integer
 *                 description: Minimum time in minutes before the event is bookable
 *               beforeEventBuffer:
 *                 type: integer
 *                 description: Number of minutes of buffer time before a Cal Event
 *               afterEventBuffer:
 *                 type: integer
 *                 description: Number of minutes of buffer time after a Cal Event
 *               schedulingType:
 *                 type: string
 *                 description: The type of scheduling if a Team event. Required for team events only
 *                 enum: [ROUND_ROBIN, COLLECTIVE, MANAGED]
 *               price:
 *                 type: integer
 *                 description: Price of the event type booking
 *               parentId:
 *                 type: integer
 *                 description: EventTypeId of the parent managed event
 *               currency:
 *                 type: string
 *                 description: Currency acronym. Eg- usd, eur, gbp, etc.
 *               slotInterval:
 *                 type: integer
 *                 description: The intervals of available bookable slots in minutes
 *               successRedirectUrl:
 *                 type: string
 *                 format: url
 *                 description: A valid URL where the booker will redirect to, once the booking is completed successfully
 *               description:
 *                 type: string
 *                 description: Description of the event type
 *               locations:
 *                 type: array
 *                 description: A list of all available locations for the event type
 *                 items:
 *                   type: array
 *                   items:
 *                     oneOf:
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['integrations:daily']
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['attendeeInPerson']
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['inPerson']
 *                           address:
 *                             type: string
 *                           displayLocationPublicly:
 *                             type: boolean
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['link']
 *                           link:
 *                             type: string
 *                           displayLocationPublicly:
 *                             type: boolean
 *           examples:
 *              event-type:
 *                summary: An example of an individual event type POST request
 *                value:
 *                  title: Hello World
 *                  slug: hello-world
 *                  length: 30
 *                  hidden: false
 *                  position: 0
 *                  eventName: null
 *                  timeZone: null
 *                  scheduleId: 5
 *                  periodType: UNLIMITED
 *                  periodStartDate: 2023-02-15T08:46:16.000Z
 *                  periodEndDate: 2023-0-15T08:46:16.000Z
 *                  periodDays: null
 *                  periodCountCalendarDays: false
 *                  requiresConfirmation: false
 *                  recurringEvent: null
 *                  disableGuests: false
 *                  hideCalendarNotes: false
 *                  minimumBookingNotice: 120
 *                  beforeEventBuffer: 0
 *                  afterEventBuffer: 0
 *                  price: 0
 *                  currency: usd
 *                  slotInterval: null
 *                  successRedirectUrl: null
 *                  description: A test event type
 *                  metadata: {
 *                    apps: {
 *                      stripe: {
 *                        price: 0,
 *                        enabled: false,
 *                        currency: usd
 *                      }
 *                    }
 *                  }
 *              team-event-type:
 *                summary: An example of a team event type POST request
 *                value:
 *                  title: "Tennis class"
 *                  slug: "tennis-class-{{$guid}}"
 *                  length: 60
 *                  hidden: false
 *                  position: 0
 *                  teamId: 3
 *                  eventName: null
 *                  timeZone: null
 *                  periodType: "UNLIMITED"
 *                  periodStartDate: null
 *                  periodEndDate: null
 *                  periodDays: null
 *                  periodCountCalendarDays: null
 *                  requiresConfirmation: true
 *                  recurringEvent:
 *                    interval: 2
 *                    count: 10
 *                    freq: 2
 *                  disableGuests: false
 *                  hideCalendarNotes: false
 *                  minimumBookingNotice: 120
 *                  beforeEventBuffer: 0
 *                  afterEventBuffer: 0
 *                  schedulingType: "COLLECTIVE"
 *                  price: 0
 *                  currency: "usd"
 *                  slotInterval: null
 *                  successRedirectUrl: null
 *                  description: null
 *                  locations:
 *                    - address: "London"
 *                      type: "inPerson"
 *                  metadata: {}
 *     tags:
 *     - event-types
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/event-types
 *     responses:
 *       201:
 *         description: OK, event type created
 *       400:
 *        description: Bad request. EventType body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma, body } = req;

  const {
    hosts = [],
    bookingLimits,
    durationLimits,
    /** FIXME: Adding event-type children from API not supported for now  */
    children: _,
    ...parsedBody
  } = schemaEventTypeCreateBodyParams.parse(body || {});

  let data: Prisma.EventTypeCreateArgs["data"] = {
    ...parsedBody,
    userId,
    users: { connect: { id: userId } },
    bookingLimits: bookingLimits === null ? Prisma.DbNull : bookingLimits,
    durationLimits: durationLimits === null ? Prisma.DbNull : durationLimits,
  };

  await checkPermissions(req);

  if (parsedBody.parentId) {
    await checkParentEventOwnership(req);
    await checkUserMembership(req);
  }

  if (isAdmin && parsedBody.userId) {
    data = { ...parsedBody, users: { connect: { id: parsedBody.userId } } };
  }

  await checkTeamEventEditPermission(req, parsedBody);
  await ensureOnlyMembersAsHosts(req, parsedBody);

  if (hosts) {
    data.hosts = { createMany: { data: hosts } };
  }

  const eventType = await prisma.eventType.create({ data, include: { hosts: true } });

  return {
    event_type: schemaEventTypeReadPublic.parse(eventType),
    message: "Event type created successfully",
  };
}

async function checkPermissions(req: NextApiRequest) {
  const { isAdmin } = req;
  const body = schemaEventTypeCreateBodyParams.parse(req.body);
  /* Non-admin users can only create event types for themselves */
  if (!isAdmin && body.userId)
    throw new HttpError({
      statusCode: 401,
      message: "ADMIN required for `userId`",
    });
  if (
    body.teamId &&
    !isAdmin &&
    !(await canUserAccessTeamWithRole(req.prisma, req.userId, isAdmin, body.teamId, {
      in: [MembershipRole.OWNER, MembershipRole.ADMIN],
    }))
  )
    throw new HttpError({
      statusCode: 401,
      message: "ADMIN required for `teamId`",
    });
  /* Admin users are required to pass in a userId or teamId */
  if (isAdmin && !body.userId && !body.teamId)
    throw new HttpError({ statusCode: 400, message: "`userId` or `teamId` required" });
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /event-types/{id}:
 *   delete:
 *     operationId: removeEventTypeById
 *     summary: Remove an existing eventType
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the eventType to delete
 *     tags:
 *     - event-types
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/event-types
 *     responses:
 *       201:
 *         description: OK, eventType removed successfully
 *       400:
 *        description: Bad request. EventType id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  await checkPermissions(req);
  await prisma.eventType.delete({ where: { id } });
  return { message: `Event Type with id: ${id} deleted successfully` };
}

async function checkPermissions(req: NextApiRequest) {
  const { userId, prisma, isAdmin } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  if (isAdmin) return;
  /** Only event type owners can delete it */
  const eventType = await prisma.eventType.findFirst({ where: { id, userId } });
  if (!eventType) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  if (isAdmin) return;
  const eventType = await prisma.eventType.findFirst({
    where: { id, users: { some: { id: userId } } },
  });
  if (!eventType) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";
import type { z } from "zod";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { SchedulingType } from "@calcom/prisma/enums";

import type { schemaEventTypeBaseBodyParams } from "~/lib/validations/event-type";
import { schemaEventTypeEditBodyParams, schemaEventTypeReadPublic } from "~/lib/validations/event-type";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";
import ensureOnlyMembersAsHosts from "~/pages/api/event-types/_utils/ensureOnlyMembersAsHosts";

import checkTeamEventEditPermission from "../_utils/checkTeamEventEditPermission";

/**
 * @swagger
 * /event-types/{id}:
 *   patch:
 *     operationId: editEventTypeById
 *     summary: Edit an existing eventType
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the eventType to edit
 *     requestBody:
 *       description: Create a new event-type related to your user or team
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               length:
 *                 type: integer
 *                 description: Duration of the event type in minutes
 *               metadata:
 *                 type: object
 *                 description: Metadata relating to event type. Pass {} if empty
 *               title:
 *                 type: string
 *                 description: Title of the event type
 *               slug:
 *                 type: string
 *                 description: Unique slug for the event type
 *               scheduleId:
 *                 type: number
 *                 description: The ID of the schedule for this event type
 *               hosts:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     userId:
 *                       type: number
 *                     isFixed:
 *                       type: boolean
 *                       description: Host MUST be available for any slot to be bookable.
 *               hidden:
 *                 type: boolean
 *                 description: If the event type should be hidden from your public booking page
 *               position:
 *                 type: integer
 *                 description: The position of the event type on the public booking page
 *               teamId:
 *                 type: integer
 *                 description: Team ID if the event type should belong to a team
 *               periodType:
 *                 type: string
 *                 enum: [UNLIMITED, ROLLING, RANGE]
 *                 description: To decide how far into the future an invitee can book an event with you
 *               periodStartDate:
 *                 type: string
 *                 format: date-time
 *                 description: Start date of bookable period (Required if periodType is 'range')
 *               periodEndDate:
 *                 type: string
 *                 format: date-time
 *                 description: End date of bookable period (Required if periodType is 'range')
 *               periodDays:
 *                 type: integer
 *                 description: Number of bookable days (Required if periodType is rolling)
 *               periodCountCalendarDays:
 *                 type: boolean
 *                 description: If calendar days should be counted for period days
 *               requiresConfirmation:
 *                 type: boolean
 *                 description: If the event type should require your confirmation before completing the booking
 *               recurringEvent:
 *                 type: object
 *                 description: If the event should recur every week/month/year with the selected frequency
 *                 properties:
 *                   interval:
 *                     type: integer
 *                   count:
 *                     type: integer
 *                   freq:
 *                     type: integer
 *               disableGuests:
 *                 type: boolean
 *                 description: If the event type should disable adding guests to the booking
 *               hideCalendarNotes:
 *                 type: boolean
 *                 description: If the calendar notes should be hidden from the booking
 *               minimumBookingNotice:
 *                 type: integer
 *                 description: Minimum time in minutes before the event is bookable
 *               beforeEventBuffer:
 *                 type: integer
 *                 description: Number of minutes of buffer time before a Cal Event
 *               afterEventBuffer:
 *                 type: integer
 *                 description: Number of minutes of buffer time after a Cal Event
 *               schedulingType:
 *                 type: string
 *                 description: The type of scheduling if a Team event. Required for team events only
 *                 enum: [ROUND_ROBIN, COLLECTIVE]
 *               price:
 *                 type: integer
 *                 description: Price of the event type booking
 *               currency:
 *                 type: string
 *                 description: Currency acronym. Eg- usd, eur, gbp, etc.
 *               slotInterval:
 *                 type: integer
 *                 description: The intervals of available bookable slots in minutes
 *               successRedirectUrl:
 *                 type: string
 *                 format: url
 *                 description: A valid URL where the booker will redirect to, once the booking is completed successfully
 *               description:
 *                 type: string
 *                 description: Description of the event type
 *               seatsPerTimeSlot:
 *                 type: integer
 *                 description: 'The number of seats for each time slot'
 *               seatsShowAttendees:
 *                 type: boolean
 *                 description: 'Share Attendee information in seats'
 *               seatsShowAvailabilityCount:
 *                 type: boolean
 *                 description: 'Show the number of available seats'
 *               locations:
 *                 type: array
 *                 description: A list of all available locations for the event type
 *                 items:
 *                   type: array
 *                   items:
 *                     oneOf:
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['integrations:daily']
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['attendeeInPerson']
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['inPerson']
 *                           address:
 *                             type: string
 *                           displayLocationPublicly:
 *                             type: boolean
 *                       - type: object
 *                         properties:
 *                           type:
 *                             type: string
 *                             enum: ['link']
 *                           link:
 *                             type: string
 *                           displayLocationPublicly:
 *                             type: boolean
 *           example:
 *              event-type:
 *                summary: An example of event type PATCH request
 *                value:
 *                  length: 60
 *                  requiresConfirmation: true
 *     tags:
 *     - event-types
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/event-types
 *     responses:
 *       201:
 *         description: OK, eventType edited successfully
 *       400:
 *        description: Bad request. EventType body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, body } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const {
    hosts = [],
    bookingLimits,
    durationLimits,
    /** FIXME: Updating event-type children from API not supported for now  */
    children: _,
    ...parsedBody
  } = schemaEventTypeEditBodyParams.parse(body);

  const data: Prisma.EventTypeUpdateArgs["data"] = {
    ...parsedBody,
    bookingLimits: bookingLimits === null ? Prisma.DbNull : bookingLimits,
    durationLimits: durationLimits === null ? Prisma.DbNull : durationLimits,
  };

  if (hosts) {
    await ensureOnlyMembersAsHosts(req, parsedBody);
    data.hosts = {
      deleteMany: {},
      create: hosts.map((host) => ({
        ...host,
        isFixed: data.schedulingType === SchedulingType.COLLECTIVE || host.isFixed,
      })),
    };
  }
  await checkPermissions(req, parsedBody);
  const eventType = await prisma.eventType.update({ where: { id }, data });
  return { event_type: schemaEventTypeReadPublic.parse(eventType) };
}

async function checkPermissions(req: NextApiRequest, body: z.infer<typeof schemaEventTypeBaseBodyParams>) {
  const { userId, prisma, isAdmin } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  if (isAdmin) return;
  /** Only event type owners can modify it */
  const eventType = await prisma.eventType.findFirst({ where: { id, userId } });
  if (!eventType) throw new HttpError({ statusCode: 403, message: "Forbidden" });
  await checkTeamEventEditPermission(req, body);
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { MembershipRole } from "@calcom/prisma/enums";

import { schemaEventTypeReadPublic } from "~/lib/validations/event-type";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";
import { checkPermissions as canAccessTeamEventOrThrow } from "~/pages/api/teams/[teamId]/_auth-middleware";

import getCalLink from "../_utils/getCalLink";

/**
 * @swagger
 * /event-types/{id}:
 *   get:
 *     operationId: getEventTypeById
 *     summary: Find a eventType
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: id
 *        example: 4
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the eventType to get
 *     tags:
 *     - event-types
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/event-types
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: EventType was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);

  const eventType = await prisma.eventType.findUnique({
    where: { id },
    include: {
      customInputs: true,
      team: { select: { slug: true } },
      users: true,
      hosts: { select: { userId: true, isFixed: true } },
      owner: { select: { username: true, id: true } },
      children: { select: { id: true, userId: true } },
    },
  });
  await checkPermissions(req, eventType);

  const link = eventType ? getCalLink(eventType) : null;
  // user.defaultScheduleId doesn't work the same for team events.
  if (!eventType?.scheduleId && eventType?.userId && !eventType?.teamId) {
    const user = await prisma.user.findUniqueOrThrow({
      where: {
        id: eventType.userId,
      },
      select: {
        defaultScheduleId: true,
      },
    });
    eventType.scheduleId = user.defaultScheduleId;
  }

  // TODO: eventType when not found should be a 404
  //       but API consumers may depend on the {} behaviour.
  return { event_type: schemaEventTypeReadPublic.parse({ ...eventType, link }) };
}

type BaseEventTypeCheckPermissions = {
  userId: number | null;
  teamId: number | null;
};

async function checkPermissions<T extends BaseEventTypeCheckPermissions>(
  req: NextApiRequest,
  eventType: (T & Partial<Omit<T, keyof BaseEventTypeCheckPermissions>>) | null
) {
  if (req.isAdmin) return true;
  if (eventType?.teamId) {
    req.query.teamId = String(eventType.teamId);
    await canAccessTeamEventOrThrow(req, {
      in: [MembershipRole.OWNER, MembershipRole.ADMIN, MembershipRole.MEMBER],
    });
  }
  if (eventType?.userId === req.userId) return true; // is owner.
  throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default defaultResponder(getHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import type { PrismaClient } from "@calcom/prisma";

import { schemaEventTypeReadPublic } from "~/lib/validations/event-type";
import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";

import getCalLink from "./_utils/getCalLink";

/**
 * @swagger
 * /event-types:
 *   get:
 *     summary: Find all event types
 *     operationId: listEventTypes
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     tags:
 *     - event-types
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/event-types
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No event types were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, prisma } = req;
  const userIds = req.query.userId ? extractUserIdsFromQuery(req) : [userId];
  const data = await prisma.eventType.findMany({
    where: {
      userId: { in: userIds },
    },
    include: {
      customInputs: true,
      team: { select: { slug: true } },
      users: true,
      hosts: { select: { userId: true, isFixed: true } },
      owner: { select: { username: true, id: true } },
      children: { select: { id: true, userId: true } },
    },
  });
  // this really should return [], but backwards compatibility..
  if (data.length === 0) new HttpError({ statusCode: 404, message: "No event types were found" });
  return {
    event_types: (await defaultScheduleId<(typeof data)[number]>({ eventTypes: data, prisma, userIds })).map(
      (eventType) => {
        const link = getCalLink(eventType);

        return schemaEventTypeReadPublic.parse({ ...eventType, link });
      }
    ),
  };
}
// TODO: Extract & reuse.
function extractUserIdsFromQuery({ isAdmin, query }: NextApiRequest) {
  /** Guard: Only admins can query other users */
  if (!isAdmin) {
    throw new HttpError({ statusCode: 401, message: "ADMIN required" });
  }
  const { userId: userIdOrUserIds } = schemaQuerySingleOrMultipleUserIds.parse(query);
  return Array.isArray(userIdOrUserIds) ? userIdOrUserIds : [userIdOrUserIds];
}

type DefaultScheduleIdEventTypeBase = {
  scheduleId: number | null;
  userId: number | null;
};
// If an eventType is given w/o a scheduleId
// Then we associate the default user schedule id to the eventType
async function defaultScheduleId<T extends DefaultScheduleIdEventTypeBase>({
  prisma,
  eventTypes,
  userIds,
}: {
  prisma: PrismaClient;
  eventTypes: (T & Partial<Omit<T, keyof DefaultScheduleIdEventTypeBase>>)[];
  userIds: number[];
}) {
  // there is no event types without a scheduleId, skip the user query
  if (eventTypes.every((eventType) => eventType.scheduleId)) return eventTypes;

  const users = await prisma.user.findMany({
    where: {
      id: {
        in: userIds,
      },
    },
    select: {
      id: true,
      defaultScheduleId: true,
    },
  });

  if (!users.length) {
    return eventTypes;
  }

  const defaultScheduleIds = users.reduce((result, user) => {
    result[user.id] = user.defaultScheduleId;

    return result;
  }, {} as { [x: number]: number | null });

  return eventTypes.map((eventType) => {
    // realistically never happens, userId should't be null on personal event types.
    if (!eventType.userId) return eventType;

    return {
      ...eventType,
      scheduleId: eventType.scheduleId || defaultScheduleIds[eventType.userId],
    };
  });
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";
import { v4 } from "uuid";

import { generateUniqueAPIKey } from "@calcom/features/ee/api-keys/lib/apiKeys";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { apiKeyCreateBodySchema, apiKeyPublicSchema } from "~/lib/validations/api-key";

async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { neverExpires, userId: bodyUserId, ...input } = apiKeyCreateBodySchema.parse(req.body);
  const [hashedKey, apiKey] = generateUniqueAPIKey();
  const args: Prisma.ApiKeyCreateArgs = {
    data: {
      id: v4(),
      userId,
      ...input,
      // And here we pass a null to expiresAt if never expires is true. otherwise just pass expiresAt from input
      expiresAt: neverExpires ? null : input.expiresAt,
      hashedKey,
    },
  };

  if (!isAdmin && bodyUserId) throw new HttpError({ statusCode: 403, message: `ADMIN required for userId` });

  if (isAdmin && bodyUserId) {
    const where: Prisma.UserWhereInput = { id: bodyUserId };
    await prisma.user.findFirstOrThrow({ where });
    args.data.userId = bodyUserId;
  }

  const result = await prisma.apiKey.create(args);
  return {
    api_key: {
      ...apiKeyPublicSchema.parse(result),
      key: `${process.env.API_KEY_PREFIX ?? "cal_"}${apiKey}`,
    },
    message: "API key created successfully. Save the `key` value as it won't be displayed again.",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware("HTTP_GET_OR_POST")(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";

async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdAsString.parse(query);
  await prisma.apiKey.delete({ where: { id } });
  return { message: `ApiKey with id: ${id} deleted` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";

export async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdAsString.parse(req.query);
  // Admin can check any api key
  if (isAdmin) return;
  // Check if user can access the api key
  const apiKey = await prisma.apiKey.findFirst({
    where: { id, userId },
  });
  if (!apiKey) throw new HttpError({ statusCode: 404, message: "API key not found" });
}
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { apiKeyEditBodySchema, apiKeyPublicSchema } from "~/lib/validations/api-key";
import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";

async function patchHandler(req: NextApiRequest) {
  const { prisma, body } = req;
  const { id } = schemaQueryIdAsString.parse(req.query);
  const data = apiKeyEditBodySchema.parse(body);
  const api_key = await prisma.apiKey.update({ where: { id }, data });
  return { api_key: apiKeyPublicSchema.parse(api_key) };
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import { authMiddleware } from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { apiKeyPublicSchema } from "~/lib/validations/api-key";
import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";

async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdAsString.parse(query);
  const api_key = await prisma.apiKey.findUniqueOrThrow({ where: { id } });
  return { api_key: apiKeyPublicSchema.parse(api_key) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";
import type { Ensure } from "@calcom/types/utils";

import { apiKeyPublicSchema } from "~/lib/validations/api-key";
import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";

type CustomNextApiRequest = NextApiRequest & {
  args?: Prisma.ApiKeyFindManyArgs;
};

/** Admins can query other users' API keys */
function handleAdminRequests(req: CustomNextApiRequest) {
  // To match type safety with runtime
  if (!hasReqArgs(req)) throw Error("Missing req.args");
  const { userId, isAdmin } = req;
  if (isAdmin && req.query.userId) {
    const query = schemaQuerySingleOrMultipleUserIds.parse(req.query);

    const userIds = Array.isArray(query.userId) ? query.userId : [query.userId || userId];
    req.args.where = { userId: { in: userIds } };

    if (Array.isArray(query.userId)) req.args.orderBy = { userId: "asc" };
  }
}

function hasReqArgs(req: CustomNextApiRequest): req is Ensure<CustomNextApiRequest, "args"> {
  return "args" in req;
}

async function getHandler(req: CustomNextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  req.args = isAdmin ? {} : { where: { userId } };
  // Proof of concept: allowing mutation in exchange of composability
  handleAdminRequests(req);
  const data = await prisma.apiKey.findMany(req.args);
  return { api_keys: data.map((v) => apiKeyPublicSchema.parse(v)) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { DEFAULT_SCHEDULE, getAvailabilityFromSchedule } from "@calcom/lib/availability";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaCreateScheduleBodyParams, schemaSchedulePublic } from "~/lib/validations/schedule";

/**
 * @swagger
 * /schedules:
 *   post:
 *     operationId: addSchedule
 *     summary: Creates a new schedule
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     requestBody:
 *       description: Create a new schedule
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - name
 *               - timeZone
 *             properties:
 *               name:
 *                 type: string
 *                 description: Name of the schedule
 *               timeZone:
 *                 type: string
 *                 description: The timeZone for this schedule
 *           examples:
 *             schedule:
 *               value:
 *                 {
 *                   "name": "Sample Schedule",
 *                   "timeZone": "Asia/Calcutta"
 *                 }
 *     tags:
 *     - schedules
 *     responses:
 *       200:
 *         description: OK, schedule created
 *         content:
 *           application/json:
 *             examples:
 *               schedule:
 *                 value:
 *                   {
 *                     "schedule": {
 *                       "id": 79471,
 *                       "userId": 182,
 *                       "name": "Total Testing",
 *                       "timeZone": "Asia/Calcutta",
 *                       "availability": [
 *                         {
 *                           "id": 337917,
 *                           "eventTypeId": null,
 *                           "days": [1, 2, 3, 4, 5],
 *                           "startTime": "09:00:00",
 *                           "endTime": "17:00:00"
 *                         }
 *                       ]
 *                     },
 *                     "message": "Schedule created successfully"
 *                   }
 *       400:
 *        description: Bad request. Schedule body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */

async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const body = schemaCreateScheduleBodyParams.parse(req.body);
  let args: Prisma.ScheduleCreateArgs = { data: { ...body, userId } };

  /* If ADMIN we create the schedule for selected user */
  if (isAdmin && body.userId) args = { data: { ...body, userId: body.userId } };

  if (!isAdmin && body.userId)
    throw new HttpError({ statusCode: 403, message: "ADMIN required for `userId`" });

  // We create default availabilities for the schedule
  args.data.availability = {
    createMany: {
      data: getAvailabilityFromSchedule(DEFAULT_SCHEDULE).map((schedule) => ({
        days: schedule.days,
        startTime: schedule.startTime,
        endTime: schedule.endTime,
      })),
    },
  };
  // We include the recently created availability
  args.include = { availability: true };

  const data = await prisma.schedule.create(args);

  return {
    schedule: schemaSchedulePublic.parse(data),
    message: "Schedule created successfully",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /schedules/{id}:
 *   delete:
 *     operationId: removeScheduleById
 *     summary: Remove an existing schedule
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the schedule to delete
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     tags:
 *     - schedules
 *     responses:
 *       201:
 *         description: OK, schedule removed successfully
 *       400:
 *        description: Bad request. Schedule id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);

  /* If we're deleting any default user schedule, we unset it */
  await prisma.user.updateMany({ where: { defaultScheduleId: id }, data: { defaultScheduleId: undefined } });

  await prisma.schedule.delete({ where: { id } });
  return { message: `Schedule with id: ${id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  // Admins can just skip this check
  if (isAdmin) return;
  // Check if the current user can access the schedule
  const schedule = await prisma.schedule.findFirst({
    where: { id, userId },
  });
  if (!schedule) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { NextApiRequest } from "next";
import type { z } from "zod";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaSchedulePublic, schemaSingleScheduleBodyParams } from "~/lib/validations/schedule";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /schedules/{id}:
 *   patch:
 *     operationId: editScheduleById
 *     summary: Edit an existing schedule
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the schedule to edit
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     requestBody:
 *       description: Edit an existing schedule
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: Name of the schedule
 *               timeZone:
 *                 type: string
 *                 description: The timezone for this schedule
 *           examples:
 *             schedule:
 *               value:
 *                 {
 *                   "name": "Updated Schedule",
 *                   "timeZone": "Asia/Calcutta"
 *                 }
 *     tags:
 *     - schedules
 *     responses:
 *       200:
 *         description: OK, schedule edited successfully
 *         content:
 *           application/json:
 *             examples:
 *               schedule:
 *                 value:
 *                   {
 *                     "schedule": {
 *                       "id": 12345,
 *                       "userId": 1,
 *                       "name": "Total Testing Part 2",
 *                       "timeZone": "Asia/Calcutta",
 *                       "availability": [
 *                         {
 *                           "id": 4567,
 *                           "eventTypeId": null,
 *                           "days": [1, 2, 3, 4, 5],
 *                           "startTime": "09:00:00",
 *                           "endTime": "17:00:00"
 *                         }
 *                       ]
 *                     }
 *                   }
 *       400:
 *        description: Bad request. Schedule body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */

export async function patchHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = schemaSingleScheduleBodyParams.parse(req.body);
  await checkPermissions(req, data);
  const result = await prisma.schedule.update({ where: { id }, data, include: { availability: true } });
  return { schedule: schemaSchedulePublic.parse(result) };
}

async function checkPermissions(req: NextApiRequest, body: z.infer<typeof schemaSingleScheduleBodyParams>) {
  const { isAdmin } = req;
  if (isAdmin) return;
  if (body.userId) {
    throw new HttpError({ statusCode: 403, message: "Non admin cannot change the owner of a schedule" });
  }
  //_auth-middleware takes care of verifying the ownership of schedule.
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaSchedulePublic } from "~/lib/validations/schedule";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /schedules/{id}:
 *   get:
 *     operationId: getScheduleById
 *     summary: Find a schedule
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the schedule to get
 *       - in: query
 *         name: apiKey
 *         schema:
 *           type: string
 *         required: true
 *         description: Your API Key
 *     tags:
 *     - schedules
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             examples:
 *               schedule:
 *                 value:
 *                   {
 *                     "schedule": {
 *                       "id": 12345,
 *                       "userId": 182,
 *                       "name": "Sample Schedule",
 *                       "timeZone": "Asia/Calcutta",
 *                       "availability": [
 *                         {
 *                           "id": 111,
 *                           "eventTypeId": null,
 *                           "days": [0, 1, 2, 3, 4, 6],
 *                           "startTime": "00:00:00",
 *                           "endTime": "23:45:00"
 *                         },
 *                         {
 *                           "id": 112,
 *                           "eventTypeId": null,
 *                           "days": [5],
 *                           "startTime": "00:00:00",
 *                           "endTime": "12:00:00"
 *                         },
 *                         {
 *                           "id": 113,
 *                           "eventTypeId": null,
 *                           "days": [5],
 *                           "startTime": "15:00:00",
 *                           "endTime": "23:45:00"
 *                         }
 *                       ]
 *                     }
 *                   }
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Schedule was not found
 */

export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = await prisma.schedule.findUniqueOrThrow({ where: { id }, include: { availability: true } });
  return { schedule: schemaSchedulePublic.parse(data) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";
import { z } from "zod";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaSchedulePublic } from "~/lib/validations/schedule";
import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";

export const schemaUserIds = z
  .union([z.string(), z.array(z.string())])
  .transform((val) => (Array.isArray(val) ? val.map((v) => parseInt(v, 10)) : [parseInt(val, 10)]));

/**
 * @swagger
 * /schedules:
 *   get:
 *     operationId: listSchedules
 *     summary: Find all schedules
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     tags:
 *     - schedules
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             examples:
 *               schedules:
 *                 value:
 *                   {
 *                     "schedules": [
 *                       {
 *                         "id": 1234,
 *                         "userId": 5678,
 *                         "name": "Sample Schedule 1",
 *                         "timeZone": "America/Chicago",
 *                         "availability": [
 *                           {
 *                             "id": 987,
 *                             "eventTypeId": null,
 *                             "days": [1, 2, 3, 4, 5],
 *                             "startTime": "09:00:00",
 *                             "endTime": "23:00:00"
 *                           }
 *                         ]
 *                       },
 *                       {
 *                         "id": 2345,
 *                         "userId": 6789,
 *                         "name": "Sample Schedule 2",
 *                         "timeZone": "Europe/Amsterdam",
 *                         "availability": [
 *                           {
 *                             "id": 876,
 *                             "eventTypeId": null,
 *                             "days": [1, 2, 3, 4, 5],
 *                             "startTime": "09:00:00",
 *                             "endTime": "17:00:00"
 *                           }
 *                         ]
 *                       }
 *                     ]
 *                   }
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No schedules were found
 */

async function handler(req: NextApiRequest) {
  const { prisma, userId, isAdmin } = req;
  const args: Prisma.ScheduleFindManyArgs = isAdmin ? {} : { where: { userId } };
  args.include = { availability: true };

  if (!isAdmin && req.query.userId)
    throw new HttpError({
      statusCode: 401,
      message: "Unauthorized: Only admins can query other users",
    });

  if (isAdmin && req.query.userId) {
    const query = schemaQuerySingleOrMultipleUserIds.parse(req.query);

    const userIds = Array.isArray(query.userId) ? query.userId : [query.userId || userId];
    args.where = { userId: { in: userIds } };

    if (Array.isArray(query.userId)) args.orderBy = { userId: "asc" };
  }
  const data = await prisma.schedule.findMany(args);
  return { schedules: data.map((s) => schemaSchedulePublic.parse(s)) };
}

export default defaultResponder(handler);
import type { NextApiRequest } from "next";

import { getCalendarCredentials, getConnectedCalendars } from "@calcom/core/CalendarManager";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { credentialForCalendarServiceSelect } from "@calcom/prisma/selects/credential";

import {
  schemaDestinationCalendarReadPublic,
  schemaDestinationCalendarCreateBodyParams,
} from "~/lib/validations/destination-calendar";

/**
 * @swagger
 * /destination-calendars:
 *   post:
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     summary: Creates a new destination calendar
 *     requestBody:
 *       description: Create a new destination calendar for your events
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - integration
 *               - externalId
 *               - credentialId
 *             properties:
 *               integration:
 *                 type: string
 *                 description: 'The integration'
 *               externalId:
 *                 type: string
 *                 description: 'The external ID of the integration'
 *               eventTypeId:
 *                 type: integer
 *                 description: 'The ID of the eventType it is associated with'
 *               bookingId:
 *                 type: integer
 *                 description: 'The booking ID it is associated with'
 *               userId:
 *                 type: integer
 *                 description: 'The user it is associated with'
 *     tags:
 *      - destination-calendars
 *     responses:
 *       201:
 *         description: OK, destination calendar created
 *       400:
 *        description: Bad request. DestinationCalendar body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma, body } = req;
  const parsedBody = schemaDestinationCalendarCreateBodyParams.parse(body);
  await checkPermissions(req, userId);

  const assignedUserId = isAdmin && parsedBody.userId ? parsedBody.userId : userId;

  /* Check if credentialId data matches the ownership and integration passed in */
  const userCredentials = await prisma.credential.findMany({
    where: {
      type: parsedBody.integration,
      userId: assignedUserId,
    },
    select: credentialForCalendarServiceSelect,
  });

  if (userCredentials.length === 0)
    throw new HttpError({
      statusCode: 400,
      message: "Bad request, credential id invalid",
    });

  const calendarCredentials = getCalendarCredentials(userCredentials);

  const { connectedCalendars } = await getConnectedCalendars(calendarCredentials, [], parsedBody.externalId);

  const eligibleCalendars = connectedCalendars[0]?.calendars?.filter((calendar) => !calendar.readOnly);
  const calendar = eligibleCalendars?.find(
    (c) => c.externalId === parsedBody.externalId && c.integration === parsedBody.integration
  );
  if (!calendar?.credentialId)
    throw new HttpError({
      statusCode: 400,
      message: "Bad request, credential id invalid",
    });
  const credentialId = calendar.credentialId;

  if (parsedBody.eventTypeId) {
    const eventType = await prisma.eventType.findFirst({
      where: { id: parsedBody.eventTypeId, userId: parsedBody.userId },
    });

    if (!eventType)
      throw new HttpError({
        statusCode: 400,
        message: "Bad request, eventTypeId invalid",
      });
    parsedBody.userId = undefined;
  }

  const destination_calendar = await prisma.destinationCalendar.create({
    data: { ...parsedBody, credentialId },
  });

  return {
    destinationCalendar: schemaDestinationCalendarReadPublic.parse(destination_calendar),
    message: "Destination calendar created successfully",
  };
}

async function checkPermissions(req: NextApiRequest, userId: number) {
  const { isAdmin } = req;
  const body = schemaDestinationCalendarCreateBodyParams.parse(req.body);

  /* Non-admin users can only create destination calendars for themselves */
  if (!isAdmin && body.userId)
    throw new HttpError({
      statusCode: 401,
      message: "ADMIN required for `userId`",
    });
  /* Admin users are required to pass in a userId */
  if (isAdmin && !body.userId) throw new HttpError({ statusCode: 400, message: "`userId` required" });
  /* User should only be able to create for their own destination calendars*/
  if (!isAdmin && body.eventTypeId) {
    const ownsEventType = await req.prisma.eventType.findFirst({ where: { id: body.eventTypeId, userId } });

    if (!ownsEventType) throw new HttpError({ statusCode: 401, message: "Unauthorized" });
  }
  // TODO:: Add support for team event types with validation
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /destination-calendars/{id}:
 *   delete:
 *     summary: Remove an existing destination calendar
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the destination calendar to delete
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     tags:
 *      - destination-calendars
 *     responses:
 *       200:
 *         description: OK, destinationCalendar removed successfully
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *        description: Destination calendar not found
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  await prisma.destinationCalendar.delete({ where: { id } });
  return { message: `OK, Destination Calendar removed successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  if (isAdmin) return;
  const userEventTypes = await prisma.eventType.findMany({
    where: { userId },
    select: { id: true },
  });

  const userEventTypeIds = userEventTypes.map((eventType) => eventType.id);

  const destinationCalendar = await prisma.destinationCalendar.findFirst({
    where: {
      AND: [
        { id },
        {
          OR: [{ userId }, { eventTypeId: { in: userEventTypeIds } }],
        },
      ],
    },
  });
  if (!destinationCalendar)
    throw new HttpError({ statusCode: 404, message: "Destination calendar not found" });
}

export default authMiddleware;
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";
import type { z } from "zod";

import { getCalendarCredentials, getConnectedCalendars } from "@calcom/core/CalendarManager";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import type { PrismaClient } from "@calcom/prisma";
import { credentialForCalendarServiceSelect } from "@calcom/prisma/selects/credential";

import {
  schemaDestinationCalendarEditBodyParams,
  schemaDestinationCalendarReadPublic,
} from "~/lib/validations/destination-calendar";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /destination-calendars/{id}:
 *   patch:
 *     summary: Edit an existing destination calendar
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the destination calendar to edit
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     requestBody:
 *       description: Create a new booking related to one of your event-types
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               integration:
 *                 type: string
 *                 description: 'The integration'
 *               externalId:
 *                 type: string
 *                 description: 'The external ID of the integration'
 *               eventTypeId:
 *                 type: integer
 *                 description: 'The ID of the eventType it is associated with'
 *               bookingId:
 *                 type: integer
 *                 description: 'The booking ID it is associated with'
 *     tags:
 *      - destination-calendars
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *        description: Destination calendar not found
 */
type DestinationCalendarType = {
  userId?: number | null;
  eventTypeId?: number | null;
  credentialId: number | null;
};

type UserCredentialType = {
  id: number;
  appId: string | null;
  type: string;
  userId: number | null;
  user: {
    email: string;
  } | null;
  teamId: number | null;
  key: Prisma.JsonValue;
  invalid: boolean | null;
};

export async function patchHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma, query, body } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const parsedBody = schemaDestinationCalendarEditBodyParams.parse(body);
  const assignedUserId = isAdmin ? parsedBody.userId || userId : userId;

  validateIntegrationInput(parsedBody);
  const destinationCalendarObject: DestinationCalendarType = await getDestinationCalendar(id, prisma);
  await validateRequestAndOwnership({ destinationCalendarObject, parsedBody, assignedUserId, prisma });

  const userCredentials = await getUserCredentials({
    credentialId: destinationCalendarObject.credentialId,
    userId: assignedUserId,
    prisma,
  });
  const credentialId = await verifyCredentialsAndGetId({
    parsedBody,
    userCredentials,
    currentCredentialId: destinationCalendarObject.credentialId,
  });
  // If the user has passed eventTypeId, we need to remove userId from the update data to make sure we don't link it to user as well
  if (parsedBody.eventTypeId) parsedBody.userId = undefined;
  const destinationCalendar = await prisma.destinationCalendar.update({
    where: { id },
    data: { ...parsedBody, credentialId },
  });
  return { destinationCalendar: schemaDestinationCalendarReadPublic.parse(destinationCalendar) };
}

/**
 * Retrieves user credentials associated with a given credential ID and user ID and validates if the credentials belong to this user
 *
 * @param credentialId - The ID of the credential to fetch. If not provided, an error is thrown.
 * @param userId - The user ID against which the credentials need to be verified.
 * @param prisma - An instance of PrismaClient for database operations.
 *
 * @returns - An array containing the matching user credentials.
 *
 * @throws HttpError - If `credentialId` is not provided or no associated credentials are found in the database.
 */
async function getUserCredentials({
  credentialId,
  userId,
  prisma,
}: {
  credentialId: number | null;
  userId: number;
  prisma: PrismaClient;
}) {
  if (!credentialId) {
    throw new HttpError({
      statusCode: 404,
      message: `Destination calendar missing credential id`,
    });
  }
  const userCredentials = await prisma.credential.findMany({
    where: { id: credentialId, userId },
    select: credentialForCalendarServiceSelect,
  });

  if (!userCredentials || userCredentials.length === 0) {
    throw new HttpError({
      statusCode: 400,
      message: `Bad request, no associated credentials found`,
    });
  }
  return userCredentials;
}

/**
 * Verifies the provided credentials and retrieves the associated credential ID.
 *
 * This function checks if the `integration` and `externalId` properties from the parsed body are present.
 * If both properties exist, it fetches the connected calendar credentials using the provided user credentials
 * and checks for a matching external ID and integration from the list of connected calendars.
 *
 * If a match is found, it updates the `credentialId` with the one from the connected calendar.
 * Otherwise, it throws an HTTP error with a 400 status indicating an invalid credential ID.
 *
 * If the parsed body does not contain the necessary properties, the function
 * returns the `credentialId` from the destination calendar object.
 *
 * @param parsedBody - The parsed body from the incoming request, validated against a predefined schema.
 *                     Checked if it contain properties like `integration` and `externalId`.
 * @param userCredentials - An array of user credentials used to fetch the connected calendar credentials.
 * @param destinationCalendarObject - An object representing the destination calendar. Primarily used
 *                                    to fetch the default `credentialId`.
 *
 * @returns - The verified `credentialId` either from the matched connected calendar in case of updating the destination calendar,
 *            or the provided destination calendar object in other cases.
 *
 * @throws HttpError - If no matching connected calendar is found for the given `integration` and `externalId`.
 */
async function verifyCredentialsAndGetId({
  parsedBody,
  userCredentials,
  currentCredentialId,
}: {
  parsedBody: z.infer<typeof schemaDestinationCalendarEditBodyParams>;
  userCredentials: UserCredentialType[];
  currentCredentialId: number | null;
}) {
  if (parsedBody.integration && parsedBody.externalId) {
    const calendarCredentials = getCalendarCredentials(userCredentials);

    const { connectedCalendars } = await getConnectedCalendars(
      calendarCredentials,
      [],
      parsedBody.externalId
    );

    const eligibleCalendars = connectedCalendars[0]?.calendars?.filter((calendar) => !calendar.readOnly);

    const calendar = eligibleCalendars?.find(
      (c) => c.externalId === parsedBody.externalId && c.integration === parsedBody.integration
    );

    if (!calendar?.credentialId)
      throw new HttpError({
        statusCode: 400,
        message: "Bad request, credential id invalid",
      });

    return calendar?.credentialId;
  }
  return currentCredentialId;
}

/**
 * Validates the request for updating a destination calendar.
 *
 * This function checks the validity of the provided eventTypeId against the existing destination calendar object
 * in the sense that if the destination calendar is not linked to an event type, the eventTypeId can not be provided.
 *
 * It also ensures that the eventTypeId, if provided, belongs to the assigned user.
 *
 * @param destinationCalendarObject - An object representing the destination calendar.
 * @param parsedBody - The parsed body from the incoming request, validated against a predefined schema.
 * @param assignedUserId - The user ID assigned for the operation, which might be an admin or a regular user.
 * @param prisma - An instance of PrismaClient for database operations.
 *
 * @throws HttpError - If the validation fails or inconsistencies are detected in the request data.
 */
async function validateRequestAndOwnership({
  destinationCalendarObject,
  parsedBody,
  assignedUserId,
  prisma,
}: {
  destinationCalendarObject: DestinationCalendarType;
  parsedBody: z.infer<typeof schemaDestinationCalendarEditBodyParams>;
  assignedUserId: number;
  prisma: PrismaClient;
}) {
  if (parsedBody.eventTypeId) {
    if (!destinationCalendarObject.eventTypeId) {
      throw new HttpError({
        statusCode: 400,
        message: `The provided destination calendar can not be linked to an event type`,
      });
    }

    const userEventType = await prisma.eventType.findFirst({
      where: { id: parsedBody.eventTypeId },
      select: { userId: true },
    });

    if (!userEventType || userEventType.userId !== assignedUserId) {
      throw new HttpError({
        statusCode: 404,
        message: `Event type with ID ${parsedBody.eventTypeId} not found`,
      });
    }
  }

  if (!parsedBody.eventTypeId) {
    if (destinationCalendarObject.eventTypeId) {
      throw new HttpError({
        statusCode: 400,
        message: `The provided destination calendar can only be linked to an event type`,
      });
    }
    if (destinationCalendarObject.userId !== assignedUserId) {
      throw new HttpError({
        statusCode: 403,
        message: `Forbidden`,
      });
    }
  }
}

/**
 * Fetches the destination calendar based on the provided ID as the path parameter, specifically `credentialId` and `eventTypeId`.
 *
 * If no matching destination calendar is found for the provided ID, an HTTP error with a 404 status
 * indicating that the desired destination calendar was not found is thrown.
 *
 * @param id - The ID of the destination calendar to be retrieved.
 * @param prisma - An instance of PrismaClient for database operations.
 *
 * @returns - An object containing details of the matching destination calendar, specifically `credentialId` and `eventTypeId`.
 *
 * @throws HttpError - If no destination calendar matches the provided ID.
 */
async function getDestinationCalendar(id: number, prisma: PrismaClient) {
  const destinationCalendarObject = await prisma.destinationCalendar.findFirst({
    where: {
      id,
    },
    select: { userId: true, eventTypeId: true, credentialId: true },
  });

  if (!destinationCalendarObject) {
    throw new HttpError({
      statusCode: 404,
      message: `Destination calendar with ID ${id} not found`,
    });
  }

  return destinationCalendarObject;
}

function validateIntegrationInput(parsedBody: z.infer<typeof schemaDestinationCalendarEditBodyParams>) {
  if (parsedBody.integration && !parsedBody.externalId) {
    throw new HttpError({ statusCode: 400, message: "External Id is required with integration value" });
  }
  if (!parsedBody.integration && parsedBody.externalId) {
    throw new HttpError({ statusCode: 400, message: "Integration value is required with external ID" });
  }
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaDestinationCalendarReadPublic } from "~/lib/validations/destination-calendar";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /destination-calendars/{id}:
 *   get:
 *     summary: Find a destination calendar
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the destination calendar to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *      - destination-calendars
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Destination calendar not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);

  const destinationCalendar = await prisma.destinationCalendar.findUnique({
    where: { id },
  });

  return { destinationCalendar: schemaDestinationCalendarReadPublic.parse({ ...destinationCalendar }) };
}

export default defaultResponder(getHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { extractUserIdsFromQuery } from "~/lib/utils/extractUserIdsFromQuery";
import { schemaDestinationCalendarReadPublic } from "~/lib/validations/destination-calendar";

/**
 * @swagger
 * /destination-calendars:
 *   get:
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     summary: Find all destination calendars
 *     tags:
 *      - destination-calendars
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No destination calendars were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, prisma } = req;
  const userIds = req.query.userId ? extractUserIdsFromQuery(req) : [userId];

  const userEventTypes = await prisma.eventType.findMany({
    where: { userId: { in: userIds } },
    select: { id: true },
  });

  const userEventTypeIds = userEventTypes.map((eventType) => eventType.id);

  const allDestinationCalendars = await prisma.destinationCalendar.findMany({
    where: {
      OR: [{ userId: { in: userIds } }, { eventTypeId: { in: userEventTypeIds } }],
    },
  });

  if (allDestinationCalendars.length === 0)
    new HttpError({ statusCode: 404, message: "No destination calendars were found" });

  return {
    destinationCalendars: allDestinationCalendars.map((destinationCalendar) =>
      schemaDestinationCalendarReadPublic.parse(destinationCalendar)
    ),
  };
}

export default defaultResponder(getHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import {
  schemaEventTypeCustomInputBodyParams,
  schemaEventTypeCustomInputPublic,
} from "~/lib/validations/event-type-custom-input";

/**
 * @swagger
 * /custom-inputs:
 *   post:
 *     summary: Creates a new eventTypeCustomInput
 *     parameters:
 *        - in: query
 *          name: apiKey
 *          required: true
 *          schema:
 *            type: string
 *          description: Your API key
 *     requestBody:
 *        description: Create a new custom input for an event type
 *        required: true
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              required:
 *                - eventTypeId
 *                - label
 *                - type
 *                - required
 *                - placeholder
 *              properties:
 *                eventTypeId:
 *                  type: integer
 *                  description: 'ID of the event type to which the custom input is being added'
 *                label:
 *                  type: string
 *                  description: 'Label of the custom input'
 *                type:
 *                  type: string
 *                  description: 'Type of the custom input. The value is ENUM; one of [TEXT, TEXTLONG, NUMBER, BOOL, RADIO, PHONE]'
 *                options:
 *                  type: object
 *                  properties:
 *                    label:
 *                      type: string
 *                    type:
 *                      type: string
 *                  description: 'Options for the custom input'
 *                required:
 *                  type: boolean
 *                  description: 'If the custom input is required before booking'
 *                placeholder:
 *                  type: string
 *                  description: 'Placeholder text for the custom input'
 *
 *            examples:
 *              custom-inputs:
 *                summary: An example of custom-inputs
 *                value:
 *                  eventTypeID: 1
 *                  label: "Phone Number"
 *                  type: "PHONE"
 *                  required: true
 *                  placeholder: "100 101 1234"
 *
 *     tags:
 *     - custom-inputs
 *     responses:
 *       201:
 *         description: OK, eventTypeCustomInput created
 *       400:
 *        description: Bad request. EventTypeCustomInput body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { eventTypeId, ...body } = schemaEventTypeCustomInputBodyParams.parse(req.body);

  if (!isAdmin) {
    /* We check that the user has access to the event type he's trying to add a custom input to. */
    const eventType = await prisma.eventType.findFirst({
      where: { id: eventTypeId, userId },
    });

    if (!eventType) throw new HttpError({ statusCode: 403, message: "Forbidden" });
  }

  const data = await prisma.eventTypeCustomInput.create({
    data: { ...body, eventType: { connect: { id: eventTypeId } } },
  });

  return {
    event_type_custom_input: schemaEventTypeCustomInputPublic.parse(data),
    message: "EventTypeCustomInput created successfully",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /custom-inputs/{id}:
 *   delete:
 *     summary: Remove an existing eventTypeCustomInput
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the eventTypeCustomInput to delete
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     tags:
 *     - custom-inputs
 *     responses:
 *       201:
 *         description: OK, eventTypeCustomInput removed successfully
 *       400:
 *        description: Bad request. EventType id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  await prisma.eventTypeCustomInput.delete({ where: { id } });
  return { message: `CustomInputEventType with id: ${id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  // Admins can just skip this check
  if (isAdmin) return;
  // Check if the current user can access the event type of this input
  const eventTypeCustomInput = await prisma.eventTypeCustomInput.findFirst({
    where: { id, eventType: { userId } },
  });
  if (!eventTypeCustomInput) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import {
  schemaEventTypeCustomInputEditBodyParams,
  schemaEventTypeCustomInputPublic,
} from "~/lib/validations/event-type-custom-input";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /custom-inputs/{id}:
 *   patch:
 *     summary: Edit an existing eventTypeCustomInput
 *     requestBody:
 *        description: Edit an existing eventTypeCustomInput for an event type
 *        required: true
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              properties:
 *                eventTypeId:
 *                  type: integer
 *                  description: 'ID of the event type to which the custom input is being added'
 *                label:
 *                  type: string
 *                  description: 'Label of the custom input'
 *                type:
 *                  type: string
 *                  description: 'Type of the custom input. The value is ENUM; one of [TEXT, TEXTLONG, NUMBER, BOOL, RADIO, PHONE]'
 *                options:
 *                  type: object
 *                  properties:
 *                    label:
 *                      type: string
 *                    type:
 *                      type: string
 *                  description: 'Options for the custom input'
 *                required:
 *                  type: boolean
 *                  description: 'If the custom input is required before booking'
 *                placeholder:
 *                  type: string
 *                  description: 'Placeholder text for the custom input'
 *
 *            examples:
 *              custom-inputs:
 *                summary: Example of patching an existing Custom Input
 *                value:
 *                  required: true
 *
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the eventTypeCustomInput to edit
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *
 *     tags:
 *     - custom-inputs
 *     responses:
 *       201:
 *         description: OK, eventTypeCustomInput edited successfully
 *       400:
 *        description: Bad request. EventType body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = schemaEventTypeCustomInputEditBodyParams.parse(req.body);
  const result = await prisma.eventTypeCustomInput.update({ where: { id }, data });
  return { event_type_custom_input: schemaEventTypeCustomInputPublic.parse(result) };
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaEventTypeCustomInputPublic } from "~/lib/validations/event-type-custom-input";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /custom-inputs/{id}:
 *   get:
 *     summary: Find a eventTypeCustomInput
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the eventTypeCustomInput to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *     - custom-inputs
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: EventType was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = await prisma.eventTypeCustomInput.findUniqueOrThrow({ where: { id } });
  return { event_type_custom_input: schemaEventTypeCustomInputPublic.parse(data) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaEventTypeCustomInputPublic } from "~/lib/validations/event-type-custom-input";

/**
 * @swagger
 * /custom-inputs:
 *   get:
 *     summary: Find all eventTypeCustomInputs
 *     parameters:
 *        - in: query
 *          name: apiKey
 *          required: true
 *          schema:
 *            type: string
 *          description: Your API key
 *     tags:
 *     - custom-inputs
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No eventTypeCustomInputs were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const args: Prisma.EventTypeCustomInputFindManyArgs = isAdmin ? {} : { where: { eventType: { userId } } };
  const data = await prisma.eventTypeCustomInput.findMany(args);
  return { event_type_custom_inputs: data.map((v) => schemaEventTypeCustomInputPublic.parse(v)) };
}

export default defaultResponder(getHandler);
import { withSwagger } from "next-swagger-doc";

import pjson from "~/package.json";

const swaggerHandler = withSwagger({
  definition: {
    openapi: "3.0.3",
    servers: [
      { url: "http://localhost:3002/v1" },
      { url: "https://api.cal.dev/v1" },
      { url: "https://api.cal.com/v1" },
    ],
    externalDocs: {
      url: "https://docs.cal.com",
      description: "Find more info at our main docs: https://docs.cal.com/",
    },
    info: {
      title: `${pjson.name}: ${pjson.description}`,
      version: pjson.version,
    },
    components: {
      securitySchemes: { ApiKeyAuth: { type: "apiKey", in: "query", name: "apiKey" } },
      schemas: {
        ArrayOfBookings: {
          type: "array",
          items: {
            $ref: "#/components/schemas/Booking",
          },
        },
        Booking: {
          properties: {
            id: {
              type: "number",
            },
            description: {
              type: "string",
            },
            eventTypeId: {
              type: "number",
            },
            uid: {
              type: "string",
              format: "uuid",
            },
            title: {
              type: "string",
            },
            startTime: {
              type: "string",
              format: "date-time",
            },
            endTime: {
              type: "string",
              format: "date-time",
            },
            timeZone: {
              type: "string",
              example: "Europe/London",
            },
            attendees: {
              type: "array",
              items: {
                properties: {
                  email: {
                    type: "string",
                    example: "example@cal.com",
                  },
                  name: {
                    type: "string",
                  },
                  timeZone: {
                    type: "string",
                    example: "Europe/London",
                  },
                  locale: {
                    type: "string",
                    example: "en",
                  },
                },
              },
            },
            user: {
              properties: {
                email: {
                  type: "string",
                  example: "example@cal.com",
                },
                name: {
                  type: "string",
                },
                timeZone: {
                  type: "string",
                  example: "Europe/London",
                },
                locale: {
                  type: "string",
                  example: "en",
                },
              },
            },
            payment: {
              type: Array,
              items: {
                properties: {
                  id: {
                    type: "number",
                    example: 1,
                  },
                  success: {
                    type: "boolean",
                    example: true,
                  },
                  paymentOption: {
                    type: "string",
                    example: "ON_BOOKING",
                  },
                },
              },
            },
          },
        },
      },
    },
    security: [{ ApiKeyAuth: [] }],
    tags: [
      { name: "users" },
      { name: "event-types" },
      { name: "bookings" },
      { name: "attendees" },
      { name: "payments" },
      { name: "schedules" },
      { name: "teams" },
      { name: "memberships" },
      {
        name: "availabilities",
        description: "Allows modifying unique availabilities tied to a schedule.",
      },
      { name: "custom-inputs" },
      { name: "event-references" },
      { name: "booking-references" },
      { name: "destination-calendars" },
      { name: "selected-calendars" },
    ],
  },
  apiFolder: "pages/api",
});

export default swaggerHandler();
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaUserReadPublic } from "~/lib/validations/user";

async function handler({ userId, prisma }: NextApiRequest) {
  const data = await prisma.user.findUniqueOrThrow({ where: { id: userId } });
  return { user: schemaUserReadPublic.parse(data) };
}

export default defaultResponder(handler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { membershipCreateBodySchema, schemaMembershipPublic } from "~/lib/validations/membership";

/**
 * @swagger
 * /memberships:
 *   post:
 *     summary: Creates a new membership
 *     tags:
 *     - memberships
 *     responses:
 *       201:
 *         description: OK, membership created
 *       400:
 *        description: Bad request. Membership body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { prisma } = req;
  const data = membershipCreateBodySchema.parse(req.body);
  const args: Prisma.MembershipCreateArgs = { data };

  await checkPermissions(req);

  const result = await prisma.membership.create(args);

  return {
    membership: schemaMembershipPublic.parse(result),
    message: "Membership created successfully",
  };
}

async function checkPermissions(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  if (isAdmin) return;
  const body = membershipCreateBodySchema.parse(req.body);
  // To prevent auto-accepted invites, limit it to ADMIN users
  if (!isAdmin && "accepted" in body)
    throw new HttpError({ statusCode: 403, message: "ADMIN needed for `accepted`" });
  // Only team OWNERS and ADMINS can add other members
  const membership = await prisma.membership.findFirst({
    where: { userId, teamId: body.teamId, role: { in: ["ADMIN", "OWNER"] } },
  });
  if (!membership) throw new HttpError({ statusCode: 403, message: "You can't add members to this team" });
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { membershipIdSchema } from "~/lib/validations/membership";

/**
 * @swagger
 * /memberships/{userId}_{teamId}:
 *   delete:
 *     summary: Remove an existing membership
 *     parameters:
 *      - in: path
 *        name: userId
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric userId of the membership to get
 *      - in: path
 *        name: teamId
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric teamId of the membership to get
 *     tags:
 *     - memberships
 *     responses:
 *       201:
 *         description: OK, membership removed successfuly
 *       400:
 *        description: Bad request. Membership id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const userId_teamId = membershipIdSchema.parse(query);
  await checkPermissions(req);
  await prisma.membership.delete({ where: { userId_teamId } });
  return { message: `Membership with id: ${query.id} deleted successfully` };
}

async function checkPermissions(req: NextApiRequest) {
  const { prisma, isAdmin, userId, query } = req;
  const userId_teamId = membershipIdSchema.parse(query);
  // Admin User can do anything including deletion of Admin Team Member in any team
  if (isAdmin) {
    return;
  }

  // Owner can delete Admin and Member
  // Admin Team Member can delete Member
  // Member can't delete anyone
  const PRIVILEGE_ORDER = ["OWNER", "ADMIN", "MEMBER"];

  const memberShipToBeDeleted = await prisma.membership.findUnique({
    where: { userId_teamId },
  });

  if (!memberShipToBeDeleted) {
    throw new HttpError({ statusCode: 404, message: "Membership not found" });
  }

  // If a user is deleting their own membership, then they can do it
  if (userId === memberShipToBeDeleted.userId) {
    return;
  }

  const currentUserMembership = await prisma.membership.findUnique({
    where: {
      userId_teamId: {
        userId,
        teamId: memberShipToBeDeleted.teamId,
      },
    },
  });

  if (!currentUserMembership) {
    // Current User isn't a member of the team
    throw new HttpError({ statusCode: 403, message: "You are not a member of the team" });
  }

  if (
    PRIVILEGE_ORDER.indexOf(memberShipToBeDeleted.role) === -1 ||
    PRIVILEGE_ORDER.indexOf(currentUserMembership.role) === -1
  ) {
    throw new HttpError({ statusCode: 400, message: "Invalid role" });
  }

  // If Role that is being deleted comes before the current User's Role, or it's the same ROLE, throw error
  if (
    PRIVILEGE_ORDER.indexOf(memberShipToBeDeleted.role) <= PRIVILEGE_ORDER.indexOf(currentUserMembership.role)
  ) {
    throw new HttpError({
      statusCode: 403,
      message: "You don't have the appropriate role to delete this membership",
    });
  }
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { membershipIdSchema } from "~/lib/validations/membership";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { teamId } = membershipIdSchema.parse(req.query);
  // Admins can just skip this check
  if (isAdmin) return;
  // Only team members can modify a membership
  const membership = await prisma.membership.findFirst({ where: { userId, teamId } });
  if (!membership) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import {
  membershipEditBodySchema,
  membershipIdSchema,
  schemaMembershipPublic,
} from "~/lib/validations/membership";

/**
 * @swagger
 * /memberships/{userId}_{teamId}:
 *   patch:
 *     summary: Edit an existing membership
 *     parameters:
 *      - in: path
 *        name: userId
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric userId of the membership to get
 *      - in: path
 *        name: teamId
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric teamId of the membership to get
 *     tags:
 *     - memberships
 *     responses:
 *       201:
 *         description: OK, membership edited successfully
 *       400:
 *        description: Bad request. Membership body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const userId_teamId = membershipIdSchema.parse(query);
  const data = membershipEditBodySchema.parse(req.body);
  const args: Prisma.MembershipUpdateArgs = { where: { userId_teamId }, data };

  await checkPermissions(req);

  const result = await prisma.membership.update(args);
  return { membership: schemaMembershipPublic.parse(result) };
}

async function checkPermissions(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { userId: queryUserId, teamId } = membershipIdSchema.parse(req.query);
  const data = membershipEditBodySchema.parse(req.body);
  // Admins can just skip this check
  if (isAdmin) return;
  // Only the invited user can accept the invite
  if ("accepted" in data && queryUserId !== userId)
    throw new HttpError({
      statusCode: 403,
      message: "Only the invited user can accept the invite",
    });
  // Only team OWNERS and ADMINS can modify `role`
  if ("role" in data) {
    const membership = await prisma.membership.findFirst({
      where: { userId, teamId, role: { in: ["ADMIN", "OWNER"] } },
    });

    if (!membership || (membership.role !== "OWNER" && req.body.role === "OWNER"))
      throw new HttpError({ statusCode: 403, message: "Forbidden" });
  }
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { membershipIdSchema, schemaMembershipPublic } from "~/lib/validations/membership";

/**
 * @swagger
 * /memberships/{userId}_{teamId}:
 *   get:
 *     summary: Find a membership by userID and teamID
 *     parameters:
 *      - in: path
 *        name: userId
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric userId of the membership to get
 *      - in: path
 *        name: teamId
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric teamId of the membership to get
 *     tags:
 *     - memberships
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Membership was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const userId_teamId = membershipIdSchema.parse(query);
  const args: Prisma.MembershipFindUniqueOrThrowArgs = { where: { userId_teamId } };
  // Just in case the user want to get more info about the team itself
  if (req.query.include === "team") args.include = { team: true };
  const data = await prisma.membership.findUniqueOrThrow(args);
  return { membership: schemaMembershipPublic.parse(data) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaMembershipPublic } from "~/lib/validations/membership";
import {
  schemaQuerySingleOrMultipleTeamIds,
  schemaQuerySingleOrMultipleUserIds,
} from "~/lib/validations/shared/queryUserId";

/**
 * @swagger
 * /memberships:
 *   get:
 *     summary: Find all memberships
 *     tags:
 *     - memberships
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No memberships were found
 */
async function getHandler(req: NextApiRequest) {
  const { prisma } = req;
  const args: Prisma.MembershipFindManyArgs = {
    where: {
      /** Admins can query multiple users */
      userId: { in: getUserIds(req) },
      /** Admins can query multiple teams as well */
      teamId: { in: getTeamIds(req) },
    },
  };
  // Just in case the user want to get more info about the team itself
  if (req.query.include === "team") args.include = { team: true };

  const data = await prisma.membership.findMany(args);
  return { memberships: data.map((v) => schemaMembershipPublic.parse(v)) };
}

/**
 * Returns requested users IDs only if admin, otherwise return only current user ID
 */
function getUserIds(req: NextApiRequest) {
  const { userId, isAdmin } = req;
  /** Only admins can query other users */
  if (!isAdmin && req.query.userId) throw new HttpError({ statusCode: 403, message: "ADMIN required" });
  if (isAdmin && req.query.userId) {
    const query = schemaQuerySingleOrMultipleUserIds.parse(req.query);

    const userIds = Array.isArray(query.userId) ? query.userId : [query.userId || userId];

    return userIds;
  }
  // Return all memberships for ADMIN, limit to current user to non-admins
  return isAdmin ? undefined : [userId];
}

/**
 * Returns requested teams IDs only if admin
 */
function getTeamIds(req: NextApiRequest) {
  const { isAdmin } = req;
  /** Only admins can query other teams */
  if (!isAdmin && req.query.teamId) throw new HttpError({ statusCode: 403, message: "ADMIN required" });
  if (isAdmin && req.query.teamId) {
    const query = schemaQuerySingleOrMultipleTeamIds.parse(req.query);

    const teamIds = Array.isArray(query.teamId) ? query.teamId : [query.teamId];

    return teamIds;
  }
  return undefined;
}

export default defaultResponder(getHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaUserCreateBodyParams } from "~/lib/validations/user";

/**
 * @swagger
 * /users:
 *   post:
 *     operationId: addUser
 *     summary: Creates a new user
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     requestBody:
 *       description: Create a new user
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *              - email
 *              - username
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 description: Email that belongs to the user being edited
 *               username:
 *                 type: string
 *                 description: Username for the user being created
 *               brandColor:
 *                 description: The new user's brand color
 *                 type: string
 *               darkBrandColor:
 *                 description: The new user's brand color for dark mode
 *                 type: string
 *               hideBranding:
 *                 description: Remove branding from the user's calendar page
 *                 type: boolean
 *               weekStart:
 *                 description: Start of the week. Acceptable values are one of [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]
 *                 type: string
 *               timeZone:
 *                 description: The new user's time zone. Eg- 'EUROPE/PARIS'
 *                 type: string
 *               theme:
 *                 description: Default theme for the new user. Acceptable values are one of [DARK, LIGHT]
 *                 type: string
 *               timeFormat:
 *                 description: The new user's time format. Acceptable values are one of [TWELVE, TWENTY_FOUR]
 *                 type: string
 *               locale:
 *                 description: The new user's locale. Acceptable values are one of [EN, FR, IT, RU, ES, DE, PT, RO, NL, PT_BR, ES_419, KO, JA, PL, AR, IW, ZH_CH, ZH_TW, CS, SR, SV, VI]
 *                 type: string
 *               avatar:
 *                 description: The user's avatar, in base64 format
 *                 type: string
 *           examples:
 *              user:
 *                summary: An example of USER
 *                value:
 *                  email: 'email@example.com'
 *                  username: 'johndoe'
 *                  weekStart: 'MONDAY'
 *                  brandColor: '#555555'
 *                  darkBrandColor: '#111111'
 *                  timeZone: 'EUROPE/PARIS'
 *                  theme: 'LIGHT'
 *                  timeFormat: 'TWELVE'
 *                  locale: 'FR'
 *     tags:
 *     - users
 *     responses:
 *       201:
 *         description: OK, user created
 *       400:
 *        description: Bad request. user body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { prisma, isAdmin } = req;
  // If user is not ADMIN, return unauthorized.
  if (!isAdmin) throw new HttpError({ statusCode: 401, message: "You are not authorized" });
  const data = await schemaUserCreateBodyParams.parseAsync(req.body);
  const user = await prisma.user.create({ data });
  req.statusCode = 201;
  return { user };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";
import { schemaQuerySingleOrMultipleUserEmails } from "~/lib/validations/shared/queryUserEmail";
import { schemaUsersReadPublic } from "~/lib/validations/user";

/**
 * @swagger
 * /users:
 *   get:
 *     operationId: listUsers
 *     summary: Find all users.
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *       - in: query
 *         name: email
 *         required: false
 *         schema:
 *          type: array
 *          items:
 *            type: string
 *            format: email
 *         style: form
 *         explode: true
 *         description: The email address or an array of email addresses to filter by
 *     tags:
 *     - users
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No users were found
 */
export async function getHandler(req: NextApiRequest) {
  const {
    userId,
    prisma,
    isAdmin,
    pagination: { take, skip },
  } = req;
  const where: Prisma.UserWhereInput = {};
  // If user is not ADMIN, return only his data.
  if (!isAdmin) where.id = userId;

  if (req.query.email) {
    const validationResult = schemaQuerySingleOrMultipleUserEmails.parse(req.query);
    where.email = {
      in: Array.isArray(validationResult.email) ? validationResult.email : [validationResult.email],
    };
  }

  const [total, data] = await prisma.$transaction([
    prisma.user.count({ where }),
    prisma.user.findMany({ where, take, skip }),
  ]);
  const users = schemaUsersReadPublic.parse(data);
  return { users, total };
}

export default withMiddleware("pagination")(defaultResponder(getHandler));
import type { NextApiRequest } from "next";

import { deleteUser } from "@calcom/features/users/lib/userDeletionService";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryUserId } from "~/lib/validations/shared/queryUserId";

/**
 * @swagger
 * /users/{userId}:
 *   delete:
 *     summary: Remove an existing user
 *     operationId: removeUserById
 *     parameters:
 *      - in: path
 *        name: userId
 *        example: 1
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the user to delete
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API key
 *     tags:
 *     - users
 *     responses:
 *       201:
 *         description: OK, user removed successfuly
 *       400:
 *        description: Bad request. User id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, isAdmin } = req;
  const query = schemaQueryUserId.parse(req.query);
  // Here we only check for ownership of the user if the user is not admin, otherwise we let ADMIN's edit any user
  if (!isAdmin && query.userId !== req.userId) throw new HttpError({ statusCode: 403, message: "Forbidden" });

  const user = await prisma.user.findUnique({
    where: { id: query.userId },
    select: {
      id: true,
      email: true,
      metadata: true,
    },
  });
  if (!user) throw new HttpError({ statusCode: 404, message: "User not found" });

  await deleteUser(user);

  return { message: `User with id: ${user.id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryUserId } from "~/lib/validations/shared/queryUserId";
import { schemaUserEditBodyParams, schemaUserReadPublic } from "~/lib/validations/user";

/**
 * @swagger
 * /users/{userId}:
 *   patch:
 *     summary: Edit an existing user
 *     operationId: editUserById
 *     parameters:
 *       - in: path
 *         name: userId
 *         example: 4
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the user to edit
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     requestBody:
 *       description: Edit an existing attendee related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 format: email
 *                 description: Email that belongs to the user being edited
 *               username:
 *                 type: string
 *                 description: Username for the user being edited
 *               brandColor:
 *                 description: The user's brand color
 *                 type: string
 *               darkBrandColor:
 *                 description: The user's brand color for dark mode
 *                 type: string
 *               weekStart:
 *                 description: Start of the week. Acceptable values are one of [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY]
 *                 type: string
 *               timeZone:
 *                 description: The user's time zone
 *                 type: string
 *               hideBranding:
 *                 description: Remove branding from the user's calendar page
 *                 type: boolean
 *               theme:
 *                 description: Default theme for the user. Acceptable values are one of [DARK, LIGHT]
 *                 type: string
 *               timeFormat:
 *                 description: The user's time format. Acceptable values are one of [TWELVE, TWENTY_FOUR]
 *                 type: string
 *               locale:
 *                 description: The user's locale. Acceptable values are one of [EN, FR, IT, RU, ES, DE, PT, RO, NL, PT_BR, ES_419, KO, JA, PL, AR, IW, ZH_CH, ZH_TW, CS, SR, SV, VI]
 *                 type: string
 *               avatar:
 *                 description: The user's avatar, in base64 format
 *                 type: string
 *           examples:
 *              user:
 *                summary: An example of USER
 *                value:
 *                  email: email@example.com
 *                  username: johndoe
 *                  weekStart: MONDAY
 *                  brandColor: #555555
 *                  darkBrandColor: #111111
 *                  timeZone: EUROPE/PARIS
 *                  theme: LIGHT
 *                  timeFormat: TWELVE
 *                  locale: FR
 *     tags:
 *       - users
 *     responses:
 *       200:
 *         description: OK, user edited successfully
 *       400:
 *         description: Bad request. User body is invalid.
 *       401:
 *         description: Authorization information is missing or invalid.
 *       403:
 *         description: Insufficient permissions to access resource.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, isAdmin } = req;
  const query = schemaQueryUserId.parse(req.query);
  // Here we only check for ownership of the user if the user is not admin, otherwise we let ADMIN's edit any user
  if (!isAdmin && query.userId !== req.userId) throw new HttpError({ statusCode: 403, message: "Forbidden" });

  const body = await schemaUserEditBodyParams.parseAsync(req.body);
  // disable role or branding changes unless admin.
  if (!isAdmin) {
    if (body.role) body.role = undefined;

    if (body.hideBranding) body.hideBranding = undefined;
  }

  const userSchedules = await prisma.schedule.findMany({
    where: { userId: query.userId },
  });
  const userSchedulesIds = userSchedules.map((schedule) => schedule.id);
  // @note: here we make sure user can only make as default his own scheudles
  if (body.defaultScheduleId && !userSchedulesIds.includes(Number(body.defaultScheduleId))) {
    throw new HttpError({
      statusCode: 400,
      message: "Bad request: Invalid default schedule id",
    });
  }
  const data = await prisma.user.update({
    where: { id: query.userId },
    data: body,
  });
  const user = schemaUserReadPublic.parse(data);
  return { user };
}

export default defaultResponder(patchHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("~/pages/api/availability/_get"),
  })
);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    PATCH: import("./_patch"),
    DELETE: import("./_delete"),
  })
);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryUserId } from "~/lib/validations/shared/queryUserId";
import { schemaUserReadPublic } from "~/lib/validations/user";

/**
 * @swagger
 * /users/{userId}:
 *   get:
 *     summary: Find a user, returns your user if regular user.
 *     operationId: getUserById
 *     parameters:
 *       - in: path
 *         name: userId
 *         example: 4
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the user to get
 *       - in: query
 *         name: apiKey
 *         schema:
 *           type: string
 *         required: true
 *         description: Your API key
 *     tags:
 *     - users
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: User was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, isAdmin } = req;

  const query = schemaQueryUserId.parse(req.query);
  // Here we only check for ownership of the user if the user is not admin, otherwise we let ADMIN's edit any user
  if (!isAdmin && query.userId !== req.userId) throw new HttpError({ statusCode: 403, message: "Forbidden" });
  const data = await prisma.user.findUnique({ where: { id: query.userId } });
  const user = schemaUserReadPublic.parse(data);
  return { user };
}

export default defaultResponder(getHandler);
import type { NextApiRequest } from "next";

import { getStripeCustomerIdFromUserId } from "@calcom/app-store/stripepayment/lib/customer";
import stripe from "@calcom/app-store/stripepayment/lib/server";
import { IS_TEAM_BILLING_ENABLED, WEBAPP_URL } from "@calcom/lib/constants";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { MembershipRole } from "@calcom/prisma/enums";

import { schemaMembershipPublic } from "~/lib/validations/membership";
import { schemaTeamCreateBodyParams, schemaTeamReadPublic } from "~/lib/validations/team";

/**
 * @swagger
 * /teams:
 *   post:
 *     operationId: addTeam
 *     summary: Creates a new team
 *     parameters:
 *        - in: query
 *          name: apiKey
 *          required: true
 *          schema:
 *            type: string
 *          description: Your API key
 *     requestBody:
 *        description: Create a new custom input for an event type
 *        required: true
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              required:
 *                - name
 *                - slug
 *                - hideBookATeamMember
 *                - brandColor
 *                - darkBrandColor
 *                - timeZone
 *                - weekStart
 *                - isPrivate
 *              properties:
 *                name:
 *                  type: string
 *                  description: Name of the team
 *                slug:
 *                  type: string
 *                  description: A unique slug that works as path for the team public page
 *                hideBookATeamMember:
 *                  type: boolean
 *                  description: Flag to hide or show the book a team member option
 *                brandColor:
 *                  type: string
 *                  description: Primary brand color for the team
 *                darkBrandColor:
 *                  type: string
 *                  description: Dark variant of the primary brand color for the team
 *                timeZone:
 *                  type: string
 *                  description: Time zone of the team
 *                weekStart:
 *                  type: string
 *                  description: Starting day of the week for the team
 *                isPrivate:
 *                  type: boolean
 *                  description: Flag indicating if the team is private
 *                ownerId:
 *                  type: number
 *                  description: ID of the team owner - only admins can set this.
 *     tags:
 *     - teams
 *     responses:
 *       201:
 *         description: OK, team created
 *       400:
 *        description: Bad request. Team body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { prisma, body, userId, isAdmin } = req;
  const { ownerId, ...data } = schemaTeamCreateBodyParams.parse(body);

  await checkPermissions(req);

  const effectiveUserId = isAdmin && ownerId ? ownerId : userId;

  if (data.slug) {
    const alreadyExist = await prisma.team.findFirst({
      where: {
        slug: {
          mode: "insensitive",
          equals: data.slug,
        },
      },
    });

    if (alreadyExist) throw new HttpError({ statusCode: 409, message: "Team slug already exists" });
  }

  // Check if parentId is related to this user
  if (data.parentId) {
    const parentTeam = await prisma.team.findFirst({
      where: { id: data.parentId, members: { some: { userId, role: { in: ["OWNER", "ADMIN"] } } } },
    });

    if (!parentTeam)
      throw new HttpError({
        statusCode: 401,
        message: "Unauthorized: Invalid parent id. You can only use parent id of your own teams.",
      });
  }

  // TODO: Perhaps there is a better fix for this?
  const cloneData: typeof data & {
    metadata: NonNullable<typeof data.metadata> | undefined;
  } = {
    ...data,
    metadata: data.metadata === null ? {} : data.metadata || undefined,
  };

  if (!IS_TEAM_BILLING_ENABLED) {
    const team = await prisma.team.create({
      data: {
        ...cloneData,
        members: {
          create: { userId: effectiveUserId, role: MembershipRole.OWNER, accepted: true },
        },
      },
      include: { members: true },
    });

    req.statusCode = 201;

    return {
      team: schemaTeamReadPublic.parse(team),
      owner: schemaMembershipPublic.parse(team.members[0]),
      message: `Team created successfully. We also made user with ID=${ownerId} the owner of this team.`,
    };
  }

  const pendingPaymentTeam = await prisma.team.create({
    data: {
      ...cloneData,
      pendingPayment: true,
    },
  });

  const checkoutSession = await generateTeamCheckoutSession({
    pendingPaymentTeamId: pendingPaymentTeam.id,
    ownerId: effectiveUserId,
  });

  return {
    message:
      "Your team will be created once we receive your payment. Please complete the payment using the payment link.",
    paymentLink: checkoutSession.url,
    pendingTeam: {
      ...schemaTeamReadPublic.parse(pendingPaymentTeam),
    },
  };
}

async function checkPermissions(req: NextApiRequest) {
  const { isAdmin } = req;
  const body = schemaTeamCreateBodyParams.parse(req.body);

  /* Non-admin users can only create teams for themselves */
  if (!isAdmin && body.ownerId)
    throw new HttpError({
      statusCode: 401,
      message: "ADMIN required for `ownerId`",
    });
}

const generateTeamCheckoutSession = async ({
  pendingPaymentTeamId,
  ownerId,
}: {
  pendingPaymentTeamId: number;
  ownerId: number;
}) => {
  const customer = await getStripeCustomerIdFromUserId(ownerId);
  const session = await stripe.checkout.sessions.create({
    customer,
    mode: "subscription",
    allow_promotion_codes: true,
    success_url: `${WEBAPP_URL}/api/teams/api/create?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: `${WEBAPP_URL}/settings/my-account/profile`,
    line_items: [
      {
        /** We only need to set the base price and we can upsell it directly on Stripe's checkout  */
        price: process.env.STRIPE_TEAM_MONTHLY_PRICE_ID,
        /**Initially it will be just the team owner */
        quantity: 1,
      },
    ],
    customer_update: {
      address: "auto",
    },
    automatic_tax: {
      enabled: true,
    },
    metadata: {
      pendingPaymentTeamId,
      ownerId,
    },
  });

  if (!session.url)
    throw new HttpError({
      statusCode: 500,
      message: "Failed generating a checkout session URL.",
    });

  return session;
};

export default defaultResponder(postHandler);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryTeamId } from "~/lib/validations/shared/queryTeamId";

import { checkPermissions } from "./_auth-middleware";

/**
 * @swagger
 * /teams/{teamId}:
 *   delete:
 *     operationId: removeTeamById
 *     summary: Remove an existing team
 *     parameters:
 *      - in: path
 *        name: teamId
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the team to delete
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     tags:
 *     - teams
 *     responses:
 *       201:
 *         description: OK, team removed successfully
 *       400:
 *        description: Bad request. Team id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { teamId } = schemaQueryTeamId.parse(query);
  await checkPermissions(req);
  await prisma.team.delete({ where: { id: teamId } });
  return { message: `Team with id: ${teamId} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultHandler, defaultResponder } from "@calcom/lib/server";
import { MembershipRole, UserPermissionRole } from "@calcom/prisma/enums";
import { createContext } from "@calcom/trpc/server/createContext";
import { viewerTeamsRouter } from "@calcom/trpc/server/routers/viewer/teams/_router";

import { TRPCError } from "@trpc/server";
import { getHTTPStatusCodeFromError } from "@trpc/server/http";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware, { checkPermissions } from "./_auth-middleware";

const patchHandler = async (req: NextApiRequest, res: NextApiResponse) => {
  await checkPermissions(req, { in: [MembershipRole.OWNER, MembershipRole.ADMIN] });
  async function sessionGetter() {
    return {
      user: {
        id: req.userId,
        username: "" /* Not used in this context */,
        role: req.isAdmin ? UserPermissionRole.ADMIN : UserPermissionRole.USER,
      },
      hasValidLicense: true /* To comply with TS signature */,
      expires: "" /* Not used in this context */,
    };
  }
  /** @see https://trpc.io/docs/server-side-calls */
  const ctx = await createContext({ req, res }, sessionGetter);
  try {
    const caller = viewerTeamsRouter.createCaller(ctx);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return await caller.publish(req.query as any /* Let tRPC handle this */);
  } catch (cause) {
    if (cause instanceof TRPCError) {
      const statusCode = getHTTPStatusCodeFromError(cause);
      throw new HttpError({ statusCode, message: cause.message });
    }
    throw cause;
  }
};

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      PATCH: Promise.resolve({ default: defaultResponder(patchHandler) }),
    })(req, res);
  })
);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { MembershipRole } from "@calcom/prisma/enums";

import { schemaQueryTeamId } from "~/lib/validations/shared/queryTeamId";

async function authMiddleware(req: NextApiRequest) {
  const { userId, prisma, isAdmin } = req;
  const { teamId } = schemaQueryTeamId.parse(req.query);
  /** Admins can skip the ownership verification */
  if (isAdmin) return;
  /** Non-members will see a 404 error which may or not be the desired behavior. */
  await prisma.team.findFirstOrThrow({
    where: { id: teamId, members: { some: { userId } } },
  });
}

export async function checkPermissions(
  req: NextApiRequest,
  role: Prisma.MembershipWhereInput["role"] = MembershipRole.OWNER
) {
  const { userId, prisma, isAdmin } = req;
  const { teamId } = schemaQueryTeamId.parse({
    teamId: req.query.teamId,
    version: req.query.version,
    apiKey: req.query.apiKey,
  });
  return canUserAccessTeamWithRole(prisma, userId, isAdmin, teamId, role);
}

export async function canUserAccessTeamWithRole(
  prisma: NextApiRequest["prisma"],
  userId: number,
  isAdmin: boolean,
  teamId: number,
  role: Prisma.MembershipWhereInput["role"] = MembershipRole.OWNER
) {
  const args: Prisma.TeamFindFirstArgs = { where: { id: teamId } };
  /** If not ADMIN then we check if the actual user belongs to team and matches the required role */
  if (!isAdmin) args.where = { ...args.where, members: { some: { userId, role } } };
  const team = await prisma.team.findFirst(args);
  if (!team) throw new HttpError({ statusCode: 401, message: `Unauthorized: ${role.toString()} required` });
  return team;
}

export default authMiddleware;
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
  })
);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";
import { z } from "zod";

import { defaultResponder } from "@calcom/lib/server";

import { schemaEventTypeReadPublic } from "~/lib/validations/event-type";

const querySchema = z.object({
  teamId: z.coerce.number(),
});

/**
 * @swagger
 * /teams/{teamId}/event-types:
 *   get:
 *     summary: Find all event types that belong to teamId
 *     operationId: listEventTypesByTeamId
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: teamId
 *        schema:
 *          type: number
 *        required: true
 *     tags:
 *     - event-types
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/event-types
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *         description: Authorization information is missing or invalid.
 *       404:
 *         description: No event types were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;

  const { teamId } = querySchema.parse(req.query);

  const args: Prisma.EventTypeFindManyArgs = {
    where: {
      team: isAdmin
        ? {
            id: teamId,
          }
        : {
            id: teamId,
            members: { some: { userId } },
          },
    },
    include: {
      customInputs: true,
      team: { select: { slug: true } },
      users: true,
      hosts: { select: { userId: true, isFixed: true } },
      owner: { select: { username: true, id: true } },
      children: { select: { id: true, userId: true } },
    },
  };

  const data = await prisma.eventType.findMany(args);
  return { event_types: data.map((eventType) => schemaEventTypeReadPublic.parse(eventType)) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { purchaseTeamSubscription } from "@calcom/features/ee/teams/lib/payments";
import { IS_TEAM_BILLING_ENABLED } from "@calcom/lib/constants";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { TRPCError } from "@trpc/server";

import { schemaQueryTeamId } from "~/lib/validations/shared/queryTeamId";
import { schemaTeamReadPublic, schemaTeamUpdateBodyParams } from "~/lib/validations/team";

/**
 * @swagger
 * /teams/{teamId}:
 *   patch:
 *     operationId: editTeamById
 *     summary: Edit an existing team
 *     parameters:
 *      - in: path
 *        name: teamId
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the team to edit
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     requestBody:
 *        description: Create a new custom input for an event type
 *        required: true
 *        content:
 *          application/json:
 *            schema:
 *              type: object
 *              properties:
 *                name:
 *                  type: string
 *                  description: Name of the team
 *                slug:
 *                  type: string
 *                  description: A unique slug that works as path for the team public page
 *     tags:
 *     - teams
 *     responses:
 *       201:
 *         description: OK, team edited successfully
 *       400:
 *        description: Bad request. Team body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, body, userId } = req;
  const data = schemaTeamUpdateBodyParams.parse(body);
  const { teamId } = schemaQueryTeamId.parse(req.query);

  /** Only OWNERS and ADMINS can edit teams */
  const _team = await prisma.team.findFirst({
    include: { members: true },
    where: { id: teamId, members: { some: { userId, role: { in: ["OWNER", "ADMIN"] } } } },
  });
  if (!_team) throw new HttpError({ statusCode: 401, message: "Unauthorized: OWNER or ADMIN required" });

  const slugAlreadyExists = await prisma.team.findFirst({
    where: {
      slug: {
        mode: "insensitive",
        equals: data.slug,
      },
    },
  });

  if (slugAlreadyExists && data.slug !== _team.slug)
    throw new HttpError({ statusCode: 409, message: "Team slug already exists" });

  // Check if parentId is related to this user
  if (data.parentId && data.parentId === teamId) {
    throw new HttpError({
      statusCode: 400,
      message: "Bad request: Parent id cannot be the same as the team id.",
    });
  }
  if (data.parentId) {
    const parentTeam = await prisma.team.findFirst({
      where: { id: data.parentId, members: { some: { userId, role: { in: ["OWNER", "ADMIN"] } } } },
    });

    if (!parentTeam)
      throw new HttpError({
        statusCode: 401,
        message: "Unauthorized: Invalid parent id. You can only use parent id of your own teams.",
      });
  }

  let paymentUrl;
  if (_team.slug === null && data.slug) {
    data.metadata = {
      ...(_team.metadata as Prisma.JsonObject),
      requestedSlug: data.slug,
    };
    delete data.slug;

    if (IS_TEAM_BILLING_ENABLED) {
      const checkoutSession = await purchaseTeamSubscription({
        teamId: _team.id,
        seats: _team.members.length,
        userId,
      });
      if (!checkoutSession.url)
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed retrieving a checkout session URL.",
        });
      paymentUrl = checkoutSession.url;
    }
  }

  // TODO: Perhaps there is a better fix for this?
  const cloneData: typeof data & {
    metadata: NonNullable<typeof data.metadata> | undefined;
  } = {
    ...data,
    metadata: data.metadata === null ? {} : data.metadata || undefined,
  };
  const team = await prisma.team.update({ where: { id: teamId }, data: cloneData });
  const result = {
    team: schemaTeamReadPublic.parse(team),
    paymentUrl,
  };
  if (!paymentUrl) {
    delete result.paymentUrl;
  }
  return result;
}

export default defaultResponder(patchHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("~/pages/api/availability/_get"),
  })
);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryTeamId } from "~/lib/validations/shared/queryTeamId";
import { schemaTeamReadPublic } from "~/lib/validations/team";

/**
 * @swagger
 * /teams/{teamId}:
 *   get:
 *     operationId: getTeamById
 *     summary: Find a team
 *     parameters:
 *       - in: path
 *         name: teamId
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the team to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *     - teams
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Team was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, isAdmin, userId } = req;
  const { teamId } = schemaQueryTeamId.parse(req.query);
  const where: Prisma.TeamWhereInput = { id: teamId };
  // Non-admins can only query the teams they're part of
  if (!isAdmin) where.members = { some: { userId } };
  const data = await prisma.team.findFirstOrThrow({ where });
  return { team: schemaTeamReadPublic.parse(data) };
}

export default defaultResponder(getHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaTeamsReadPublic } from "~/lib/validations/team";

/**
 * @swagger
 * /teams:
 *   get:
 *     operationId: listTeams
 *     summary: Find all teams
 *     parameters:
 *        - in: query
 *          name: apiKey
 *          required: true
 *          schema:
 *            type: string
 *          description: Your API key
 *     tags:
 *     - teams
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No teams were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, prisma, isAdmin } = req;
  const where: Prisma.TeamWhereInput = {};
  // If user is not ADMIN, return only his data.
  if (!isAdmin) where.members = { some: { userId } };
  const data = await prisma.team.findMany({ where });
  return { teams: schemaTeamsReadPublic.parse(data) };
}

export default defaultResponder(getHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
  })
);
import type { NextApiRequest } from "next";
import { z } from "zod";

import { getUserAvailability } from "@calcom/core/getUserAvailability";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { availabilityUserSelect } from "@calcom/prisma";
import { MembershipRole } from "@calcom/prisma/enums";
import { stringOrNumber } from "@calcom/prisma/zod-utils";

/**
 * @swagger
 * /teams/{teamId}/availability:
 *   get:
 *     summary: Find team availability
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         example: "1234abcd5678efgh"
 *         description: Your API key
 *       - in: path
 *         name: teamId
 *         required: true
 *         schema:
 *           type: integer
 *         example: 123
 *         description: ID of the team to fetch the availability for
 *       - in: query
 *         name: dateFrom
 *         schema:
 *           type: string
 *           format: date
 *         example: "2023-05-14 00:00:00"
 *         description: Start Date of the availability query
 *       - in: query
 *         name: dateTo
 *         schema:
 *           type: string
 *           format: date
 *         example: "2023-05-20 00:00:00"
 *         description: End Date of the availability query
 *       - in: query
 *         name: eventTypeId
 *         schema:
 *           type: integer
 *         example: 123
 *         description: Event Type ID of the event type to fetch the availability for
 *     operationId: team-availability
 *     tags:
 *     - availability
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               example:
 *                 busy:
 *                   - start: "2023-05-14T10:00:00.000Z"
 *                     end: "2023-05-14T11:00:00.000Z"
 *                     title: "Team meeting between Alice and Bob"
 *                   - start: "2023-05-15T14:00:00.000Z"
 *                     end: "2023-05-15T15:00:00.000Z"
 *                     title: "Project review between Carol and Dave"
 *                   - start: "2023-05-16T09:00:00.000Z"
 *                     end: "2023-05-16T10:00:00.000Z"
 *                   - start: "2023-05-17T13:00:00.000Z"
 *                     end: "2023-05-17T14:00:00.000Z"
 *                 timeZone: "America/New_York"
 *                 workingHours:
 *                   - days: [1, 2, 3, 4, 5]
 *                     startTime: 540
 *                     endTime: 1020
 *                     userId: 101
 *                 dateOverrides:
 *                   - date: "2023-05-15"
 *                     startTime: 600
 *                     endTime: 960
 *                     userId: 101
 *                 currentSeats: 4
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Team not found | Team has no members
 *
 * /availability:
 *   get:
 *     summary: Find user availability
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         example: "1234abcd5678efgh"
 *         description: Your API key
 *       - in: query
 *         name: userId
 *         schema:
 *           type: integer
 *         example: 101
 *         description: ID of the user to fetch the availability for
 *       - in: query
 *         name: username
 *         schema:
 *           type: string
 *         example: "alice"
 *         description: username of the user to fetch the availability for
 *       - in: query
 *         name: dateFrom
 *         schema:
 *           type: string
 *           format: date
 *         example: "2023-05-14 00:00:00"
 *         description: Start Date of the availability query
 *       - in: query
 *         name: dateTo
 *         schema:
 *           type: string
 *           format: date
 *         example: "2023-05-20 00:00:00"
 *         description: End Date of the availability query
 *       - in: query
 *         name: eventTypeId
 *         schema:
 *           type: integer
 *         example: 123
 *         description: Event Type ID of the event type to fetch the availability for
 *     operationId: user-availability
 *     tags:
 *     - availability
 *     responses:
 *       200:
 *         description: OK
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               example:
 *                 busy:
 *                   - start: "2023-05-14T10:00:00.000Z"
 *                     end: "2023-05-14T11:00:00.000Z"
 *                     title: "Team meeting between Alice and Bob"
 *                   - start: "2023-05-15T14:00:00.000Z"
 *                     end: "2023-05-15T15:00:00.000Z"
 *                     title: "Project review between Carol and Dave"
 *                   - start: "2023-05-16T09:00:00.000Z"
 *                     end: "2023-05-16T10:00:00.000Z"
 *                   - start: "2023-05-17T13:00:00.000Z"
 *                     end: "2023-05-17T14:00:00.000Z"
 *                 timeZone: "America/New_York"
 *                 workingHours:
 *                   - days: [1, 2, 3, 4, 5]
 *                     startTime: 540
 *                     endTime: 1020
 *                     userId: 101
 *                 dateOverrides:
 *                   - date: "2023-05-15"
 *                     startTime: 600
 *                     endTime: 960
 *                     userId: 101
 *                 currentSeats: 4
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: User not found
 */
interface MemberRoles {
  [userId: number | string]: MembershipRole;
}

const availabilitySchema = z
  .object({
    userId: stringOrNumber.optional(),
    teamId: stringOrNumber.optional(),
    username: z.string().optional(),
    dateFrom: z.string(),
    dateTo: z.string(),
    eventTypeId: stringOrNumber.optional(),
  })
  .refine(
    (data) => !!data.username || !!data.userId || !!data.teamId,
    "Either username or userId or teamId should be filled in."
  );

async function handler(req: NextApiRequest) {
  const { prisma, isAdmin, userId: reqUserId } = req;
  const { username, userId, eventTypeId, dateTo, dateFrom, teamId } = availabilitySchema.parse(req.query);
  if (!teamId)
    return getUserAvailability({
      username,
      dateFrom,
      dateTo,
      eventTypeId,
      userId,
    });
  const team = await prisma.team.findUnique({
    where: { id: teamId },
    select: { members: true },
  });
  if (!team) throw new HttpError({ statusCode: 404, message: "teamId not found" });
  if (!team.members) throw new HttpError({ statusCode: 404, message: "team has no members" });
  const allMemberIds = team.members.reduce((allMemberIds: number[], member) => {
    if (member.accepted) {
      allMemberIds.push(member.userId);
    }
    return allMemberIds;
  }, []);
  const members = await prisma.user.findMany({
    where: { id: { in: allMemberIds } },
    select: availabilityUserSelect,
  });
  const memberRoles: MemberRoles = team.members.reduce((acc: MemberRoles, membership) => {
    acc[membership.userId] = membership.role;

    return acc;
  }, {} as MemberRoles);
  // check if the user is a team Admin or Owner, if it is a team request, or a system Admin
  const isUserAdminOrOwner =
    memberRoles[reqUserId] == MembershipRole.ADMIN ||
    memberRoles[reqUserId] == MembershipRole.OWNER ||
    isAdmin;
  if (!isUserAdminOrOwner) throw new HttpError({ statusCode: 403, message: "Forbidden" });
  const availabilities = members.map(async (user) => {
    return {
      userId: user.id,
      availability: await getUserAvailability({
        userId: user.id,
        dateFrom,
        dateTo,
        eventTypeId,
      }),
    };
  });
  const settled = await Promise.all(availabilities);
  if (!settled)
    throw new HttpError({
      statusCode: 401,
      message: "We had an issue retrieving all your members availabilities",
    });
  return settled;
}

export default defaultResponder(handler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import {
  schemaBookingCreateBodyParams,
  schemaBookingReferenceReadPublic,
} from "~/lib/validations/booking-reference";

/**
 * @swagger
 * /booking-references:
 *   post:
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     operationId: addBookingReference
 *     summary: Creates a new  booking reference
 *     requestBody:
 *       description: Create a new booking reference related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *              - type
 *              - uid
 *             properties:
 *               type:
 *                 type: string
 *               uid:
 *                 type: string
 *               meetingId:
 *                 type: string
 *               meetingPassword:
 *                 type: string
 *               meetingUrl:
 *                 type: string
 *               bookingId:
 *                 type: boolean
 *               externalCalendarId:
 *                 type: string
 *               deleted:
 *                 type: boolean
 *               credentialId:
 *                 type: integer
 *     tags:
 *      - booking-references
 *     responses:
 *       201:
 *         description: OK,  booking reference created
 *       400:
 *        description: Bad request. BookingReference body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const body = schemaBookingCreateBodyParams.parse(req.body);
  const args: Prisma.BookingFindFirstOrThrowArgs = isAdmin
    ? /* If admin, we only check that the booking exists */
      { where: { id: body.bookingId } }
    : /* For non-admins we make sure the booking belongs to the user */
      { where: { id: body.bookingId, userId } };
  await prisma.booking.findFirstOrThrow(args);

  const data = await prisma.bookingReference.create({
    data: {
      ...body,
      bookingId: body.bookingId,
    },
  });

  return {
    booking_reference: schemaBookingReferenceReadPublic.parse(data),
    message: "Booking reference created successfully",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /booking-references/{id}:
 *   delete:
 *     operationId: removeBookingReferenceById
 *     summary: Remove an existing booking reference
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the booking reference to delete
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     tags:
 *      - booking-references
 *     responses:
 *       201:
 *         description: OK, bookingReference removed successfully
 *       400:
 *        description: Bad request. BookingReference id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  await prisma.bookingReference.delete({ where: { id } });
  return { message: `BookingReference with id: ${id} deleted` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdParseInt.parse(req.query);
  // Here we make sure to only return references of the user's own bookings if the user is not an admin.
  if (isAdmin) return;
  // Find all references where the user has bookings
  const bookingReference = await prisma.bookingReference.findFirst({
    where: { id, booking: { userId } },
  });
  if (!bookingReference) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import {
  schemaBookingEditBodyParams,
  schemaBookingReferenceReadPublic,
} from "~/lib/validations/booking-reference";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /booking-references/{id}:
 *   patch:
 *     operationId: editBookingReferenceById
 *     summary: Edit an existing booking reference
 *     requestBody:
 *       description: Edit an existing booking reference related to one of your bookings
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               type:
 *                 type: string
 *               meetingId:
 *                 type: string
 *               meetingPassword:
 *                 type: string
 *               externalCalendarId:
 *                 type: string
 *               deleted:
 *                 type: boolean
 *               credentialId:
 *                 type: integer
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: ID of the booking reference to edit
 *     tags:
 *      - booking-references
 *     responses:
 *       201:
 *         description: OK, BookingReference edited successfully
 *       400:
 *        description: Bad request. BookingReference body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, body, isAdmin, userId } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const data = schemaBookingEditBodyParams.parse(body);
  /* If user tries to update bookingId, we run extra checks */
  if (data.bookingId) {
    const args: Prisma.BookingFindFirstOrThrowArgs = isAdmin
      ? /* If admin, we only check that the booking exists */
        { where: { id: data.bookingId } }
      : /* For non-admins we make sure the booking belongs to the user */
        { where: { id: data.bookingId, userId } };
    await prisma.booking.findFirstOrThrow(args);
  }
  const booking_reference = await prisma.bookingReference.update({ where: { id }, data });
  return { booking_reference: schemaBookingReferenceReadPublic.parse(booking_reference) };
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaBookingReferenceReadPublic } from "~/lib/validations/booking-reference";
import { schemaQueryIdParseInt } from "~/lib/validations/shared/queryIdTransformParseInt";

/**
 * @swagger
 * /booking-references/{id}:
 *   get:
 *     operationId: getBookingReferenceById
 *     summary: Find a booking reference
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the booking reference to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *      - booking-references
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: BookingReference was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdParseInt.parse(query);
  const booking_reference = await prisma.bookingReference.findUniqueOrThrow({ where: { id } });
  return { booking_reference: schemaBookingReferenceReadPublic.parse(booking_reference) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaBookingReferenceReadPublic } from "~/lib/validations/booking-reference";

/**
 * @swagger
 * /booking-references:
 *   get:
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     operationId: listBookingReferences
 *     summary: Find all booking references
 *     tags:
 *      - booking-references
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No booking references were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const args: Prisma.BookingReferenceFindManyArgs = isAdmin ? {} : { where: { booking: { userId } } };
  const data = await prisma.bookingReference.findMany(args);
  return { booking_references: data.map((br) => schemaBookingReferenceReadPublic.parse(br)) };
}

export default defaultResponder(getHandler);
import type { NextApiRequest, NextApiResponse } from "next";

export default async function CalcomApi(_: NextApiRequest, res: NextApiResponse) {
  res.status(200).json({ message: "Welcome to Cal.com API - docs are at https://developer.cal.com/api" });
}
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";
import { v4 as uuidv4 } from "uuid";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaWebhookCreateBodyParams, schemaWebhookReadPublic } from "~/lib/validations/webhook";

/**
 * @swagger
 * /webhooks:
 *   post:
 *     summary: Creates a new webhook
 *     operationId: addWebhook
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     requestBody:
 *       description: Create a new webhook
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - subscriberUrl
 *               - eventTriggers
 *               - active
 *             properties:
 *               subscriberUrl:
 *                 type: string
 *                 format: uri
 *                 description: The URL to subscribe to this webhook
 *               eventTriggers:
 *                 type: string
 *                 enum: [BOOKING_CREATED, BOOKING_RESCHEDULED, BOOKING_CANCELLED, MEETING_ENDED]
 *                 description: The events which should trigger this webhook call
 *               active:
 *                 type: boolean
 *                 description: Whether the webhook is active and should trigger on associated trigger events
 *               payloadTemplate:
 *                 type: string
 *                 description: The template of the webhook's payload
 *               eventTypeId:
 *                 type: number
 *                 description: The event type ID if this webhook should be associated with only that event type
 *               secret:
 *                 type: string
 *                 description: The secret to verify the authenticity of the received payload
 *     tags:
 *     - webhooks
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/webhooks
 *     responses:
 *       201:
 *         description: OK, webhook created
 *       400:
 *        description: Bad request. webhook body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const {
    eventTypeId,
    userId: bodyUserId,
    eventTriggers,
    ...body
  } = schemaWebhookCreateBodyParams.parse(req.body);
  const args: Prisma.WebhookCreateArgs = { data: { id: uuidv4(), ...body } };

  // If no event type, we assume is for the current user. If admin we run more checks below...
  if (!eventTypeId) args.data.userId = userId;

  if (eventTypeId) {
    const where: Prisma.EventTypeWhereInput = { id: eventTypeId };

    if (!isAdmin) where.userId = userId;
    await prisma.eventType.findFirstOrThrow({ where });
    args.data.eventTypeId = eventTypeId;
  }

  if (!isAdmin && bodyUserId) throw new HttpError({ statusCode: 403, message: `ADMIN required for userId` });

  if (isAdmin && bodyUserId) {
    const where: Prisma.UserWhereInput = { id: bodyUserId };
    await prisma.user.findFirstOrThrow({ where });
    args.data.userId = bodyUserId;
  }

  if (eventTriggers) {
    const eventTriggersSet = new Set(eventTriggers);
    args.data.eventTriggers = Array.from(eventTriggersSet);
  }

  const data = await prisma.webhook.create(args);

  return {
    webhook: schemaWebhookReadPublic.parse(data),
    message: "Webhook created successfully",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";

/**
 * @swagger
 * /webhooks/{id}:
 *   delete:
 *     summary: Remove an existing hook
 *     operationId: removeWebhookById
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric ID of the hooks to delete
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     tags:
 *     - webhooks
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/webhooks
 *     responses:
 *       201:
 *         description: OK, hook removed successfully
 *       400:
 *        description: Bad request. hook id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdAsString.parse(query);
  await prisma.webhook.delete({ where: { id } });
  return { message: `Webhook with id: ${id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { id } = schemaQueryIdAsString.parse(req.query);
  // Admins can just skip this check
  if (isAdmin) return;
  // Check if the current user can access the webhook
  const webhook = await prisma.webhook.findFirst({
    where: { id, appId: null, OR: [{ userId }, { eventType: { team: { members: { some: { userId } } } } }] },
  });
  if (!webhook) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";
import { schemaWebhookEditBodyParams, schemaWebhookReadPublic } from "~/lib/validations/webhook";

/**
 * @swagger
 * /webhooks/{id}:
 *   patch:
 *     summary: Edit an existing webhook
 *     operationId: editWebhookById
 *     parameters:
 *      - in: path
 *        name: id
 *        schema:
 *          type: integer
 *        required: true
 *        description: Numeric ID of the webhook to edit
 *      - in: query
 *        name: apiKey
 *        required: true
 *        schema:
 *          type: string
 *        description: Your API key
 *     requestBody:
 *       description: Edit an existing webhook
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               subscriberUrl:
 *                 type: string
 *                 format: uri
 *                 description: The URL to subscribe to this webhook
 *               eventTriggers:
 *                 type: string
 *                 enum: [BOOKING_CREATED, BOOKING_RESCHEDULED, BOOKING_CANCELLED, MEETING_ENDED]
 *                 description: The events which should trigger this webhook call
 *               active:
 *                 type: boolean
 *                 description: Whether the webhook is active and should trigger on associated trigger events
 *               payloadTemplate:
 *                 type: string
 *                 description: The template of the webhook's payload
 *               eventTypeId:
 *                 type: number
 *                 description: The event type ID if this webhook should be associated with only that event type
 *               secret:
 *                 type: string
 *                 description: The secret to verify the authenticity of the received payload
 *     tags:
 *     - webhooks
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/webhooks
 *     responses:
 *       201:
 *         description: OK, webhook edited successfully
 *       400:
 *        description: Bad request. Webhook body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, userId, isAdmin } = req;
  const { id } = schemaQueryIdAsString.parse(query);
  const {
    eventTypeId,
    userId: bodyUserId,
    eventTriggers,
    ...data
  } = schemaWebhookEditBodyParams.parse(req.body);
  const args: Prisma.WebhookUpdateArgs = { where: { id }, data };

  if (eventTypeId) {
    const where: Prisma.EventTypeWhereInput = { id: eventTypeId };

    if (!isAdmin) where.userId = userId;
    await prisma.eventType.findFirstOrThrow({ where });
    args.data.eventTypeId = eventTypeId;
  }

  if (!isAdmin && bodyUserId) throw new HttpError({ statusCode: 403, message: `ADMIN required for userId` });

  if (isAdmin && bodyUserId) {
    const where: Prisma.UserWhereInput = { id: bodyUserId };
    await prisma.user.findFirstOrThrow({ where });
    args.data.userId = bodyUserId;
  }

  if (eventTriggers) {
    const eventTriggersSet = new Set(eventTriggers);
    args.data.eventTriggers = Array.from(eventTriggersSet);
  }

  const result = await prisma.webhook.update(args);
  return { webhook: schemaWebhookReadPublic.parse(result) };
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaQueryIdAsString } from "~/lib/validations/shared/queryIdString";
import { schemaWebhookReadPublic } from "~/lib/validations/webhook";

/**
 * @swagger
 * /webhooks/{id}:
 *   get:
 *     summary: Find a webhook
 *     operationId: getWebhookById
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: Numeric ID of the webhook to get
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *     - webhooks
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/webhooks
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: Webhook was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const { id } = schemaQueryIdAsString.parse(query);
  const data = await prisma.webhook.findUniqueOrThrow({ where: { id } });
  return { webhook: schemaWebhookReadPublic.parse(data) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";
import { schemaWebhookReadPublic } from "~/lib/validations/webhook";

/**
 * @swagger
 * /webhooks:
 *   get:
 *     summary: Find all webhooks
 *     operationId: listWebhooks
 *     parameters:
 *       - in: query
 *         name: apiKey
 *         required: true
 *         schema:
 *           type: string
 *         description: Your API key
 *     tags:
 *     - webhooks
 *     externalDocs:
 *        url: https://docs.cal.com/core-features/webhooks
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No webhooks were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const args: Prisma.WebhookFindManyArgs = isAdmin
    ? {}
    : { where: { OR: [{ eventType: { userId } }, { userId }] } };

  /** Only admins can query other users */
  if (!isAdmin && req.query.userId) throw new HttpError({ statusCode: 403, message: "ADMIN required" });
  if (isAdmin && req.query.userId) {
    const query = schemaQuerySingleOrMultipleUserIds.parse(req.query);

    const userIds = Array.isArray(query.userId) ? query.userId : [query.userId || userId];
    args.where = { OR: [{ eventType: { userId: { in: userIds } } }, { userId: { in: userIds } }] };

    if (Array.isArray(query.userId)) args.orderBy = { userId: "asc", eventType: { userId: "asc" } };
  }

  const data = await prisma.webhook.findMany(args);
  return { webhooks: data.map((v) => schemaWebhookReadPublic.parse(v)) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import {
  schemaSelectedCalendarBodyParams,
  schemaSelectedCalendarPublic,
} from "~/lib/validations/selected-calendar";

/**
 * @swagger
 * /selected-calendars:
 *   post:
 *     summary: Creates a new selected calendar
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     requestBody:
 *       description: Create a new selected calendar
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - integration
 *               - externalId
 *             properties:
 *               integration:
 *                 type: string
 *                 description: The integration name
 *               externalId:
 *                 type: string
 *                 description: The external ID of the integration
 *     tags:
 *     - selected-calendars
 *     responses:
 *       201:
 *         description: OK, selected calendar created
 *       400:
 *        description: Bad request. SelectedCalendar body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
async function postHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  const { userId: bodyUserId, ...body } = schemaSelectedCalendarBodyParams.parse(req.body);
  const args: Prisma.SelectedCalendarCreateArgs = { data: { ...body, userId } };

  if (!isAdmin && bodyUserId) throw new HttpError({ statusCode: 403, message: `ADMIN required for userId` });

  if (isAdmin && bodyUserId) {
    const where: Prisma.UserWhereInput = { id: bodyUserId };
    await prisma.user.findFirstOrThrow({ where });
    args.data.userId = bodyUserId;
  }

  const data = await prisma.selectedCalendar.create(args);

  return {
    selected_calendar: schemaSelectedCalendarPublic.parse(data),
    message: "Selected Calendar created successfully",
  };
}

export default defaultResponder(postHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
    POST: import("./_post"),
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { selectedCalendarIdSchema } from "~/lib/validations/selected-calendar";

/**
 * @swagger
 * /selected-calendars/{userId}_{integration}_{externalId}:
 *   delete:
 *     operationId: removeSelectedCalendarById
 *     summary: Remove a selected calendar
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: userId
 *        schema:
 *          type: integer
 *        required: true
 *        description: userId of the selected calendar to get
 *      - in: path
 *        name: externalId
 *        schema:
 *          type: integer
 *        required: true
 *        description: externalId of the selected-calendar to get
 *      - in: path
 *        name: integration
 *        schema:
 *          type: string
 *        required: true
 *        description: integration of the selected calendar to get
 *     tags:
 *     - selected-calendars
 *     responses:
 *       201:
 *         description: OK, selected-calendar removed successfully
 *       400:
 *        description: Bad request. SelectedCalendar id is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function deleteHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const userId_integration_externalId = selectedCalendarIdSchema.parse(query);
  await prisma.selectedCalendar.delete({ where: { userId_integration_externalId } });
  return { message: `Selected Calendar with id: ${query.id} deleted successfully` };
}

export default defaultResponder(deleteHandler);
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";

import { selectedCalendarIdSchema } from "~/lib/validations/selected-calendar";

async function authMiddleware(req: NextApiRequest) {
  const { userId, isAdmin } = req;
  const { userId: queryUserId } = selectedCalendarIdSchema.parse(req.query);
  // Admins can just skip this check
  if (isAdmin) return;
  // Check if the current user requesting is the same as the one being requested
  if (userId !== queryUserId) throw new HttpError({ statusCode: 403, message: "Forbidden" });
}

export default authMiddleware;
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import {
  schemaSelectedCalendarPublic,
  schemaSelectedCalendarUpdateBodyParams,
  selectedCalendarIdSchema,
} from "~/lib/validations/selected-calendar";

/**
 * @swagger
 * /selected-calendars/{userId}_{integration}_{externalId}:
 *   patch:
 *     operationId: editSelectedCalendarById
 *     summary: Edit a selected calendar
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: userId
 *        schema:
 *          type: integer
 *        required: true
 *        description: userId of the selected calendar to get
 *      - in: path
 *        name: externalId
 *        schema:
 *          type: string
 *        required: true
 *        description: externalId of the selected calendar to get
 *      - in: path
 *        name: integration
 *        schema:
 *          type: string
 *        required: true
 *        description: integration of the selected calendar to get
 *     tags:
 *     - selected-calendars
 *     responses:
 *       201:
 *         description: OK, selected-calendar edited successfully
 *       400:
 *        description: Bad request. SelectedCalendar body is invalid.
 *       401:
 *        description: Authorization information is missing or invalid.
 */
export async function patchHandler(req: NextApiRequest) {
  const { prisma, query, isAdmin } = req;
  const userId_integration_externalId = selectedCalendarIdSchema.parse(query);
  const { userId: bodyUserId, ...data } = schemaSelectedCalendarUpdateBodyParams.parse(req.body);
  const args: Prisma.SelectedCalendarUpdateArgs = { where: { userId_integration_externalId }, data };

  if (!isAdmin && bodyUserId) throw new HttpError({ statusCode: 403, message: `ADMIN required for userId` });

  if (isAdmin && bodyUserId) {
    const where: Prisma.UserWhereInput = { id: bodyUserId };
    await prisma.user.findFirstOrThrow({ where });
    args.data.userId = bodyUserId;
  }

  const result = await prisma.selectedCalendar.update(args);
  return { selected_calendar: schemaSelectedCalendarPublic.parse(result) };
}

export default defaultResponder(patchHandler);
import type { NextApiRequest, NextApiResponse } from "next";

import { defaultHandler, defaultResponder } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

import authMiddleware from "./_auth-middleware";

export default withMiddleware()(
  defaultResponder(async (req: NextApiRequest, res: NextApiResponse) => {
    await authMiddleware(req);

    return defaultHandler({
      GET: import("./_get"),
      PATCH: import("./_patch"),
      DELETE: import("./_delete"),
    })(req, res);
  })
);
import type { NextApiRequest } from "next";

import { defaultResponder } from "@calcom/lib/server";

import { schemaSelectedCalendarPublic, selectedCalendarIdSchema } from "~/lib/validations/selected-calendar";

/**
 * @swagger
 * /selected-calendars/{userId}_{integration}_{externalId}:
 *   get:
 *     operationId: getSelectedCalendarById
 *     summary: Find a selected calendar by providing the compoundId(userId_integration_externalId) separated by `_`
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *      - in: path
 *        name: userId
 *        schema:
 *          type: integer
 *        required: true
 *        description: userId of the selected calendar to get
 *      - in: path
 *        name: externalId
 *        schema:
 *          type: string
 *        required: true
 *        description: externalId of the selected calendar to get
 *      - in: path
 *        name: integration
 *        schema:
 *          type: string
 *        required: true
 *        description: integration of the selected calendar to get
 *     tags:
 *     - selected-calendars
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: SelectedCalendar was not found
 */
export async function getHandler(req: NextApiRequest) {
  const { prisma, query } = req;
  const userId_integration_externalId = selectedCalendarIdSchema.parse(query);
  const data = await prisma.selectedCalendar.findUniqueOrThrow({
    where: { userId_integration_externalId },
  });
  return { selected_calendar: schemaSelectedCalendarPublic.parse(data) };
}

export default defaultResponder(getHandler);
import type { Prisma } from "@prisma/client";
import type { NextApiRequest } from "next";

import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";

import { schemaSelectedCalendarPublic } from "~/lib/validations/selected-calendar";
import { schemaQuerySingleOrMultipleUserIds } from "~/lib/validations/shared/queryUserId";

/**
 * @swagger
 * /selected-calendars:
 *   get:
 *     operationId: listSelectedCalendars
 *     summary: Find all selected calendars
 *     parameters:
 *      - in: query
 *        name: apiKey
 *        schema:
 *          type: string
 *        required: true
 *        description: Your API Key
 *     tags:
 *     - selected-calendars
 *     responses:
 *       200:
 *         description: OK
 *       401:
 *        description: Authorization information is missing or invalid.
 *       404:
 *         description: No selected calendars were found
 */
async function getHandler(req: NextApiRequest) {
  const { userId, isAdmin, prisma } = req;
  /* Admin gets all selected calendar by default, otherwise only the user's ones */
  const args: Prisma.SelectedCalendarFindManyArgs = isAdmin ? {} : { where: { userId } };

  /** Only admins can query other users */
  if (!isAdmin && req.query.userId) throw new HttpError({ statusCode: 403, message: "ADMIN required" });
  if (isAdmin && req.query.userId) {
    const query = schemaQuerySingleOrMultipleUserIds.parse(req.query);

    const userIds = Array.isArray(query.userId) ? query.userId : [query.userId || userId];
    args.where = { userId: { in: userIds } };

    if (Array.isArray(query.userId)) args.orderBy = { userId: "asc" };
  }

  const data = await prisma.selectedCalendar.findMany(args);
  return { selected_calendars: data.map((v) => schemaSelectedCalendarPublic.parse(v)) };
}

export default defaultResponder(getHandler);
import { defaultHandler } from "@calcom/lib/server";

import { withMiddleware } from "~/lib/helpers/withMiddleware";

export default withMiddleware()(
  defaultHandler({
    GET: import("./_get"),
  })
);
import timezone from "dayjs/plugin/timezone";
import utc from "dayjs/plugin/utc";
import type { NextApiRequest, NextApiResponse } from "next";

import dayjs from "@calcom/dayjs";
import { isSupportedTimeZone } from "@calcom/lib/date-fns";
import { HttpError } from "@calcom/lib/http-error";
import { defaultResponder } from "@calcom/lib/server";
import { createContext } from "@calcom/trpc/server/createContext";
import { getScheduleSchema } from "@calcom/trpc/server/routers/viewer/slots/types";
import { getAvailableSlots } from "@calcom/trpc/server/routers/viewer/slots/util";

import { TRPCError } from "@trpc/server";
import { getHTTPStatusCodeFromError } from "@trpc/server/http";

// Apply plugins
dayjs.extend(utc);
dayjs.extend(timezone);

async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    const { usernameList, ...rest } = req.query;

    let slugs = usernameList;

    if (!Array.isArray(usernameList)) {
      slugs = usernameList ? [usernameList] : undefined;
    }
    const input = getScheduleSchema.parse({ usernameList: slugs, ...rest });

    const timeZoneSupported = input.timeZone ? isSupportedTimeZone(input.timeZone) : false;

    const availableSlots = await getAvailableSlots({ ctx: await createContext({ req, res }), input });

    const slotsInProvidedTimeZone = timeZoneSupported
      ? Object.keys(availableSlots.slots).reduce(
          (acc: Record<string, { time: string; attendees?: number; bookingUid?: string }[]>, date) => {
            acc[date] = availableSlots.slots[date].map((slot) => ({
              ...slot,
              time: dayjs(slot.time).tz(input.timeZone).format(),
            }));

            return acc;
          },
          {}
        )
      : availableSlots.slots;

    return { slots: slotsInProvidedTimeZone };
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } catch (cause) {
    if (cause instanceof TRPCError) {
      const statusCode = getHTTPStatusCodeFromError(cause);
      throw new HttpError({ statusCode, message: cause.message });
    }
    throw cause;
  }
}

export default defaultResponder(handler);
import prismock from "../../../../../tests/libs/__mocks__/prisma";

import type { Request, Response } from "express";
import type { NextApiRequest, NextApiResponse } from "next";
import { createMocks } from "node-mocks-http";
import { describe, expect, test } from "vitest";

import dayjs from "@calcom/dayjs";

import handler from "./_get";

type CustomNextApiRequest = NextApiRequest & Request;
type CustomNextApiResponse = NextApiResponse & Response;

function buildMockData() {
  prismock.user.create({
    data: {
      id: 1,
      username: "test",
      name: "Test User",
      email: "test@example.com",
    },
  });
  prismock.eventType.create({
    data: {
      id: 1,
      slug: "test",
      length: 30,
      title: "Test Event Type",
      userId: 1,
    },
  });
}

describe("GET /api/slots", () => {
  describe("Errors", () => {
    test("Missing required data", async () => {
      const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
        method: "GET",
      });

      await handler(req, res);

      expect(res.statusCode).toBe(400);
      expect(JSON.parse(res._getData())).toMatchInlineSnapshot(`
        {
          "message": "invalid_type in 'startTime': Required; invalid_type in 'endTime': Required",
        }
      `);
    });
  });

  describe("Success", () => {
    describe("Regular event-type", () => {
      test("Returns and event type available slots", async () => {
        const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
          method: "GET",
          query: {
            eventTypeId: 1,
            startTime: dayjs().format(),
            endTime: dayjs().add(1, "day").format(),
            usernameList: "test",
          },
          prisma: prismock,
        });
        buildMockData();
        await handler(req, res);
        console.log({ statusCode: res._getStatusCode(), data: JSON.parse(res._getData()) });
        expect(JSON.parse(res._getData())).toMatchInlineSnapshot(`
          {
            "slots": {},
          }
        `);
      });
      test("Returns and event type available slots with passed timeZone", async () => {
        const { req, res } = createMocks<CustomNextApiRequest, CustomNextApiResponse>({
          method: "GET",
          query: {
            eventTypeId: 1,
            startTime: dayjs().format(),
            endTime: dayjs().add(1, "day").format(),
            usernameList: "test",
            timeZone: "UTC",
          },
          prisma: prismock,
        });
        buildMockData();
        await handler(req, res);
        console.log({ statusCode: res._getStatusCode(), data: JSON.parse(res._getData()) });
        expect(JSON.parse(res._getData())).toMatchInlineSnapshot(`
          {
            "slots": {},
          }
        `);
      });
    });
  });
});
